<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>音视频学习 (十一) Android 端 rtmp 推流 - DevYK 个人博客</title><meta description="前言咱们回顾了前面 2 篇文章，主要讲解了如何搭建 rtmp 直播服务器，和如何开发一款具有拉流功能的 Android 播放器。那么现在有了播放端和直播服务器还缺少推流端。该篇文章我们就一起来实现 Android 端的 rtmp 推流，想要实现 Android 端推流必须要经过如下几个阶段，见下图:"><meta property="og:type" content="blog"><meta property="og:title" content="音视频学习 (十一) Android 端 rtmp 推流"><meta property="og:url" content="http://yoursite.com/2020/06/04/Android-%E5%8D%81%E4%B8%80-Android-%E7%AB%AF-rtmp-%E6%8E%A8%E6%B5%81/"><meta property="og:site_name" content="DevYK 个人博客"><meta property="og:description" content="前言咱们回顾了前面 2 篇文章，主要讲解了如何搭建 rtmp 直播服务器，和如何开发一款具有拉流功能的 Android 播放器。那么现在有了播放端和直播服务器还缺少推流端。该篇文章我们就一起来实现 Android 端的 rtmp 推流，想要实现 Android 端推流必须要经过如下几个阶段，见下图:"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302220507.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302154202.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302204444.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302210529.gif"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302210914.gif"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302170719.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302185720.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302192219.png"><meta property="article:published_time" content="2020-06-04T10:24:00.000Z"><meta property="article:modified_time" content="2020-06-04T15:54:20.080Z"><meta property="article:author" content="DevYK"><meta property="article:tag" content="音视频学习路线"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302220507.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/06/04/Android-%E5%8D%81%E4%B8%80-Android-%E7%AB%AF-rtmp-%E6%8E%A8%E6%B5%81/"},"headline":"DevYK 个人博客","image":["https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302220507.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302154202.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302204444.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302210529.gif","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302210914.gif","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302170719.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302185720.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302192219.png"],"datePublished":"2020-06-04T10:24:00.000Z","dateModified":"2020-06-04T15:54:20.080Z","author":{"@type":"Person","name":"DevYK"},"description":"前言咱们回顾了前面 2 篇文章，主要讲解了如何搭建 rtmp 直播服务器，和如何开发一款具有拉流功能的 Android 播放器。那么现在有了播放端和直播服务器还缺少推流端。该篇文章我们就一起来实现 Android 端的 rtmp 推流，想要实现 Android 端推流必须要经过如下几个阶段，见下图:"}</script><link rel="canonical" href="http://yoursite.com/2020/06/04/Android-%E5%8D%81%E4%B8%80-Android-%E7%AB%AF-rtmp-%E6%8E%A8%E6%B5%81/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="DevYK 个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:24:00.000Z" title="2020-06-04T10:24:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">1 小时 读完 (大约 10131 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">音视频学习 (十一) Android 端 rtmp 推流</h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302220507.png" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>咱们回顾了前面 2 篇文章，主要讲解了如何搭建 rtmp <a href="https://juejin.im/post/5e4ec66c5188254967067502">直播服务器</a>，和如何开发一款具有拉流功能的 Android <a href="https://juejin.im/post/5e495ec1e51d452713551017">播放器</a>。那么现在有了播放端和直播服务器还缺少推流端。该篇文章我们就一起来实现 Android 端的 rtmp 推流，想要实现 Android 端推流必须要经过如下几个阶段，见下图:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302154202.png" alt=""></p>
<a id="more"></a>

<p>该篇文章主要完成上图黄颜色功能部分，下面就开始进入正题，代码编写了。</p>
<h2 id="项目效果"><a href="#项目效果" class="headerlink" title="项目效果"></a>项目效果</h2><h2 id="推流监控"><a href="#推流监控" class="headerlink" title="推流监控"></a>推流监控</h2><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302204444.png" alt=""></p>
<h3 id="软编码"><a href="#软编码" class="headerlink" title="软编码"></a>软编码</h3><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302210529.gif" alt=""></p>
<h3 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h3><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302210914.gif" alt=""></p>
<p>文章末尾会介绍软硬编解码。</p>
<h2 id="音频采集"><a href="#音频采集" class="headerlink" title="音频采集"></a>音频采集</h2><p>Android SDK 提供了两套音频采集的 API ,分别是 MediaRecorder 、AudioRecord 。前者是一个上层 API ,它可以直接对手机麦克风录入的音频数据进行编码压缩(如 AMR/MP3) 等，并存储为文件；后者则更接近底层，能够更加自由灵活地控制，其可以让开发者得到内存中的 PCM 原始音频数据流。如果想做一个简单的录音机，输出音频文件则推荐使用 MediaRecorder ； 如果需要对音频做进一步的算法处理，或者需要采用第三方的编码库进行编码，又或者需要用到网络传输等场景中，那么只能使用 AudioRecord 或者 OpenSL ES ，其实 MediaRecorder 底层也是调用了 AudioRecord 与 Android Framework 层的 AudioFlinger 进行交互的。而我们该篇的场景更倾向于第二种实现方式，即使用 AudioRecord 来采集音频。</p>
<p>如果想要使用 AudioRecord 这个 API ,则需要在应用 AndroidManifest.xml 的配置文件中进行如下配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECORD_AUDIO"</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，如果你想把采集到的 PCM 原始数据，存储 sdcard 中，还需要额外添加写入权限:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来了解一下 AudioRecord 的工作流程。</p>
<h3 id="1-初始化-AudioRecord"><a href="#1-初始化-AudioRecord" class="headerlink" title="1. 初始化 AudioRecord"></a>1. 初始化 AudioRecord</h3><p>首先来看一下 AudioRecord 的配置参数，AudioRecord 是通过构造函数来配置参数的，其函数原型如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AudioRecord</span><span class="params">(<span class="keyword">int</span> audioSource, <span class="keyword">int</span> sampleRateInHz, <span class="keyword">int</span> channelConfig, <span class="keyword">int</span> audioFormat,<span class="keyword">int</span> bufferSizeInBytes)</span></span></span><br></pre></td></tr></table></figure>

<p>上述参数所代表的函数及其在各种场景下应该传递的值的含义参考如下说明:</p>
<p><strong>audioSource:</strong> 该参数指的是音频采集的输入源，可选值以常量的形式定义在类 AudioSource （MediaRecorder 中的一个内部类）中，常用的值包过:</p>
<ul>
<li>DEFAULT(默认)</li>
<li>VOICE_RECOGNITION (用于语音识别，等同于默认)</li>
<li>MIC (由手机麦克风输入)</li>
<li>VOICE_COMMUNICATION (用于 VOIP 应用场景)</li>
</ul>
<p><strong>sampleRateInHz:</strong> 用于指定以多大的采样频率来采集音频，现在用的最多的兼容最好是 44100 (44.1KHZ)采样频率。</p>
<p><strong>channelConfig:</strong> 该参数用于指定录音器采集几个声道的声音，可选值以常量的形式定义在 AudioFormat 类中，常用的值包括:</p>
<ul>
<li>CHANNEL_IN_MONO 单声道 (移动设备上目前推荐使用)</li>
<li>CHANNEL_IN_STEREO 立体声</li>
</ul>
<p><strong>audioFormat:</strong> 采样格式，以常量的形式定义在 AudioFormat 类中，常用的值包括:</p>
<ul>
<li>ENCODING_PCM_16BIT (16bit 兼容大部分 Android 手机)</li>
<li>ENCODING_PCM_8BIT (8bit)</li>
</ul>
<p><strong>bufferSizeInBytes:</strong> 配置内部音频缓冲区的大小(配置的缓存值越小，延时就越低)，而具体的大小，有可能在不同的手机上会有不同的值，那么可以使用如下 API 进行确定缓冲大小:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioRecord.getMinBufferSize(<span class="keyword">int</span> sampleRateInHz, <span class="keyword">int</span> channelConfig, <span class="keyword">int</span> audioFormat);</span><br></pre></td></tr></table></figure>

<p>配置好之后，检查一下 AudioRecord 当前的状态是否可以进行录制，可以通过 AudioRecord##getState 来获取当前的状态:</p>
<ul>
<li>STATE_UNINITIALIZED 还没有初始化，或者初始化失败了</li>
<li>STATE_INITIALIZED 已经初始化成功了。</li>
</ul>
<h3 id="2-开启采集"><a href="#2-开启采集" class="headerlink" title="2. 开启采集"></a>2. 开启采集</h3><p>创建好 AudioRecord 之后，就可以开启音频数据的采集了，可以通过调用下面的函数进行控制麦克风的采集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mAudioRecord.startRecording();</span><br></pre></td></tr></table></figure>

<h3 id="3-提取数据"><a href="#3-提取数据" class="headerlink" title="3. 提取数据"></a>3. 提取数据</h3><p>执行完上一步之后，需要开启一个子线程用于不断的从 AudioRecord 缓冲区读取 PCM 数据，调用如下函数进行读取数据:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(@NonNull <span class="keyword">byte</span>[] audioData, <span class="keyword">int</span> offsetInBytes, <span class="keyword">int</span> sizeInBytes)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-停止采集"><a href="#4-停止采集" class="headerlink" title="4. 停止采集"></a>4. 停止采集</h3><p>如果想要停止采集，那么只需要调用 AudioRecord 的 stop 方法来实现，最后可以通过一个变量先控制子线程停止读取数据，然后在调用 stop 停止最后释放 AudioRecord 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopEncode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//停止的变量标记</span></span><br><span class="line">    mStopFlag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mAudioEncoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">//停止采集</span></span><br><span class="line">        mAudioEncoder.stop();</span><br><span class="line">      	<span class="comment">//释放内存</span></span><br><span class="line">        mAudioEncoder = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视频采集"><a href="#视频采集" class="headerlink" title="视频采集"></a>视频采集</h2><p>视频画面的采集主要是使用各个平台提供的摄像头 API 来实现的，在为摄像头设置了合适的参数之后，将摄像头实时采集的视频帧渲染到屏幕上提供给用户预览，然后将该视频帧传递给编码通道，进行编码。</p>
<h3 id="1-权限配置"><a href="#1-权限配置" class="headerlink" title="1. 权限配置"></a>1. 权限配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name="android.permission.CAMERA"&gt;&lt;/uses-permission&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-打开摄像头"><a href="#2-打开摄像头" class="headerlink" title="2. 打开摄像头"></a>2. 打开摄像头</h3><h4 id="2-1-检查摄像头"><a href="#2-1-检查摄像头" class="headerlink" title="2.1 检查摄像头"></a>2.1 检查摄像头</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCameraService</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CameraDisabledException </span>&#123;</span><br><span class="line">    <span class="comment">// Check if device policy has disabled the camera.</span></span><br><span class="line">    DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(</span><br><span class="line">            Context.DEVICE_POLICY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (dpm.getCameraDisabled(<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CameraDisabledException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-检查摄像头的个数"><a href="#2-2-检查摄像头的个数" class="headerlink" title="2.2 检查摄像头的个数"></a>2.2 检查摄像头的个数</h4><p>检查完摄像头服务后，还需要检查手机上摄像头的个数，如果个数为 0，则说明手机上没有摄像头，这样的话也是不能进行后续操作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;CameraData&gt; <span class="title">getAllCamerasData</span><span class="params">(<span class="keyword">boolean</span> isBackFirst)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;CameraData&gt; cameraDatas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Camera.CameraInfo cameraInfo = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line">    <span class="keyword">int</span> numberOfCameras = Camera.getNumberOfCameras();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfCameras; i++) &#123;</span><br><span class="line">        Camera.getCameraInfo(i, cameraInfo);</span><br><span class="line">        <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">            CameraData cameraData = <span class="keyword">new</span> CameraData(i, CameraData.FACING_FRONT);</span><br><span class="line">            <span class="keyword">if</span>(isBackFirst) &#123;</span><br><span class="line">                cameraDatas.add(cameraData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cameraDatas.add(<span class="number">0</span>, cameraData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">            CameraData cameraData = <span class="keyword">new</span> CameraData(i, CameraData.FACING_BACK);</span><br><span class="line">            <span class="keyword">if</span>(isBackFirst) &#123;</span><br><span class="line">                cameraDatas.add(<span class="number">0</span>, cameraData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cameraDatas.add(cameraData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cameraDatas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的方法中，需要传入一个是否先开启背面摄像头的 boolean 变量，如果变量为 true，则把背面摄像头放在列表第一个，之后打开摄像头的时候，直接获取列表中第一个摄像头相关参数，然后进行打开。这样的设计使得切换摄像头也变得十分简单，切换摄像头时，先关闭当前摄像头，然后变化摄像头列表中的顺序，然后再打开摄像头即可，也就是每次打开摄像头都打开摄像头列表中第一个摄像头参数所指向的摄像头。</p>
<h4 id="2-3-打开摄像头"><a href="#2-3-打开摄像头" class="headerlink" title="2.3 打开摄像头"></a>2.3 打开摄像头</h4><p>打开摄像头之前，先从摄像头列表中获取第一个摄像头参数，之后根据参数中的 CameraId 来打开摄像头，打开成功后改变相关状态。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Camera <span class="title">openCamera</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CameraHardwareException, CameraNotSupportException </span>&#123;</span><br><span class="line">    CameraData cameraData = mCameraDatas.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mCameraDevice != <span class="keyword">null</span> &amp;&amp; mCameraData == cameraData) &#123;</span><br><span class="line">        <span class="keyword">return</span> mCameraDevice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCameraDevice != <span class="keyword">null</span>) &#123;</span><br><span class="line">        releaseCamera();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"open camera "</span> + cameraData.cameraID);</span><br><span class="line">        mCameraDevice = Camera.open(cameraData.cameraID);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"fail to connect Camera"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CameraHardwareException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mCameraDevice == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CameraNotSupportException();</span><br><span class="line">    &#125;</span><br><span class="line">    mCameraData = cameraData;</span><br><span class="line">    mState = State.OPENED;</span><br><span class="line">    <span class="keyword">return</span> mCameraDevice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面需要注意的是，在 Android 提供的 Camera 源码中，Camera.open(cameraData.cameraID) 抛出异常则说明Camera 不可用，否则说明 Camera 可用，但是在一些手机上 Camera.open(cameraData.cameraID) 不是抛出异常，而是返回 null。</p>
<h3 id="3-配置摄像头参数"><a href="#3-配置摄像头参数" class="headerlink" title="3. 配置摄像头参数"></a>3. 配置摄像头参数</h3><p>在给摄像头设置参数后，需要记录这些参数，以方便其他地方使用。比如记录当前摄像头是否有闪光点，从而可以决定 UI 界面上是否显示打开闪光灯按钮。在直播项目中使用 CameraData 来记录这些参数，CameraData 类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FACING_FRONT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FACING_BACK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cameraID;            <span class="comment">//camera的id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cameraFacing;        <span class="comment">//区分前后摄像头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cameraWidth;         <span class="comment">//camera的采集宽度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cameraHeight;        <span class="comment">//camera的采集高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> hasLight;        <span class="comment">//camera是否有闪光灯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> orientation;         <span class="comment">//camera旋转角度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> supportTouchFocus;   <span class="comment">//camera是否支持手动对焦</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> touchFocusMode;      <span class="comment">//camera是否处在自动对焦模式</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraData</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> facing, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        cameraID = id;</span><br><span class="line">        cameraFacing = facing;</span><br><span class="line">        cameraWidth = width;</span><br><span class="line">        cameraHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraData</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> facing)</span> </span>&#123;</span><br><span class="line">        cameraID = id;</span><br><span class="line">        cameraFacing = facing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给摄像头设置参数的时候，有一点需要注意：设置的参数不生效会抛出异常，因此需要每个参数单独设置，这样就避免一个参数不生效后抛出异常，导致之后所有的参数都没有设置。</p>
<h3 id="4-摄像头开启预览"><a href="#4-摄像头开启预览" class="headerlink" title="4. 摄像头开启预览"></a>4. 摄像头开启预览</h3><p>设置预览界面有两种方式：1、通过 SurfaceView 显示；2、通过 GLSurfaceView 显示。当为 SurfaceView 显示时，需要传给 Camera 这个 SurfaceView 的 SurfaceHolder。当使用 GLSurfaceView 显示时，需要使用Renderer 进行渲染，先通过 OpenGL 生成纹理，通过生成纹理的纹理 id 生成 SurfaceTexture ，将SurfaceTexture 交给 Camera ，那么在 Render 中便可以使用这个纹理进行相应的渲染，最后通过GLSurfaceView 显示。</p>
<h4 id="4-1-设置预览回调"><a href="#4-1-设置预览回调" class="headerlink" title="4.1 设置预览回调"></a>4.1 设置预览回调</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPreviewFormat</span><span class="params">(Camera camera, Camera.Parameters parameters)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置预览回调的图片格式</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parameters.setPreviewFormat(ImageFormat.NV21);</span><br><span class="line">        camera.setParameters(parameters);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当设置预览好预览回调的图片格式后，需要设置预览回调的 Callback。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Camera.PreviewCallback myCallback = <span class="keyword">new</span> Camera.PreviewCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//得到相应的图片数据</span></span><br><span class="line">        <span class="comment">//Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPreviewCallback</span><span class="params">(Camera camera, Camera.PreviewCallback callback)</span> </span>&#123;</span><br><span class="line">    camera.setPreviewCallback(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Android 推荐的 PreViewFormat 是 NV21，在 PreviewCallback 中会返回 Preview 的 N21 图片。如果是软编的话，由于 H264 支持 I420 的图片格式，因此需要将 N21格式转为 I420 格式，然后交给 x264 编码库。如果是硬编的话，由于 Android 硬编编码器支持 I420(COLOR_FormatYUV420Planar) 和NV12(COLOR_FormatYUV420SemiPlanar)，因此可以将 N21 的图片转为 I420 或者 NV12 ，然后交给硬编编码器。</p>
<h4 id="4-2-设置预览图像大小"><a href="#4-2-设置预览图像大小" class="headerlink" title="4.2 设置预览图像大小"></a>4.2 设置预览图像大小</h4><p>在摄像头相关处理中，一个比较重要的是 <strong>屏幕显示大小和摄像头预览大小比例不一致</strong> 的处理。在 Android 中，摄像头有一系列的 PreviewSize，我们需要从中选出适合的 PreviewSize 。选择合适的摄像头 PreviewSize 的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Camera.<span class="function">Size <span class="title">getOptimalPreviewSize</span><span class="params">(Camera camera, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    Camera.Size optimalSize = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">double</span> minHeightDiff = Double.MAX_VALUE;</span><br><span class="line">    <span class="keyword">double</span> minWidthDiff = Double.MAX_VALUE;</span><br><span class="line">    List&lt;Camera.Size&gt; sizes = camera.getParameters().getSupportedPreviewSizes();</span><br><span class="line">    <span class="keyword">if</span> (sizes == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//找到宽度差距最小的</span></span><br><span class="line">    <span class="keyword">for</span>(Camera.Size size:sizes)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(size.width - width) &lt; minWidthDiff) &#123;</span><br><span class="line">            minWidthDiff = Math.abs(size.width - width);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在宽度差距最小的里面，找到高度差距最小的</span></span><br><span class="line">    <span class="keyword">for</span>(Camera.Size size:sizes)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(size.width - width) == minWidthDiff) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(size.height - height) &lt; minHeightDiff) &#123;</span><br><span class="line">                optimalSize = size;</span><br><span class="line">                minHeightDiff = Math.abs(size.height - height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> optimalSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPreviewSize</span><span class="params">(Camera camera, Camera.Size size, Camera.Parameters parameters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;    </span><br><span class="line">        parameters.setPreviewSize(size.width, size.height);           </span><br><span class="line">        camera.setParameters(parameters);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;    </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设置好最适合的 PreviewSize 之后，将 size 信息存储在 CameraData 中。当选择了 SurfaceView 显示的方式，可以将 SurfaceView 放置在一个 LinearLayout 中，然后根据摄像头 PreviewSize 的比例改变 SurfaceView 的大小，从而使得两者比例一致，确保图像正常。当选择了GLSurfaceView 显示的时候，可以通过裁剪纹理，使得纹理的大小比例和 GLSurfaceView 的大小比例保持一致，从而确保图像显示正常。</p>
<h4 id="4-3-图像旋转"><a href="#4-3-图像旋转" class="headerlink" title="4.3 图像旋转"></a>4.3 图像旋转</h4><p>在 Android 中摄像头出来的图像需要进行一定的旋转，然后才能交给屏幕显示，而且如果应用支持屏幕旋转的话，也需要根据旋转的状况实时调整摄像头的角度。在 Android 中旋转摄像头图像同样有两种方法，一是通过摄像头的 setDisplayOrientation(result) 方法，一是通过 OpenGL 的矩阵进行旋转。下面是通过setDisplayOrientation(result) 方法进行旋转的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDisplayRotation</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">    <span class="keyword">switch</span> (rotation) &#123;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_0: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_90: <span class="keyword">return</span> <span class="number">90</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_180: <span class="keyword">return</span> <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_270: <span class="keyword">return</span> <span class="number">270</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCameraDisplayOrientation</span><span class="params">(Activity activity, <span class="keyword">int</span> cameraId, Camera camera)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See android.hardware.Camera.setCameraDisplayOrientation for</span></span><br><span class="line">    <span class="comment">// documentation.</span></span><br><span class="line">    Camera.CameraInfo info = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line">    Camera.getCameraInfo(cameraId, info);</span><br><span class="line">    <span class="keyword">int</span> degrees = getDisplayRotation(activity);</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">        result = (info.orientation + degrees) % <span class="number">360</span>;</span><br><span class="line">        result = (<span class="number">360</span> - result) % <span class="number">360</span>; <span class="comment">// compensate the mirror</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// back-facing</span></span><br><span class="line">        result = (info.orientation - degrees + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    camera.setDisplayOrientation(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-设置预览帧率"><a href="#4-4-设置预览帧率" class="headerlink" title="4.4 设置预览帧率"></a>4.4 设置预览帧率</h4><p>通过 Camera.Parameters 中 getSupportedPreviewFpsRange() 可以获得摄像头支持的帧率变化范围，从中选取合适的设置给摄像头即可。相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCameraFps</span><span class="params">(Camera camera, <span class="keyword">int</span> fps)</span> </span>&#123;</span><br><span class="line">    Camera.Parameters params = camera.getParameters();</span><br><span class="line">    <span class="keyword">int</span>[] range = adaptPreviewFps(fps, params.getSupportedPreviewFpsRange());</span><br><span class="line">    params.setPreviewFpsRange(range[<span class="number">0</span>], range[<span class="number">1</span>]);</span><br><span class="line">    camera.setParameters(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] adaptPreviewFps(<span class="keyword">int</span> expectedFps, List&lt;<span class="keyword">int</span>[]&gt; fpsRanges) &#123;</span><br><span class="line">    expectedFps *= <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span>[] closestRange = fpsRanges.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> measure = Math.abs(closestRange[<span class="number">0</span>] - expectedFps) + Math.abs(closestRange[<span class="number">1</span>] - expectedFps);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] range : fpsRanges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (range[<span class="number">0</span>] &lt;= expectedFps &amp;&amp; range[<span class="number">1</span>] &gt;= expectedFps) &#123;</span><br><span class="line">            <span class="keyword">int</span> curMeasure = Math.abs(range[<span class="number">0</span>] - expectedFps) + Math.abs(range[<span class="number">1</span>] - expectedFps);</span><br><span class="line">            <span class="keyword">if</span> (curMeasure &lt; measure) &#123;</span><br><span class="line">                closestRange = range;</span><br><span class="line">                measure = curMeasure;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closestRange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-设置相机对焦"><a href="#4-5-设置相机对焦" class="headerlink" title="4.5 设置相机对焦"></a>4.5 设置相机对焦</h4><p>一般摄像头对焦的方式有两种：手动对焦和触摸对焦。下面的代码分别是设置自动对焦和触摸对焦的模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAutoFocusMode</span><span class="params">(Camera camera)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Camera.Parameters parameters = camera.getParameters();</span><br><span class="line">        List&lt;String&gt; focusModes = parameters.getSupportedFocusModes();</span><br><span class="line">        <span class="keyword">if</span> (focusModes.size() &gt; <span class="number">0</span> &amp;&amp; focusModes.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) &#123;</span><br><span class="line">            parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (focusModes.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            parameters.setFocusMode(focusModes.get(<span class="number">0</span>));</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTouchFocusMode</span><span class="params">(Camera camera)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Camera.Parameters parameters = camera.getParameters();</span><br><span class="line">        List&lt;String&gt; focusModes = parameters.getSupportedFocusModes();</span><br><span class="line">        <span class="keyword">if</span> (focusModes.size() &gt; <span class="number">0</span> &amp;&amp; focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) &#123;</span><br><span class="line">            parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (focusModes.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            parameters.setFocusMode(focusModes.get(<span class="number">0</span>));</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于自动对焦这样设置后就完成了工作，但是对于触摸对焦则需要设置对应的对焦区域。要准确地设置对焦区域，有三个步骤：一、得到当前点击的坐标位置；二、通过点击的坐标位置转换到摄像头预览界面坐标系统上的坐标；三、根据坐标生成对焦区域并且设置给摄像头。整个摄像头预览界面定义了如下的坐标系统，对焦区域也需要对应到这个坐标系统中。<br><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302170719.png" alt=""></p>
<p>如果摄像机预览界面是通过 SurfaceView 显示的则比较简单，由于要确保不变形，会将 SurfaceView 进行拉伸，从而使得 SurfaceView 和预览图像大小比例一致，因此整个 SurfaceView 相当于预览界面，只需要得到当前点击点在整个 SurfaceView 上对应的坐标，然后转化为相应的对焦区域即可。如果摄像机预览界面是通过GLSurfaceView 显示的则要复杂一些，由于纹理需要进行裁剪，才能使得显示不变形，这样的话，我们要还原出整个预览界面的大小，然后通过当前点击的位置换算成预览界面坐标系统上的坐标，然后得到相应的对焦区域，然后设置给摄像机。当设置好对焦区域后，通过调用 Camera 的 autoFocus() 方法即可完成触摸对焦。<br>整个过程代码量较多，请自行阅读项目源码。</p>
<h4 id="4-6-设置缩放"><a href="#4-6-设置缩放" class="headerlink" title="4.6 设置缩放"></a>4.6 设置缩放</h4><p>当检测到手势缩放的时候，我们往往希望摄像头也能进行相应的缩放，其实这个实现还是比较简单的。首先需要加入缩放的手势识别，当识别到缩放的手势的时候，根据缩放的大小来对摄像头进行缩放。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles the pinch-to-zoom gesture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoomGestureListener</span> <span class="keyword">extends</span> <span class="title">ScaleGestureDetector</span>.<span class="title">SimpleOnScaleGestureListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScale</span><span class="params">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mIsFocusing) &#123;</span><br><span class="line">            <span class="keyword">float</span> progress = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (detector.getScaleFactor() &gt; <span class="number">1.0f</span>) &#123;</span><br><span class="line">                progress = CameraHolder.instance().cameraZoom(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (detector.getScaleFactor() &lt; <span class="number">1.0f</span>) &#123;</span><br><span class="line">                progress = CameraHolder.instance().cameraZoom(<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mZoomListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mZoomListener.onZoomProgress(progress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cameraZoom</span><span class="params">(<span class="keyword">boolean</span> isBig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mState != State.PREVIEW || mCameraDevice == <span class="keyword">null</span> || mCameraData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Camera.Parameters params = mCameraDevice.getParameters();</span><br><span class="line">    <span class="keyword">if</span>(isBig) &#123;</span><br><span class="line">        params.setZoom(Math.min(params.getZoom() + <span class="number">1</span>, params.getMaxZoom()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        params.setZoom(Math.max(params.getZoom() - <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    mCameraDevice.setParameters(params);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>) params.getZoom()/params.getMaxZoom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-闪光灯操作"><a href="#4-7-闪光灯操作" class="headerlink" title="4.7 闪光灯操作"></a>4.7 闪光灯操作</h4><p>一个摄像头可能有相应的闪光灯，也可能没有，因此在使用闪光灯功能的时候先要确认是否有相应的闪光灯。检测摄像头是否有闪光灯的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">supportFlash</span><span class="params">(Camera camera)</span></span>&#123;</span><br><span class="line">    Camera.Parameters params = camera.getParameters();</span><br><span class="line">    List&lt;String&gt; flashModes = params.getSupportedFlashModes();</span><br><span class="line">    <span class="keyword">if</span>(flashModes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String flashMode : flashModes) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切换闪光灯的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">switchLight</span><span class="params">(Camera camera, Camera.Parameters cameraParameters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cameraParameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_OFF)) &#123;</span><br><span class="line">        cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        camera.setParameters(cameraParameters);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-开始预览"><a href="#4-8-开始预览" class="headerlink" title="4.8 开始预览"></a>4.8 开始预览</h4><p>当打开了摄像头，并且设置好了摄像头相关的参数后，便可以通过调用 Camera 的 startPreview() 方法开始预览。有一个需要说明，无论是 SurfaceView 还是 GLSurfaceView ，都可以设置 SurfaceHolder.Callback ，当界面开始显示的时候打开摄像头并且开始预览，当界面销毁的时候停止预览并且关闭摄像头，这样的话当程序退到后台，其他应用也能调用摄像头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private SurfaceHolder.Callback mSurfaceHolderCallback &#x3D; new SurfaceHolder.Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceDestroyed(SurfaceHolder holder) &#123;</span><br><span class="line">        Log.d(SopCastConstant.TAG, &quot;SurfaceView destroy&quot;);</span><br><span class="line">        CameraHolder.instance().stopPreview();</span><br><span class="line">        CameraHolder.instance().releaseCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.GINGERBREAD)</span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceCreated(SurfaceHolder holder) &#123;</span><br><span class="line">        Log.d(SopCastConstant.TAG, &quot;SurfaceView created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</span><br><span class="line">     Log.d(SopCastConstant.TAG, &quot;SurfaceView width:&quot; + width + &quot; height:&quot; + height);</span><br><span class="line">        CameraHolder.instance().openCamera();</span><br><span class="line">        CameraHolder.instance().startPreview();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-停止预览"><a href="#5-停止预览" class="headerlink" title="5. 停止预览"></a>5. 停止预览</h3><p>停止预览只需要释放掉相机资源即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">releaseCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == State.PREVIEW) &#123;</span><br><span class="line">        stopPreview();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mState != State.OPENED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCameraDevice == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCameraDevice.release();</span><br><span class="line">    mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">    mCameraData = <span class="keyword">null</span>;</span><br><span class="line">    mState = State.INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h2><p>AudioRecord 采集完之后需要对 PCM 数据进行实时的编码 (软编利用 <a href="https://sourceforge.net/projects/faac/files/faac-src/">libfaac</a> 通过 NDK 交叉编译静态库、硬编使用 Android SDK MediaCodec 进行编码)。</p>
<h3 id="软编"><a href="#软编" class="headerlink" title="软编"></a>软编</h3><p>语音软编这里们用主流的编码库 libfaac 进行编码 AAC 语音格式数据。 </p>
<h4 id="1-编译-libfaac"><a href="#1-编译-libfaac" class="headerlink" title="1. 编译 libfaac"></a>1. 编译 libfaac</h4><h5 id="1-1-下载-libfaac"><a href="#1-1-下载-libfaac" class="headerlink" title="1.1 下载 libfaac"></a>1.1 下载 libfaac</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceforge.net/projects/faac/files/faac-src/faac-1.29/faac-1.29.9.2.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="1-2-编写交叉编译脚本"><a href="#1-2-编写交叉编译脚本" class="headerlink" title="1.2 编写交叉编译脚本"></a>1.2 编写交叉编译脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打包地址</span></span><br><span class="line">PREFIX=`pwd`/android/armeabi-v7a</span><br><span class="line"><span class="meta">#</span><span class="bash">配置NDK 环境变量</span></span><br><span class="line">NDK_ROOT=$NDK_HOME</span><br><span class="line"><span class="meta">#</span><span class="bash">指定 CPU</span></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"><span class="meta">#</span><span class="bash">指定 Android API</span></span><br><span class="line">ANDROID_API=17</span><br><span class="line"><span class="meta">#</span><span class="bash">编译工具链目录</span></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">FLAGS="-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS  -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC"</span><br><span class="line"></span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi</span><br><span class="line">export CC="$CROSS_COMPILE-gcc --sysroot=$NDK_ROOT/platforms/android-17/arch-arm"</span><br><span class="line">export CFLAGS="$FLAGS"</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--with-pic \</span><br><span class="line">--enable-shared=no</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="2-CMakeLists-txt-配置"><a href="#2-CMakeLists-txt-配置" class="headerlink" title="2. CMakeLists.txt 配置"></a>2. CMakeLists.txt 配置</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"><span class="comment">#语音编码器</span></span><br><span class="line"><span class="keyword">set</span>(faac <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/faac)</span><br><span class="line"><span class="comment">#加载 faac 头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;faac&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#指定 faac 静态库文件目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;faac&#125;/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"><span class="comment">#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了</span></span><br><span class="line"><span class="keyword">file</span>(GLOB Push_CPP <span class="variable">$&#123;ykpusher&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment">#添加自己编写 cpp 源文件生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(ykpusher SHARED <span class="variable">$&#123;Push_CPP&#125;</span>)</span><br><span class="line"><span class="comment">#找系统中 NDK log库</span></span><br><span class="line"><span class="keyword">find_library</span>(log_lib</span><br><span class="line">        log)</span><br><span class="line"><span class="comment">#推流 so</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        <span class="comment">#播放 so</span></span><br><span class="line">        ykpusher</span><br><span class="line"><span class="comment">#        # 写了此命令不用在乎添加 ffmpeg lib 顺序问题导致应用崩溃</span></span><br><span class="line"><span class="comment">#        -Wl,--start-group</span></span><br><span class="line"><span class="comment">#        avcodec avfilter avformat avutil swresample swscale</span></span><br><span class="line"><span class="comment">#        -Wl,--end-group</span></span><br><span class="line"><span class="comment">#        z</span></span><br><span class="line">        <span class="comment">#推流库</span></span><br><span class="line">        rtmp</span><br><span class="line">        <span class="comment">#视频编码</span></span><br><span class="line">        x264</span><br><span class="line">        <span class="comment">#语音编码</span></span><br><span class="line">        faac</span><br><span class="line">        <span class="comment">#本地库</span></span><br><span class="line">        android</span><br><span class="line">        <span class="variable">$&#123;log_lib&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h4 id="3-配置-faac-编码参数"><a href="#3-配置-faac-编码参数" class="headerlink" title="3. 配置 faac 编码参数"></a>3. 配置 faac 编码参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置语音软编码参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioEncoderChannel::setAudioEncoderInfo</span><span class="params">(<span class="keyword">int</span> samplesHZ, <span class="keyword">int</span> channel)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//如果已经初始化，需要释放</span></span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line">    <span class="comment">//通道 默认单声道</span></span><br><span class="line">    mChannels = channel;</span><br><span class="line">    <span class="comment">//打开编码器</span></span><br><span class="line">    <span class="comment">//3、一次最大能输入编码器的样本数量 也编码的数据的个数 (一个样本是16位 2字节)</span></span><br><span class="line">    <span class="comment">//4、最大可能的输出数据  编码后的最大字节数</span></span><br><span class="line">    mAudioCodec = faacEncOpen(samplesHZ, channel, &amp;mInputSamples, &amp;mMaxOutputBytes);</span><br><span class="line">    <span class="keyword">if</span> (!mAudioCodec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIPushCallback) &#123;</span><br><span class="line">            mIPushCallback-&gt;onError(THREAD_MAIN, FAAC_ENC_OPEN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置编码器参数</span></span><br><span class="line">    faacEncConfigurationPtr <span class="built_in">config</span> = faacEncGetCurrentConfiguration(mAudioCodec);</span><br><span class="line">    <span class="comment">//指定为 mpeg4 标准</span></span><br><span class="line">    <span class="built_in">config</span>-&gt;mpegVersion = MPEG4;</span><br><span class="line">    <span class="comment">//lc 标准</span></span><br><span class="line">    <span class="built_in">config</span>-&gt;aacObjectType = <span class="literal">LOW</span>;</span><br><span class="line">    <span class="comment">//16位</span></span><br><span class="line">    <span class="built_in">config</span>-&gt;inputFormat = FAAC_INPUT_16BIT;</span><br><span class="line">    <span class="comment">// 编码出原始数据 既不是adts也不是adif</span></span><br><span class="line">    <span class="built_in">config</span>-&gt;outputFormat = <span class="number">0</span>;</span><br><span class="line">    faacEncSetConfiguration(mAudioCodec, <span class="built_in">config</span>);</span><br><span class="line">    <span class="comment">//输出缓冲区 编码后的数据 用这个缓冲区来保存</span></span><br><span class="line">    mBuffer = <span class="keyword">new</span> u_char[mMaxOutputBytes];</span><br><span class="line">  	<span class="comment">//设置一个标志，用于开启编码</span></span><br><span class="line">    isStart = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-配置-AAC-包头"><a href="#4-配置-AAC-包头" class="headerlink" title="4. 配置 AAC 包头"></a>4. 配置 AAC 包头</h4><p>在发送 rtmp 音视频包的时候需要将语音包头第一个发送</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频头包数据</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">RTMPPacket *<span class="title">AudioEncoderChannel::getAudioTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAudioCodec) &#123;</span><br><span class="line">        setAudioEncoderInfo(FAAC_DEFAUTE_SAMPLE_RATE, FAAC_DEFAUTE_SAMPLE_CHANNEL);</span><br><span class="line">        <span class="keyword">if</span> (!mAudioCodec)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    u_char *buf;</span><br><span class="line">    u_long len;</span><br><span class="line">    faacEncGetDecoderSpecificInfo(mAudioCodec, &amp;buf, &amp;len);</span><br><span class="line">    <span class="keyword">int</span> bodySize = <span class="number">2</span> + len;</span><br><span class="line">    RTMPPacket *packet = <span class="keyword">new</span> RTMPPacket;</span><br><span class="line">    RTMPPacket_Alloc(packet, bodySize);</span><br><span class="line">    <span class="comment">//双声道</span></span><br><span class="line">    packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0xAF</span>;</span><br><span class="line">    <span class="keyword">if</span> (mChannels == <span class="number">1</span>) &#123; <span class="comment">//单身道</span></span><br><span class="line">        packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0xAE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    packet-&gt;m_body[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//将包头数据 copy 到RTMPPacket 中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[<span class="number">2</span>], buf, len);</span><br><span class="line">		<span class="comment">//是否使用绝对时间戳</span></span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = FALSE;</span><br><span class="line">  	<span class="comment">//包大小</span></span><br><span class="line">    packet-&gt;m_nBodySize = bodySize;</span><br><span class="line">  	<span class="comment">//包类型</span></span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO;</span><br><span class="line">  	<span class="comment">//语音通道</span></span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x11</span>;</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    <span class="keyword">return</span> packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-开始实时编码"><a href="#5-开始实时编码" class="headerlink" title="5. 开始实时编码"></a>5. 开始实时编码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioEncoderChannel::encodeData</span><span class="params">(<span class="keyword">int8_t</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAudioCodec || !isStart)<span class="comment">//不符合编码要求，退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//返回编码后的数据字节长度</span></span><br><span class="line">    <span class="keyword">int</span> bytelen = faacEncEncode(mAudioCodec, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int32_t</span> *&gt;(data), mInputSamples,mBuffer, mMaxOutputBytes);</span><br><span class="line">    <span class="keyword">if</span> (bytelen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//开始打包 rtmp</span></span><br><span class="line">        <span class="keyword">int</span> bodySize = <span class="number">2</span> + bytelen;</span><br><span class="line">        RTMPPacket *packet = <span class="keyword">new</span> RTMPPacket;</span><br><span class="line">        RTMPPacket_Alloc(packet, bodySize);</span><br><span class="line">        <span class="comment">//双声道</span></span><br><span class="line">        packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0xAF</span>;</span><br><span class="line">        <span class="keyword">if</span> (mChannels == <span class="number">1</span>) &#123;</span><br><span class="line">            packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0xAE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编码出的音频 都是 0x01</span></span><br><span class="line">        packet-&gt;m_body[<span class="number">1</span>] = <span class="number">0x01</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[<span class="number">2</span>], mBuffer, bytelen);</span><br><span class="line"></span><br><span class="line">        packet-&gt;m_hasAbsTimestamp = FALSE;</span><br><span class="line">        packet-&gt;m_nBodySize = bodySize;</span><br><span class="line">        packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO;</span><br><span class="line">        packet-&gt;m_nChannel = <span class="number">0x11</span>;</span><br><span class="line">        packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">        <span class="comment">//发送 rtmp packet，回调给 RTMP send 模块</span></span><br><span class="line">        mAudioCallback(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-释放编码器"><a href="#6-释放编码器" class="headerlink" title="6. 释放编码器"></a>6. 释放编码器</h4><p>在不需要编码或者退出编码的时候需要主动释放编码器，释放 native 内存，可以通过如下函数来实现释放编码器的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioEncoderChannel::release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//退出编码的标志</span></span><br><span class="line">    isStart = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//释放编码器</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioCodec) &#123;</span><br><span class="line">      	<span class="comment">//关闭编码器</span></span><br><span class="line">        faacEncClose(mAudioCodec);</span><br><span class="line">      	<span class="comment">//释放缓冲区</span></span><br><span class="line">      	DELETE(mBuffer);</span><br><span class="line">        mAudioCodec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬编"><a href="#硬编" class="headerlink" title="硬编"></a>硬编</h3><p>软编码介绍完了下面利用 Android SDK 自带的 MediaCodec 函数进行对 PCM 编码为 AAC 的格式音频数据。使用 MediaCodec 编码 AAC 对 Android 系统是有要求的，必须是 4.1系统以上，即要求 Android 的版本代号在 Build.VERSION_CODES.JELLY_BEAN (16) 以上。MediaCodec 是 Android 系统提供的硬件编码器，它可以利用设备的硬件来完成编码，从而大大提高编码的效率，还可以降低电量的使用，但是其在兼容性方面不如软编号，因为 Android 设备的锁片化太严重，所以读者可以自己衡量在应用中是否使用 Android 平台的硬件编码特性。</p>
<h4 id="1-创建-quot-audio-mp4a-latm-quot-类型的硬编码器"><a href="#1-创建-quot-audio-mp4a-latm-quot-类型的硬编码器" class="headerlink" title="1. 创建 &quot;audio/mp4a-latm&quot; 类型的硬编码器"></a>1. 创建 <code>&quot;audio/mp4a-latm&quot;</code> 类型的硬编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaCodec = MediaCodec.createEncoderByType(configuration.mime);</span><br></pre></td></tr></table></figure>

<h4 id="2-配置音频硬编码器"><a href="#2-配置音频硬编码器" class="headerlink" title="2.   配置音频硬编码器"></a>2.   配置音频硬编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MediaCodec <span class="title">getAudioMediaCodec</span><span class="params">(AudioConfiguration configuration)</span></span>&#123;</span><br><span class="line">    MediaFormat format = MediaFormat.createAudioFormat(configuration.mime, configuration.frequency, configuration.channelCount);</span><br><span class="line">    <span class="keyword">if</span>(configuration.mime.equals(AudioConfiguration.DEFAULT_MIME)) &#123;</span><br><span class="line">        format.setInteger(MediaFormat.KEY_AAC_PROFILE, configuration.aacProfile);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//语音码率</span></span><br><span class="line">    format.setInteger(MediaFormat.KEY_BIT_RATE, configuration.maxBps * <span class="number">1024</span>);</span><br><span class="line">  	<span class="comment">//语音采样率 44100</span></span><br><span class="line">    format.setInteger(MediaFormat.KEY_SAMPLE_RATE, configuration.frequency);</span><br><span class="line">    <span class="keyword">int</span> maxInputSize = AudioUtils.getRecordBufferSize(configuration);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, configuration.channelCount);</span><br><span class="line"></span><br><span class="line">    MediaCodec mediaCodec = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mediaCodec = MediaCodec.createEncoderByType(configuration.mime);</span><br><span class="line">      	<span class="comment">//MediaCodec.CONFIGURE_FLAG_ENCODE 代表编码器，解码传 0 即可</span></span><br><span class="line">        mediaCodec.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (mediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mediaCodec.stop();</span><br><span class="line">            mediaCodec.release();</span><br><span class="line">            mediaCodec = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mediaCodec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-开启音频硬编码器"><a href="#3-开启音频硬编码器" class="headerlink" title="3. 开启音频硬编码器"></a>3. 开启音频硬编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepareEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   mMediaCodec = AudioMediaCodec.getAudioMediaCodec(mAudioConfiguration);</span><br><span class="line">   mMediaCodec.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-拿到硬编码输入-PCM-输出-AAC-ByteBufferer"><a href="#4-拿到硬编码输入-PCM-输出-AAC-ByteBufferer" class="headerlink" title="4. 拿到硬编码输入(PCM)输出(AAC) ByteBufferer"></a>4. 拿到硬编码输入(PCM)输出(AAC) ByteBufferer</h4><p>到了这一步说明，音频编码器配置完成并且也成功开启了，现在就可以从 MediaCodec 实例中获取两个 buffer ，一个是输入 buffer 一个是输出 buffer , 输入 buffer 类似于 FFmpeg 中的 AVFrame 存放待编码的 PCM 数据，输出 buffer 类似于 FFmpeg 的 AVPacket 编码之后的 AAC 数据, 其代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放的是 PCM 数据</span></span><br><span class="line">ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers();</span><br><span class="line"><span class="comment">//存放的是编码之后的 AAC 数据</span></span><br><span class="line">ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers();</span><br></pre></td></tr></table></figure>

<h4 id="5-开始-PCM-硬编码为-AAC"><a href="#5-开始-PCM-硬编码为-AAC" class="headerlink" title="5. 开始 PCM 硬编码为 AAC"></a>5. 开始 PCM 硬编码为 AAC</h4><p>到此，所有初始化方法已实现完毕，下面来看一下 MediaCodec 的工作原理如下图所示，左边 Client 元素代表要将 PCM 放到 inputBuffer 中的某个具体的 buffer 中去，右边的 Client 元素代表将编码之后的原始 AAC 数据从 outputBuffer 中的某个具体 buffer 中取出来，👈 左边的小方块代表各个 inputBuffer 元素，右边的小方块则代表各个 outputBuffer 元素。详细介绍可以看 <a href="https://developer.android.com/reference/android/media/MediaCodec">MediaCodec 类介绍</a>。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302185720.png" alt=""></p>
<p>代表具体实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//input:PCM  </span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">offerEncoder</span><span class="params">(<span class="keyword">byte</span>[] input)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(mMediaCodec == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers();</span><br><span class="line">       ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers();</span><br><span class="line">       <span class="keyword">int</span> inputBufferIndex = mMediaCodec.dequeueInputBuffer(<span class="number">12000</span>);</span><br><span class="line">       <span class="keyword">if</span> (inputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           ByteBuffer inputBuffer = inputBuffers[inputBufferIndex];</span><br><span class="line">           inputBuffer.clear();</span><br><span class="line">           inputBuffer.put(input);</span><br><span class="line">           mMediaCodec.queueInputBuffer(inputBufferIndex, <span class="number">0</span>, input.length, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> outputBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">12000</span>);</span><br><span class="line">       <span class="keyword">while</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           ByteBuffer outputBuffer = outputBuffers[outputBufferIndex];</span><br><span class="line">           <span class="keyword">if</span>(mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">             	<span class="comment">//将 AAC 数据回调出去</span></span><br><span class="line">               mListener.onAudioEncode(outputBuffer, mBufferInfo);</span><br><span class="line">           &#125;</span><br><span class="line">         	<span class="comment">//释放当前内部编码内存</span></span><br><span class="line">           mMediaCodec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">           outputBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-AAC-打包为-flv"><a href="#6-AAC-打包为-flv" class="headerlink" title="6. AAC 打包为 flv"></a>6. AAC 打包为 flv</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioData</span><span class="params">(ByteBuffer bb, MediaCodec.BufferInfo bi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packetListener == <span class="keyword">null</span> || !isHeaderWrite || !isKeyFrameWrite) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bb.position(bi.offset);</span><br><span class="line">    bb.limit(bi.offset + bi.size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] audio = <span class="keyword">new</span> <span class="keyword">byte</span>[bi.size];</span><br><span class="line">    bb.get(audio);</span><br><span class="line">    <span class="keyword">int</span> size = AUDIO_HEADER_SIZE + audio.length;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(size);</span><br><span class="line">    FlvPackerHelper.writeAudioTag(buffer, audio, <span class="keyword">false</span>, mAudioSampleSize);</span><br><span class="line">    packetListener.onPacket(buffer.array(), AUDIO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAudioTag</span><span class="params">(ByteBuffer buffer, <span class="keyword">byte</span>[] audioInfo, <span class="keyword">boolean</span> isFirst, <span class="keyword">int</span> audioSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//写入音频头信息</span></span><br><span class="line">    writeAudioHeader(buffer, isFirst, audioSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入音频信息</span></span><br><span class="line">    buffer.put(audioInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-释放编码器"><a href="#7-释放编码器" class="headerlink" title="7. 释放编码器"></a>7. 释放编码器</h4><p>在使用完 MediaCodec 编码器之后，就需要停止运行并释放编码器，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMediaCodec.stop();</span><br><span class="line">        mMediaCodec.release();</span><br><span class="line">        mMediaCodec = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h2><p>Camera 采集完之后需要对 YUV 数据进行实时的编码 (软编利用 <a href="https://www.videolan.org/developers/x264.html">x264</a> 通过 NDK 交叉编译静态库、硬编使用 Android SDK MediaCodec 进行编码)。</p>
<h3 id="软编-1"><a href="#软编-1" class="headerlink" title="软编"></a>软编</h3><p>视频软编这里们用主流的编码库 x264 进行编码 H264 视频格式数据。 </p>
<h4 id="1-交叉编译-x264"><a href="#1-交叉编译-x264" class="headerlink" title="1. 交叉编译 x264"></a>1. 交叉编译 x264</h4><h5 id="1-1-下载-x264"><a href="#1-1-下载-x264" class="headerlink" title="1.1 下载 x264"></a>1.1 下载 x264</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式 一</span><br><span class="line">git clone https://code.videolan.org/videolan/x264.git</span><br><span class="line">//方式 二</span><br><span class="line">wget ftp://ftp.videolan.org/pub/x264/snapshots/last_x264.tar.bz2</span><br></pre></td></tr></table></figure>

<h5 id="1-2-编写编译脚本"><a href="#1-2-编写编译脚本" class="headerlink" title="1.2 编写编译脚本"></a>1.2 编写编译脚本</h5><p>在编写脚本之前需要在 configure 中添加一处代码 <code>-Werror=implicit-function-declaration</code>,如下所示:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302192219.png" alt=""></p>
<p>交叉编译脚本如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#打包地址</span><br><span class="line">PREFIX=./android/armeabi-v7a</span><br><span class="line"></span><br><span class="line">#配置NDK 环境变量</span><br><span class="line">NDK_ROOT=$NDK_HOME</span><br><span class="line"></span><br><span class="line">#指定 CPU</span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">#指定 Android API</span><br><span class="line">ANDROID_API=<span class="number">17</span></span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-<span class="number">4.9</span>/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">FLAGS=<span class="string">"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS  -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC"</span></span><br><span class="line"></span><br><span class="line">#--disable-cli 不需要命令行工具</span><br><span class="line">#--enable-static 静态库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--disable-cli \</span><br><span class="line">--enable-<span class="keyword">static</span> \</span><br><span class="line">--enable-pic \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-<span class="number">17</span>/arch-arm \</span><br><span class="line">--extra-cflags=<span class="string">"$FLAGS"</span></span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="2-CMakeList-txt-配置"><a href="#2-CMakeList-txt-配置" class="headerlink" title="2. CMakeList.txt 配置"></a>2. CMakeList.txt 配置</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#视频编码器</span></span><br><span class="line"><span class="keyword">set</span>(x264 <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/x264)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载 x264 头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;x264&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定 x264 静态库文件目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;x264&#125;/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了</span></span><br><span class="line"><span class="keyword">file</span>(GLOB Player_CPP <span class="variable">$&#123;ykplayer&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB Push_CPP <span class="variable">$&#123;ykpusher&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment">#添加自己编写 cpp 源文件生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(ykpusher SHARED <span class="variable">$&#123;Push_CPP&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#找系统中 NDK log库</span></span><br><span class="line"><span class="keyword">find_library</span>(log_lib</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment">#推流 so</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        <span class="comment">#播放 so</span></span><br><span class="line">        ykpusher</span><br><span class="line"><span class="comment">#        # 写了此命令不用在乎添加 ffmpeg lib 顺序问题导致应用崩溃</span></span><br><span class="line"><span class="comment">#        -Wl,--start-group</span></span><br><span class="line"><span class="comment">#        avcodec avfilter avformat avutil swresample swscale</span></span><br><span class="line"><span class="comment">#        -Wl,--end-group</span></span><br><span class="line"><span class="comment">#        z</span></span><br><span class="line">        <span class="comment">#推流库</span></span><br><span class="line">        rtmp</span><br><span class="line">        <span class="comment">#视频编码</span></span><br><span class="line">        x264</span><br><span class="line">        <span class="comment">#语音编码</span></span><br><span class="line">        faac</span><br><span class="line">        <span class="comment">#本地库</span></span><br><span class="line">        android</span><br><span class="line">        <span class="variable">$&#123;log_lib&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h4 id="3-配置并打开-x264-编码器"><a href="#3-配置并打开-x264-编码器" class="headerlink" title="3. 配置并打开 x264 编码器"></a>3. 配置并打开 x264 编码器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::setVideoEncoderInfo</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> fps, <span class="keyword">int</span> <span class="built_in">bit</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mMutex);</span><br><span class="line">    <span class="keyword">this</span>-&gt;mWidth = <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mHeight = <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mFps = fps;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mBit = <span class="built_in">bit</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mY_Size = <span class="built_in">width</span> * <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mUV_Size = mY_Size / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果编码器已经存在，需要释放</span></span><br><span class="line">    <span class="keyword">if</span> (mVideoCodec || pic_in) &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开x264编码器</span></span><br><span class="line">    <span class="comment">//x264编码器的属性</span></span><br><span class="line">    <span class="keyword">x264_param_t</span> param;</span><br><span class="line">    <span class="comment">//2： 最快</span></span><br><span class="line">    <span class="comment">//3:  无延迟编码</span></span><br><span class="line">    x264_param_default_preset(&amp;param, x264_preset_names[<span class="number">0</span>], x264_tune_names[<span class="number">7</span>]);</span><br><span class="line">    <span class="comment">//base_line 3.2 编码规格</span></span><br><span class="line">    param.i_level_idc = <span class="number">32</span>;</span><br><span class="line">    <span class="comment">//输入数据格式</span></span><br><span class="line">    param.i_csp = X264_CSP_I420;</span><br><span class="line">    param.i_width = <span class="built_in">width</span>;</span><br><span class="line">    param.i_height = <span class="built_in">height</span>;</span><br><span class="line">    <span class="comment">//无b帧</span></span><br><span class="line">    param.i_bframe = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//参数i_rc_method表示码率控制，CQP(恒定质量)，CRF(恒定码率)，ABR(平均码率)</span></span><br><span class="line">    param.rc.i_rc_method = X264_RC_ABR;</span><br><span class="line">    <span class="comment">//码率(比特率,单位Kbps)</span></span><br><span class="line">    param.rc.i_bitrate = mBit;</span><br><span class="line">    <span class="comment">//瞬时最大码率</span></span><br><span class="line">    param.rc.i_vbv_max_bitrate = mBit * <span class="number">1.2</span>;</span><br><span class="line">    <span class="comment">//设置了i_vbv_max_bitrate必须设置此参数，码率控制区大小,单位kbps</span></span><br><span class="line">    param.rc.i_vbv_buffer_size = mBit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//帧率</span></span><br><span class="line">    param.i_fps_num = fps;</span><br><span class="line">    param.i_fps_den = <span class="number">1</span>;</span><br><span class="line">    param.i_timebase_den = param.i_fps_num;</span><br><span class="line">    param.i_timebase_num = param.i_fps_den;</span><br><span class="line"><span class="comment">//    param.pf_log = x264_log_default2;</span></span><br><span class="line">    <span class="comment">//用fps而不是时间戳来计算帧间距离</span></span><br><span class="line">    param.b_vfr_input = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//帧距离(关键帧)  2s一个关键帧</span></span><br><span class="line">    param.i_keyint_max = fps * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 是否复制sps和pps放在每个关键帧的前面 该参数设置是让每个关键帧(I帧)都附带sps/pps。</span></span><br><span class="line">    param.b_repeat_headers = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//多线程</span></span><br><span class="line">    param.i_threads = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    x264_param_apply_profile(&amp;param, <span class="string">"baseline"</span>);</span><br><span class="line">    <span class="comment">//打开编码器</span></span><br><span class="line">    mVideoCodec = x264_encoder_open(&amp;param);</span><br><span class="line">    pic_in = <span class="keyword">new</span> <span class="keyword">x264_picture_t</span>;</span><br><span class="line">    x264_picture_alloc(pic_in, X264_CSP_I420, <span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">    <span class="comment">//相当于重启编码器</span></span><br><span class="line">    isStart = <span class="literal">true</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-开始编码"><a href="#4-开始编码" class="headerlink" title="4. 开始编码"></a>4. 开始编码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::onEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isStart) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mVideoCodec) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int8_t</span> *data = <span class="number">0</span>;</span><br><span class="line">        mVideoPackets.pop(data);</span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            LOGE(<span class="string">"获取 YUV 数据错误"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//copy Y 数据</span></span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;pic_in-&gt;img.plane[<span class="number">0</span>], data, mY_Size);</span><br><span class="line">        <span class="comment">//拿到 UV 数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mUV_Size; ++i) &#123;</span><br><span class="line">            <span class="comment">//拿到 u 数据</span></span><br><span class="line">            *(pic_in-&gt;img.plane[<span class="number">1</span>] + i) = *(data + mY_Size + i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//拿到 v 数据</span></span><br><span class="line">            *(pic_in-&gt;img.plane[<span class="number">2</span>] + i) = *(data + mY_Size + i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编码出来的数据</span></span><br><span class="line">        <span class="keyword">x264_nal_t</span> *pp_nal;</span><br><span class="line">        <span class="comment">//编码出来的帧数量</span></span><br><span class="line">        <span class="keyword">int</span> pi_nal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">x264_picture_t</span> pic_out;</span><br><span class="line">        <span class="comment">//开始编码</span></span><br><span class="line">        <span class="keyword">int</span> ret = x264_encoder_encode(mVideoCodec, &amp;pp_nal, &amp;pi_nal, pic_in, &amp;pic_out);</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            LOGE(<span class="string">"编码失败"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是关键帧</span></span><br><span class="line">        <span class="keyword">int</span> sps_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pps_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span> sps[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">uint8_t</span> pps[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pi_nal; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pp_nal[i].i_type == NAL_SPS) &#123;</span><br><span class="line">                <span class="comment">//排除掉 h264的间隔 00 00 00 01</span></span><br><span class="line">                sps_len = pp_nal[i].i_payload - <span class="number">4</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(sps, pp_nal[i].p_payload + <span class="number">4</span>, sps_len);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp_nal[i].i_type == NAL_PPS) &#123;</span><br><span class="line">                pps_len = pp_nal[i].i_payload - <span class="number">4</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(pps, pp_nal[i].p_payload + <span class="number">4</span>, pps_len);</span><br><span class="line">                <span class="comment">//pps肯定是跟着sps的</span></span><br><span class="line">                sendSpsPps(sps, pps, sps_len, pps_len);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//编码之后的 H264 数据</span></span><br><span class="line">                sendFrame(pp_nal[i].i_type, pp_nal[i].p_payload, pp_nal[i].i_payload, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送 sps pps</span></span><br><span class="line"><span class="comment"> * @param sps  编码第一帧数据</span></span><br><span class="line"><span class="comment"> * @param pps  编码第二帧数据</span></span><br><span class="line"><span class="comment"> * @param sps_len  编码第一帧数据的长度</span></span><br><span class="line"><span class="comment"> * @param pps_len  编码第二帧数据的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::sendSpsPps</span><span class="params">(<span class="keyword">uint8_t</span> *sps, <span class="keyword">uint8_t</span> *pps, <span class="keyword">int</span> sps_len, <span class="keyword">int</span> pps_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bodySize = <span class="number">13</span> + sps_len + <span class="number">3</span> + pps_len;</span><br><span class="line">    RTMPPacket *packet = <span class="keyword">new</span> RTMPPacket;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    RTMPPacket_Alloc(packet, bodySize);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//固定头</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x17</span>;</span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//composition time 0x000000</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x00</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x00</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//版本</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">//编码规格</span></span><br><span class="line">    packet-&gt;m_body[i++] = sps[<span class="number">1</span>];</span><br><span class="line">    packet-&gt;m_body[i++] = sps[<span class="number">2</span>];</span><br><span class="line">    packet-&gt;m_body[i++] = sps[<span class="number">3</span>];</span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个sps</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0xE1</span>;</span><br><span class="line">    <span class="comment">//sps长度</span></span><br><span class="line">    packet-&gt;m_body[i++] = (sps_len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = sps_len &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[i], sps, sps_len);</span><br><span class="line">    i += sps_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pps</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x01</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = (pps_len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = (pps_len) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[i], pps, pps_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视频</span></span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    packet-&gt;m_nBodySize = bodySize;</span><br><span class="line">    <span class="comment">//随意分配一个管道（尽量避开rtmp.c中使用的）</span></span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x10</span>;</span><br><span class="line">    <span class="comment">//sps pps没有时间戳</span></span><br><span class="line">    packet-&gt;m_nTimeStamp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//不使用绝对时间</span></span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = <span class="number">0</span>;</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_MEDIUM;</span><br><span class="line">    <span class="keyword">if</span> (mVideoCallback &amp;&amp; isStart)</span><br><span class="line">        mVideoCallback(packet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送视频帧 -- 关键帧</span></span><br><span class="line"><span class="comment"> * @param type</span></span><br><span class="line"><span class="comment"> * @param payload</span></span><br><span class="line"><span class="comment"> * @param i_playload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::sendFrame</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">uint8_t</span> *payload, <span class="keyword">int</span> i_payload, <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (payload[<span class="number">2</span>] == <span class="number">0x00</span>) &#123;</span><br><span class="line">        i_payload -= <span class="number">4</span>;</span><br><span class="line">        payload += <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i_payload -= <span class="number">3</span>;</span><br><span class="line">        payload += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看表</span></span><br><span class="line">    <span class="keyword">int</span> bodySize = <span class="number">9</span> + i_payload;</span><br><span class="line">    RTMPPacket *packet = <span class="keyword">new</span> RTMPPacket;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    RTMPPacket_Alloc(packet, bodySize);</span><br><span class="line"></span><br><span class="line">    packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0x27</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == NAL_SLICE_IDR) &#123;</span><br><span class="line">        packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0x17</span>;</span><br><span class="line">        LOGE(<span class="string">"关键帧"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    packet-&gt;m_body[<span class="number">1</span>] = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">//时间戳</span></span><br><span class="line">    packet-&gt;m_body[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//数据长度 int 4个字节</span></span><br><span class="line">    packet-&gt;m_body[<span class="number">5</span>] = (i_payload &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">6</span>] = (i_payload &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">7</span>] = (i_payload &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">8</span>] = (i_payload) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[<span class="number">9</span>], payload, i_payload);</span><br><span class="line"></span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = <span class="number">0</span>;</span><br><span class="line">    packet-&gt;m_nBodySize = bodySize;</span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x10</span>;</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    <span class="keyword">if</span> (mVideoCallback &amp;&amp; isStart)</span><br><span class="line">        mVideoCallback(packet);<span class="comment">//回调给 RTMP 模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-释放编码器"><a href="#5-释放编码器" class="headerlink" title="5. 释放编码器"></a>5. 释放编码器</h4><p>当我们不需要编码的时候需要释放编码器，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x264_encoder_close(mVideoCodec);</span><br></pre></td></tr></table></figure>

<h3 id="硬编-1"><a href="#硬编-1" class="headerlink" title="硬编"></a>硬编</h3><p>在 Android 4.3 系统以后，用 MediaCodec 编码视频成为了主流的使用场景，尽管 Android 的碎片化很严重，会导致一些兼容性问题，但是硬件编码器的性能以及速度是非常可观的，并且在 4.3 系统之后可以通过 Surface 来配置编码器的输入，大大降低了显存到内存的交换过程所使用的时间，从而使得整个应用的体验得到大大提升。由于输入和输出已经确定，因此接下来将直接编写 MediaCodec 编码视频帧的过程。</p>
<h4 id="1-创建-“video-avc”-类型的硬编码器"><a href="#1-创建-“video-avc”-类型的硬编码器" class="headerlink" title="1. 创建 “video/avc” 类型的硬编码器"></a>1. 创建 “video/avc” 类型的硬编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaCodec = MediaCodec.createEncoderByType(videoConfiguration.mime);</span><br></pre></td></tr></table></figure>

<h4 id="2-配置视频编码器"><a href="#2-配置视频编码器" class="headerlink" title="2. 配置视频编码器"></a>2. 配置视频编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MediaCodec <span class="title">getVideoMediaCodec</span><span class="params">(VideoConfiguration videoConfiguration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> videoWidth = getVideoSize(videoConfiguration.width);</span><br><span class="line">    <span class="keyword">int</span> videoHeight = getVideoSize(videoConfiguration.height);</span><br><span class="line">    MediaFormat format = MediaFormat.createVideoFormat(videoConfiguration.mime, videoWidth, videoHeight);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_COLOR_FORMAT,</span><br><span class="line">            MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_BIT_RATE, videoConfiguration.maxBps* <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">int</span> fps = videoConfiguration.fps;</span><br><span class="line">    <span class="comment">//设置摄像头预览帧率</span></span><br><span class="line">    <span class="keyword">if</span>(BlackListHelper.deviceInFpsBlacklisted()) &#123;</span><br><span class="line">        SopCastLog.d(SopCastConstant.TAG, <span class="string">"Device in fps setting black list, so set mediacodec fps 15"</span>);</span><br><span class="line">        fps = <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    format.setInteger(MediaFormat.KEY_FRAME_RATE, fps);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, videoConfiguration.ifi);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_BITRATE_MODE, MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_VBR);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_COMPLEXITY, MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_CBR);</span><br><span class="line">    MediaCodec mediaCodec = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mediaCodec = MediaCodec.createEncoderByType(videoConfiguration.mime);</span><br><span class="line">        mediaCodec.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (mediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mediaCodec.stop();</span><br><span class="line">            mediaCodec.release();</span><br><span class="line">            mediaCodec = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mediaCodec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-开启视频编码器"><a href="#3-开启视频编码器" class="headerlink" title="3. 开启视频编码器"></a>3. 开启视频编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mMediaCodec.start();</span><br></pre></td></tr></table></figure>

<h4 id="4-拿到编码之后的数据"><a href="#4-拿到编码之后的数据" class="headerlink" title="4. 拿到编码之后的数据"></a>4. 拿到编码之后的数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuffer[] outBuffers = mMediaCodec.getOutputBuffers();</span><br><span class="line">	<span class="keyword">while</span> (isStarted) &#123;</span><br><span class="line">		encodeLock.lock();</span><br><span class="line">		<span class="keyword">if</span>(mMediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> outBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">12000</span>);</span><br><span class="line">			<span class="keyword">if</span> (outBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				ByteBuffer bb = outBuffers[outBufferIndex];</span><br><span class="line">				<span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123; <span class="comment">//将编码好的 H264 数据回调出去</span></span><br><span class="line">					mListener.onVideoEncode(bb, mBufferInfo);</span><br><span class="line">				&#125;</span><br><span class="line">				mMediaCodec.releaseOutputBuffer(outBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// wait 10ms</span></span><br><span class="line">					Thread.sleep(<span class="number">10</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			encodeLock.unlock();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			encodeLock.unlock();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-H264-打包为-flv"><a href="#5-H264-打包为-flv" class="headerlink" title="5. H264 打包为 flv"></a>5. H264 打包为 flv</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//接收 H264 数据 </span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVideoData</span><span class="params">(ByteBuffer bb, MediaCodec.BufferInfo bi)</span> </span>&#123;</span><br><span class="line">       mAnnexbHelper.analyseVideoData(bb, bi);</span><br><span class="line">   &#125;   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将硬编得到的视频数据进行处理生成每一帧视频数据，然后传给flv打包器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bb 硬编后的数据buffer</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bi 硬编的BufferInfo</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyseVideoData</span><span class="params">(ByteBuffer bb, MediaCodec.BufferInfo bi)</span> </span>&#123;</span><br><span class="line">       bb.position(bi.offset);</span><br><span class="line">       bb.limit(bi.offset + bi.size);</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;<span class="keyword">byte</span>[]&gt; frames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">boolean</span> isKeyFrame = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(bb.position() &lt; bi.offset + bi.size) &#123;</span><br><span class="line">           <span class="keyword">byte</span>[] frame = annexbDemux(bb, bi);</span><br><span class="line">           <span class="keyword">if</span>(frame == <span class="keyword">null</span>) &#123;</span><br><span class="line">               LogUtils.e(<span class="string">"annexb not match."</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// ignore the nalu type aud(9)</span></span><br><span class="line">           <span class="keyword">if</span> (isAccessUnitDelimiter(frame)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// for pps</span></span><br><span class="line">           <span class="keyword">if</span>(isPps(frame)) &#123;</span><br><span class="line">               mPps = frame;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// for sps</span></span><br><span class="line">           <span class="keyword">if</span>(isSps(frame)) &#123;</span><br><span class="line">               mSps = frame;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// for IDR frame</span></span><br><span class="line">           <span class="keyword">if</span>(isKeyFrame(frame)) &#123;</span><br><span class="line">               isKeyFrame = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               isKeyFrame = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">byte</span>[] naluHeader = buildNaluHeader(frame.length);</span><br><span class="line">           frames.add(naluHeader);</span><br><span class="line">           frames.add(frame);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (mPps != <span class="keyword">null</span> &amp;&amp; mSps != <span class="keyword">null</span> &amp;&amp; mListener != <span class="keyword">null</span> &amp;&amp; mUploadPpsSps) &#123;</span><br><span class="line">           <span class="keyword">if</span>(mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mListener.onSpsPps(mSps, mPps);</span><br><span class="line">           &#125;</span><br><span class="line">           mUploadPpsSps = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(frames.size() == <span class="number">0</span> || mListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">byte</span>[] frame = frames.get(i);</span><br><span class="line">           size += frame.length;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">       <span class="keyword">int</span> currentSize = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">byte</span>[] frame = frames.get(i);</span><br><span class="line">           System.arraycopy(frame, <span class="number">0</span>, data, currentSize, frame.length);</span><br><span class="line">           currentSize += frame.length;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mListener.onVideo(data, isKeyFrame);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是从编码后的数据中解析得到NALU，然后判断NALU的类型，最后再把数据回调给 FlvPacker 去处理。</p>
<p>处理 spsPps:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpsPps</span><span class="params">(<span class="keyword">byte</span>[] sps, <span class="keyword">byte</span>[] pps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packetListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入第一个视频信息</span></span><br><span class="line">    writeFirstVideoTag(sps, pps);</span><br><span class="line">    <span class="comment">//写入第一个音频信息</span></span><br><span class="line">    writeFirstAudioTag();</span><br><span class="line">    isHeaderWrite = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理视频帧:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVideo</span><span class="params">(<span class="keyword">byte</span>[] video, <span class="keyword">boolean</span> isKeyFrame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packetListener == <span class="keyword">null</span> || !isHeaderWrite) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> packetType = INTER_FRAME;</span><br><span class="line">    <span class="keyword">if</span> (isKeyFrame) &#123;</span><br><span class="line">        isKeyFrameWrite = <span class="keyword">true</span>;</span><br><span class="line">        packetType = KEY_FRAME;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保第一帧是关键帧，避免一开始出现灰色模糊界面</span></span><br><span class="line">    <span class="keyword">if</span> (!isKeyFrameWrite) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = VIDEO_HEADER_SIZE + video.length;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(size);</span><br><span class="line">    FlvPackerHelper.writeH264Packet(buffer, video, isKeyFrame);</span><br><span class="line">    packetListener.onPacket(buffer.array(), packetType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-释放编码器-并释放-Surface"><a href="#6-释放编码器-并释放-Surface" class="headerlink" title="6. 释放编码器,并释放 Surface"></a>6. 释放编码器,并释放 Surface</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放编码器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mMediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mMediaCodec.signalEndOfInputStream();</span><br><span class="line">		mMediaCodec.stop();</span><br><span class="line">		mMediaCodec.release();</span><br><span class="line">		mMediaCodec = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mInputSurface != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mInputSurface.release();</span><br><span class="line">		mInputSurface = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放 OpenGL ES 渲染，Surface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface);</span><br><span class="line">	EGL14.eglDestroyContext(mEGLDisplay, mEGLContext);</span><br><span class="line">	EGL14.eglReleaseThread();</span><br><span class="line">	EGL14.eglTerminate(mEGLDisplay);</span><br><span class="line"></span><br><span class="line">	mSurface.release();</span><br><span class="line"></span><br><span class="line">	mSurface    = <span class="keyword">null</span>;</span><br><span class="line">	mEGLDisplay = <span class="keyword">null</span>;</span><br><span class="line">	mEGLContext = <span class="keyword">null</span>;</span><br><span class="line">	mEGLSurface = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rtmp-推流"><a href="#rtmp-推流" class="headerlink" title="rtmp 推流"></a>rtmp 推流</h2><p>注: 实际项目 rtmp 需要先连接上才有后续操作。</p>
<p>rtmp 模块我们已在开发 <a href="https://juejin.im/post/5e495ec1e51d452713551017">播放器</a> 的时候，将它和 ffmpeg 一并编译了。所以我们直接使用上次的静态库和头文件就可以了，如果对 rtmp 协议不了解的可以参考上一篇文章，里面也有介绍 <a href="https://juejin.im/post/5e4ec66c5188254967067502">搭建 RTMP 直播服务器</a>。</p>
<p>到这里软编码和硬编码数据都已准备好了现在，需要发送给 rtmp 模块，也就是在 native 中，先看 java 发送出口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打包之后的数据，和裸流数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == RtmpPacker.FIRST_AUDIO || type == RtmpPacker.AUDIO) &#123;<span class="comment">//音频 AAC 数据,已打包 </span></span><br><span class="line">        mPusherManager.pushAACData(data, data.length, type);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RtmpPacker.FIRST_VIDEO ||</span><br><span class="line">            type == RtmpPacker.INTER_FRAME || type == RtmpPacker.KEY_FRAME) &#123;<span class="comment">//H264 视频数据,已打包</span></span><br><span class="line">        mPusherManager.pushH264(data, type, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RtmpPacker.PCM) &#123; <span class="comment">//PCM 裸流数据</span></span><br><span class="line">        mPusherManager.pushPCM(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RtmpPacker.YUV) &#123; <span class="comment">//YUV 裸流数据</span></span><br><span class="line">        mPusherManager.pushYUV(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送 H264 数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h264</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">pushH264</span><span class="params">(<span class="keyword">byte</span>[] h264, <span class="keyword">int</span> type, <span class="keyword">long</span> timeStamp)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> audio     直接推编码完成之后的音频流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">pushAACData</span><span class="params">(<span class="keyword">byte</span>[] audio, <span class="keyword">int</span> length, <span class="keyword">int</span> timestamp)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送 PCM 原始数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> audioData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">native_pushAudio</span><span class="params">(<span class="keyword">byte</span>[] audioData)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * push 视频原始 nv21</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">native_push_video</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-Rtmp-链接"><a href="#1-Rtmp-链接" class="headerlink" title="1. Rtmp 链接"></a>1. Rtmp 链接</h3><p>Rtmp 底层是 TCP 协议，所以你可以使用 Java Socket 进行连接，也可以使用 c++ librtmp 库来进行连接，咱么这里就使用 librtmp 来进行连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正 rtmp 连接的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTMPModel::onConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 初始化</span></span><br><span class="line">    RTMP_Init(rtmp);</span><br><span class="line">    <span class="comment">//2. 设置rtmp地址</span></span><br><span class="line">    <span class="keyword">int</span> ret = RTMP_SetupURL(rtmp, <span class="keyword">this</span>-&gt;url)</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//3. 确认写入 rtmp</span></span><br><span class="line">    RTMP_EnableWrite(rtmp);</span><br><span class="line">		<span class="comment">//4. 开始链接</span></span><br><span class="line">    ret = RTMP_Connect(rtmp, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//5. 连接成功之后需要连接一个流</span></span><br><span class="line">    ret = RTMP_ConnectStream(rtmp, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Native-音频模块接收-AAC-Flv-打包数据"><a href="#2-Native-音频模块接收-AAC-Flv-打包数据" class="headerlink" title="2. Native 音频模块接收 AAC Flv 打包数据"></a>2. Native 音频模块接收 AAC Flv 打包数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接推送 AAC 硬编码</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioEncoderChannel::pushAAC</span><span class="params">(u_char *data, <span class="keyword">int</span> dataLen, <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    RTMPPacket *packet = (RTMPPacket *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(packet, dataLen);</span><br><span class="line">    RTMPPacket_Reset(packet);</span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x05</span>; <span class="comment">//音频</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet-&gt;m_body, data, dataLen);</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = FALSE;</span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO;</span><br><span class="line">    packet-&gt;m_nBodySize = dataLen;</span><br><span class="line">    <span class="keyword">if</span> (mAudioCallback)</span><br><span class="line">        mAudioCallback(packet); <span class="comment">//发送给 rtmp 模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Native-视频模块接收-H264-Flv-打包数据"><a href="#3-Native-视频模块接收-H264-Flv-打包数据" class="headerlink" title="3. Native 视频模块接收 H264 Flv 打包数据"></a>3. Native 视频模块接收 H264 Flv 打包数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param type  视频帧类型</span></span><br><span class="line"><span class="comment"> * @param buf  H264</span></span><br><span class="line"><span class="comment"> * @param len H264 长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::sendH264</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> dataLen, <span class="keyword">int</span> timeStamp)</span> </span>&#123;</span><br><span class="line">    RTMPPacket *packet = (RTMPPacket *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(packet, dataLen);</span><br><span class="line">    RTMPPacket_Reset(packet);</span><br><span class="line"></span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x04</span>; <span class="comment">//视频</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == RTMP_PACKET_KEY_FRAME) &#123;</span><br><span class="line">        LOGE(<span class="string">"视频关键帧"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(packet-&gt;m_body, data, dataLen);</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = FALSE;</span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    packet-&gt;m_nBodySize = dataLen;</span><br><span class="line">    mVideoCallback(packet);<span class="comment">//发送给 rtmp 模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-RTMP-发送数据"><a href="#4-RTMP-发送数据" class="headerlink" title="4. RTMP 发送数据"></a>4. RTMP 发送数据</h3><h4 id="4-1-将接收到的数据入发送队列"><a href="#4-1-将接收到的数据入发送队列" class="headerlink" title="4.1 将接收到的数据入发送队列"></a>4.1 将接收到的数据入发送队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不管是软编码还是硬编码所有发送数据都需要入队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(RTMPPacket *packet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rtmpModel) &#123;</span><br><span class="line">            <span class="comment">//设置时间戳</span></span><br><span class="line">            packet-&gt;m_nTimeStamp = RTMP_GetTime() - rtmpModel-&gt;mStartTime;</span><br><span class="line">            rtmpModel-&gt;mPackets.push(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-发送"><a href="#4-2-发送" class="headerlink" title="4.2 发送"></a>4.2 发送</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正推流的地方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTMPModel::onPush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RTMPPacket *packet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (isStart) &#123;</span><br><span class="line">      	<span class="comment">//从队列中获取发送的音视频数据</span></span><br><span class="line">        mPackets.pop(packet);</span><br><span class="line">        <span class="keyword">if</span> (!readyPushing) &#123;</span><br><span class="line">            releasePackets(packet);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!packet) &#123;</span><br><span class="line">            LOGE(<span class="string">"获取失败"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        packet-&gt;m_nInfoField2 = rtmp-&gt;m_stream_id;</span><br><span class="line">        <span class="keyword">int</span> ret = RTMP_SendPacket(rtmp, packet, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            LOGE(<span class="string">"发送失败"</span>)</span><br><span class="line">            <span class="keyword">if</span> (pushCallback) &#123;</span><br><span class="line">                pushCallback-&gt;onError(THREAD_CHILD, RTMP_PUSHER_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    releasePackets(packet);</span><br><span class="line">    <span class="built_in">release</span>();<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-关闭-RTMP"><a href="#5-关闭-RTMP" class="headerlink" title="5. 关闭 RTMP"></a>5. 关闭 RTMP</h3><p>当不需要发送音视频数据的时候需要关闭 rtmp 连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTMPModel::release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isStart = <span class="literal">false</span>;</span><br><span class="line">    readyPushing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (rtmp) &#123;</span><br><span class="line">        RTMP_DeleteStream(rtmp);</span><br><span class="line">        RTMP_Close(rtmp);</span><br><span class="line">        RTMP_Free(rtmp);</span><br><span class="line">        rtmp = <span class="number">0</span>;</span><br><span class="line">        LOGE(<span class="string">"释放 native 资源"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPackets.clearQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单谈谈软硬编解码"><a href="#简单谈谈软硬编解码" class="headerlink" title="简单谈谈软硬编解码"></a>简单谈谈软硬编解码</h2><h3 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h3><p><strong>软编码:</strong>  使用 CPU 进行编码。<br><strong>硬编码:</strong>  使用 GPU 进行编码。</p>
<h3 id="2-比较"><a href="#2-比较" class="headerlink" title="2. 比较"></a>2. 比较</h3><p><strong>软编码:</strong>  实现直接、简单，参数调整方便，升级容易，但 CPU 负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。<br><strong>硬编码:</strong>  性能高，低码率下通常质量低于软编码器，但部分产品在 GPU 硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><p><strong>软编码:</strong> 适用短时间操作，如录制短视频等。</p>
<p><strong>硬编码:</strong> 长时间编码或者对视频质量要求高(VOIP 实时通话)，可以推荐硬件编码 (前提是手机性能好)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里 Android 端软编推流，硬编推流都分别实现了。在项目上可以根据实际情况来选择到底是硬编还是软编。</p>
<p>硬编我是基于来疯开源项目进行二次开发:</p>
<p> <a href="https://github.com/yangkun19921001/NDK_AV_SAMPLE/tree/master/ykav_common">Android 推流项目地址</a></p>
<p> <a href="https://github.com/yangkun19921001/NDK_AV_SAMPLE/blob/master/ykav_sample/src/main/java/com/devyk/ykav_sample/PlayerActivity.java">Android 拉流项目地址</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/LaiFeng-Android/SopCastComponent">来疯直播项目</a></li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">音视频学习路线</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200604150710.jpeg" alt="支付宝"></span></a><a class="button donate" href="/" style="background-color:rgba(255,128,62,.87);border-color:transparent;color:white;" target="_blank" rel="noopener"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button is-danger donate" href="/" target="_blank" rel="noopener"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200604150835.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%BA%8C-FFmpeg-OpenSL-ES-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">音视频学习 (十二) FFmpeg + OpenSL ES 实现音频播放器</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81-%E5%9F%BA%E4%BA%8E-Nginx-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="level-item">音视频学习 (十) 基于 Nginx 搭建直播服务器</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "j16d0HiTJvVWRQzjQN625f4W-gzGzoHsz",
            appKey: "7cgla0UfvddS9PjRz7Lcvqn7",
            placeholder: "请遵守中华人民共和国法律法规。填写邮箱信息以接收回复。",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200427113132.jpeg" alt="DevYK"></figure><p class="title is-size-4 is-block line-height-inherit">DevYK</p><p class="is-size-6 is-block">Android/NDK/音视频/跨平台</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>BeiJing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yangkun19921001" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yangkun19921001"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="http://wpa.qq.com/msgrd?v=1&amp;uin=919079498&amp;site=ioshenmue&amp;menu=yes"><i class="fab fa-qq"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://github.com/yangkun19921001/Blog/blob/master/about.md" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">联系我</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://juejin.im/user/578259398ac2470061f3a3fb/posts" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.im</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/"><span class="level-start"><span class="level-item">专题</span></span><span class="level-end"><span class="level-item tag">25</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="level-start"><span class="level-item">性能优化</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/"><span class="level-start"><span class="level-item">音视频</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">服务</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1/apprtc/"><span class="level-start"><span class="level-item">apprtc</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/webrtc/"><span class="tag">webrtc</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"><span class="tag">音视频学习路线</span><span class="tag is-grey-lightest">12</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:33:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E5%BF%85%E7%9C%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/">必看的性能优化总结</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:31:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%B8%89-%E7%A8%B3%E5%AE%9A%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96%E4%B9%8B%E6%8D%95%E8%8E%B7-Native-Crash/">性能优化 (十三) 稳定运行优化之捕获 Native Crash </a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:30:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%BA%8C-%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96%E4%B9%8B%E6%9E%81%E9%99%90%E7%98%A6%E8%BA%AB/">性能优化 (十二) 体积优化之极限瘦身</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:29:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%B8%80-%E7%A8%B3%E5%AE%9A%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96%E4%B9%8B%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/">性能优化 (十一) 稳定运行优化之热修复原理探索</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:27:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81-%E6%8C%81%E7%BB%AD%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%AE%9E%E7%8E%B0/">性能优化 (十) 稳定运行优化之进程保活实现 </a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="DevYK 个人博客" height="28"></a><p class="size-small"><span>&copy; 2020 DevYK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><a href="http://www.beian.miit.gov.cn">京ICP备19052442号-1</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>