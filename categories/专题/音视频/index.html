<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: 音视频 - DevYK 个人博客</title><meta property="og:type" content="blog"><meta property="og:title" content="DevYK 个人博客"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="DevYK 个人博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:author" content="DevYK"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"DevYK 个人博客","image":["http://yoursite.com/img/og_image.png"],"author":{"@type":"Person","name":"DevYK"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="DevYK 个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">about</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li><a href="/categories/%E4%B8%93%E9%A2%98/">专题</a></li><li class="is-active"><a href="#" aria-current="page">音视频</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:26:00.000Z" title="2020-06-04T10:26:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">19 分钟 读完 (大约 2902 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%BA%8C-FFmpeg-OpenSL-ES-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/">音视频学习 (十二) FFmpeg + OpenSL ES 实现音频播放器</a></h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>唠叨一句:</p>
<p>说实话现在搞 Android 开发的要求是越来越高，初级都要被淘汰的感觉。所以想要一直往 Android 的道路上走，深入 <strong>音视频领域</strong> 是一个不错的选择。虽然现在跨平台 <strong>Flutter</strong> 很火，但终究它还是一个写 UI 的(个人看法)。程序员随着年龄的增长不可能一直写 UI 。但是深入 <strong>C/C++</strong> 就不一样了。它可以给移动端甚至 <strong>Flutter</strong> 提供底层 SDK 和技术支持这难道不香吗？所以想要或者准备学习音视频知识的，那么该篇文章可以助你快速入门。</p>
</blockquote>
<p>五一假期即将结束，不知道大家玩的怎么样，我了也趁着这个假期抽出了一天时间去爬了长城，有句话不是说，不到长城非好汉嘛。何况来北京好些年了一直没机会去。之后利用剩下的这 4 天写了一个音频处理库，目前包含如下功能:</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>是否完成</th>
</tr>
</thead>
<tbody><tr>
<td>读取任意格式音频流</td>
<td>Yes</td>
</tr>
<tr>
<td>FFmpeg 音频解码为 PCM</td>
<td>Yes</td>
</tr>
<tr>
<td>音频 Native OpenSL ES 渲染</td>
<td>Yes</td>
</tr>
<tr>
<td>音量控制</td>
<td>Yes</td>
</tr>
<tr>
<td>seek 控制</td>
<td>Yes</td>
</tr>
<tr>
<td>声道切换</td>
<td>Yes</td>
</tr>
<tr>
<td><a href="[SoundTouch](https://gitlab.com/soundtouch/soundtouch)">变调变速</a></td>
<td>Yes</td>
</tr>
<tr>
<td>变声</td>
<td>No</td>
</tr>
<tr>
<td>裁剪音频输出 MP3/PCM 等格式</td>
<td>pcm-ok</td>
</tr>
<tr>
<td>边播边录制</td>
<td>No</td>
</tr>
<tr>
<td>音频编码为 AAC、MP3、WAV</td>
<td>No</td>
</tr>
</tbody></table>
<p>其实音频处理的库在 GitHub 搜都是一大堆，那为什么我自己还要写一个呢？原因是我不想当伸手党，如果每次都这样，那自己的技术何来进步，是吧？而且自己写的库也便于自己修改和增加一些特殊的功能。下面我就大概来说一下具体每个功能是如何实现及做一个音频处理的库需要搭建怎样的一个架构。当然我也不是一时兴起就来写一个音频处理库。</p>
<p>还是有一个小目标的:</p>
<ul>
<li><p>打造一个万能音频播放器。不管是直播源还是网络/本地源，只要给我一个路径我就能播放。</p>
</li>
<li><p>增加一些特殊的处理比如，变调变速、变声、裁剪…</p>
</li>
<li><p>一切皆有可能。</p>
</li>
</ul>
<p>可以看下效果图:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505195250.gif" alt=""></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>编码环境</strong></p>
<p>FFmpeg : 4.2.2</p>
<p>NDK: 17c</p>
<p>OS: MAC</p>
<p><strong>实现流程:</strong></p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505221954.png" alt=""></p>
<p><strong>粗略架构组成:</strong></p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505204348.png" alt=""></p>
<p><strong><a href="https://github.com/JetBrains/kotlin">kotlin</a>:</strong></p>
<p><strong>Kotlin</strong> 语言是由 <strong>JetBrains</strong> 公司开发，2010 面世，2017 年正式在谷歌 I/O 大会上推荐 Kotlin 作为 Android 开发语言。</p>
<p><strong><a href="https://github.com/FFmpeg/FFmpeg">FFmpeg</a>:</strong></p>
<p>FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。</p>
<p><strong><a href="https://gitlab.com/soundtouch/soundtouch">SoundTouch</a>:</strong></p>
<p>可以在 PCM 音频裸流基础上对音频变调变速</p>
<p><strong><a href="https://developer.android.google.cn/ndk/guides/audio/opensl-for-android">OpenSLES</a>:</strong></p>
<p><strong>OpenSL ES</strong>（<strong>嵌入式系统的开放声音库</strong>）是一种免版税，跨平台，硬件加速的 <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C语言</a> 音频<a href="https://en.wikipedia.org/wiki/Application_programming_interface">API，</a>用于2D和3D音频。它提供对<a href="https://en.wikipedia.org/wiki/3D_audio">3D位置音频</a>和<a href="https://en.wikipedia.org/wiki/MIDI">MIDI</a>播放等功能的访问。它是为移动和游戏行业的开发人员设计的，致力于使跨多个平台的应用程序轻松移植。</p>
<h2 id="FFmpeg-初始化"><a href="#FFmpeg-初始化" class="headerlink" title="FFmpeg 初始化"></a>FFmpeg 初始化</h2><p>编译 FFmpeg 可以参考我之前写的文章<a href="https://juejin.im/post/5e1eace16fb9a02fec66474e">音视频学习 (六) 一键编译 32/64 位 FFmpeg 4.2.2</a></p>
<p>这里我们就按照 FFmpeg 初始化流程来进行介绍 API 如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 分配一个 AVFormatContext。</span></span><br><span class="line"><span class="function">AVFormatContext *<span class="title">avformat_alloc_context</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//对应的释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avformat_free_context</span><span class="params">(AVFormatContext *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 打开输入流，读取头部信息，一般包含有音频，视频流信息也可能有弹幕信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, ff_const59 AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br><span class="line"><span class="comment">//对应的关闭流信息，释放所有内容资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avformat_close_input</span><span class="params">(AVFormatContext **s)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//3. 读取媒体文件的数据包以获取流信息。返回 &gt;=0 则成功</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br><span class="line"><span class="comment">//3.1 拿到当前流的数量信息，一般会有音频，视频，或者弹幕</span></span><br><span class="line"><span class="keyword">int</span> number = (*AVFormatContext)-&gt;nb_streams</span><br><span class="line"><span class="comment">//3.2 遍历拿到对应的 stream</span></span><br><span class="line"><span class="comment">//视频流</span></span><br><span class="line"><span class="keyword">if</span> ((*pFormatCtx)-&gt;streams &amp;&amp; (*pFormatCtx)-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line"><span class="comment">//语音流</span></span><br><span class="line"> <span class="keyword">if</span> ((*pFormatCtx)-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO)</span><br><span class="line"><span class="comment">//其它流类型</span></span><br><span class="line"><span class="keyword">enum</span> AVMediaType &#123;</span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 根据 AVCodecID 拿到已经注册的解码器</span></span><br><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 分配一个 AVCodecContext </span></span><br><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="keyword">const</span> AVCodec *codec)</span></span>;</span><br><span class="line"><span class="comment">//对应的释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avcodec_free_context</span><span class="params">(AVCodecContext **avctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 给解码器设置参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> AVCodecParameters *par)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 打开解码器 is 0 success</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上 7 步如果没有问题证明编解码器打开成功，可以进行下一步操作。</p>
<h2 id="FFmpeg-读取音频帧"><a href="#FFmpeg-读取音频帧" class="headerlink" title="FFmpeg 读取音频帧"></a>FFmpeg 读取音频帧</h2><p>这里还是介绍 API 使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 分配一个 AVPacket </span></span><br><span class="line"><span class="function">AVPacket *<span class="title">av_packet_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//结果必须释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_packet_free</span><span class="params">(AVPacket **pkt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 读取待解码数据包</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对，就是这么简单，就调用 3 个 API 然后循环读取，送入待解码队列中。</p>
<h2 id="FFmpeg-解码音频为-PCM"><a href="#FFmpeg-解码音频为-PCM" class="headerlink" title="FFmpeg 解码音频为 PCM"></a>FFmpeg 解码音频为 PCM</h2><p>这里相当于是读取待解码队列中的数据，进行解码为 PCM 数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 将待解码数据 AVPacket 送入解码器 0 is ok</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVPacket *avpkt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 分配一个 AVFrame 用于接收解码之后的数据</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//对应的释放 API</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 接收解码之后的数据 0 is ok</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对解码之后的 PCM 进行统一重采样。规定一些格式，避免不统一而渲染异常</span></span><br><span class="line"><span class="comment">//4. 根据传入的参数来分配一个 SwrContext</span></span><br><span class="line"><span class="function">struct SwrContext *<span class="title">swr_alloc_set_opts</span><span class="params">(struct SwrContext *s,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int64_t</span> out_ch_layout, <span class="keyword">enum</span> AVSampleFormat out_sample_fmt, <span class="keyword">int</span> out_sample_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int64_t</span>  in_ch_layout, <span class="keyword">enum</span> AVSampleFormat  in_sample_fmt, <span class="keyword">int</span>  in_sample_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> log_offset, <span class="keyword">void</span> *log_ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.1 对 SwrContext 进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swr_init</span><span class="params">(struct SwrContext *s)</span></span>;</span><br><span class="line"><span class="comment">//4.2 开始重采样</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swr_convert</span><span class="params">(struct SwrContext *s, <span class="keyword">uint8_t</span> **out, <span class="keyword">int</span> out_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">uint8_t</span> **in , <span class="keyword">int</span> in_count)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="OpenSLES-渲染-PCM"><a href="#OpenSLES-渲染-PCM" class="headerlink" title="OpenSLES 渲染 PCM"></a>OpenSLES 渲染 PCM</h2><p>这里还是以流程的形式介绍 API 含义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建播放引擎</span></span><br><span class="line">result = slCreateEngine(&amp;engineObject, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">result = (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE);</span><br><span class="line">result = (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineEngine);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建混音器</span></span><br><span class="line"><span class="keyword">const</span> SLInterfaceID mids[<span class="number">1</span>] = &#123;SL_IID_ENVIRONMENTALREVERB&#125;;</span><br><span class="line"><span class="keyword">const</span> SLboolean mreq[<span class="number">1</span>] = &#123;SL_BOOLEAN_FALSE&#125;;</span><br><span class="line">result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE);</span><br><span class="line">result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB,</span><br><span class="line">                                              &amp;outputMixEnvironmentalReverb);</span><br><span class="line">    <span class="keyword">if</span> (SL_RESULT_SUCCESS == result) &#123;</span><br><span class="line">        result = (*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties(</span><br><span class="line">                outputMixEnvironmentalReverb, &amp;reverbSettings);</span><br><span class="line">        (<span class="keyword">void</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line">SLDataLocator_OutputMix outputMix = &#123;SL_DATALOCATOR_OUTPUTMIX, outputMixObject&#125;;</span><br><span class="line">SLDataSink audioSnk = &#123;&amp;outputMix, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 配置PCM格式信息</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue android_queue = &#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    SLDataFormat_PCM pcm = &#123;</span><br><span class="line">            SL_DATAFORMAT_PCM,<span class="comment">//播放pcm格式的数据</span></span><br><span class="line">            <span class="number">2</span>,<span class="comment">//2个声道（立体声）</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;SLuint32&gt;(getCurSampleRate(sample_rate)),<span class="comment">//44100hz的频率</span></span><br><span class="line">            SL_PCMSAMPLEFORMAT_FIXED_16,<span class="comment">//位数 16位</span></span><br><span class="line">            SL_PCMSAMPLEFORMAT_FIXED_16,<span class="comment">//和位数一致就行</span></span><br><span class="line">            SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT,<span class="comment">//立体声（前左前右）</span></span><br><span class="line">            SL_BYTEORDER_LITTLEENDIAN<span class="comment">//结束标志</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    SLDataSource slDataSource = &#123;&amp;android_queue, &amp;pcm&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> SLInterfaceID ids[<span class="number">3</span>] = &#123;SL_IID_BUFFERQUEUE, SL_IID_VOLUME, SL_IID_MUTESOLO&#125;;</span><br><span class="line">    <span class="keyword">const</span> SLboolean req[<span class="number">3</span>] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"></span><br><span class="line">    result = (*engineEngine)-&gt;CreateAudioPlayer(engineEngine, &amp;pcmPlayerObject, &amp;slDataSource, &amp;audioSnk,</span><br><span class="line">                                                <span class="keyword">sizeof</span>(ids) / <span class="keyword">sizeof</span>(ids[<span class="number">0</span>]), ids, req);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 初始化播放器</span></span><br><span class="line">result = (*pcmPlayerObject)-&gt;Realize(pcmPlayerObject, SL_BOOLEAN_FALSE);</span><br><span class="line">result = (*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_PLAY, &amp;pcmPlayerPlay);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 注册回调缓冲区 获取缓冲队列接口</span></span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_BUFFERQUEUE, &amp;pcmBufferQueue);</span><br><span class="line">(*pcmBufferQueue)-&gt;RegisterCallback(pcmBufferQueue, pcmBufferCallBack, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 设置播放状态</span></span><br><span class="line">(*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PLAYING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 手动激活回调接口</span></span><br><span class="line">pcmBufferCallBack(pcmBufferQueue, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>初始化就是这 7 大步，那么渲染的话，就是在 <code>pcmBufferCallBack</code> 中进行设置，直接上代码吧:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcmBufferCallBack</span><span class="params">(SLAndroidSimpleBufferQueueItf bf, <span class="keyword">void</span> *pVoid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> audioPlayer = <span class="keyword">static_cast</span>&lt;BaseAudioChannel *&gt;(pVoid);</span><br><span class="line">    <span class="keyword">if</span> (!audioPlayer)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (audioPlayer-&gt;status &amp;&amp; audioPlayer-&gt;status-&gt;<span class="built_in">exit</span>)</span><br><span class="line">        LOGE(<span class="string">"looper  pcmBufferCallBack start"</span>);</span><br><span class="line">    <span class="comment">//拿到 PCM 原始数据</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = audioPlayer-&gt;getPCMData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对 PCM 做变速变调操作。</span></span><br><span class="line">    <span class="built_in">size</span> = audioPlayer-&gt;setSoundTouchData();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">            <span class="comment">//8. 放入缓存，开始播放声音</span></span><br><span class="line">		(*audioPlayer-&gt;pcmBufferQueue)-&gt;Enqueue(audioPlayer-&gt;pcmBufferQueue, audioPlayer-&gt;out_pcm_buffer, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对，没错。第八步就是真正将 PCM 放入 OpenSL ES 缓冲队列中，这里要注意，一点要等它的上一帧渲染完在放入下一帧 PCM 数据。</p>
<h2 id="功能点实现"><a href="#功能点实现" class="headerlink" title="功能点实现:"></a>功能点实现:</h2><h3 id="声道选择"><a href="#声道选择" class="headerlink" title="声道选择"></a>声道选择</h3><p>声道操作直接操作的是 OpenSLES 接口，具体 API 如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 得到音频声道通道接口</span></span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_MUTESOLO, &amp;pcmChannelModePlay);</span><br><span class="line"><span class="comment">//2. 设置音频通道</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置音频通道</span></span><br><span class="line"><span class="comment"> * @param channelMode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseAudioChannel::setChannelMode</span><span class="params">(<span class="keyword">int</span> channelMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mChannelMode = channelMode;</span><br><span class="line">    <span class="keyword">if</span> (pcmChannelModePlay != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelMode == <span class="number">0</span>)<span class="comment">//右声道</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (channelMode == <span class="number">1</span>)<span class="comment">//左声道</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (channelMode == <span class="number">2</span>)<span class="comment">//立体声 通道为 2 也就是我们重采样设置的 AV_CH_LAYOUT_STEREO</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><p>声音音量控制这里还是基于的是 OpenSLES 接口，对应 API 如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 拿到音频声音控制接口</span></span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_VOLUME, &amp;pcmVolumePlay);</span><br><span class="line"><span class="comment">//2. 设置声音</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平滑设置当前音量</span></span><br><span class="line"><span class="comment"> * @param volume</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseAudioChannel::setVolume</span><span class="params">(<span class="keyword">int</span> percent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;curVolume = percent;</span><br><span class="line">    <span class="keyword">if</span> (pcmVolumePlay != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (percent &gt; <span class="number">30</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-20</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">25</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-22</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-25</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">15</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-28</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-30</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-34</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-37</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-40</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语调语速设置"><a href="#语调语速设置" class="headerlink" title="语调语速设置"></a>语调语速设置</h3><p>语调语速功能这里用的开源的 <a href="https://gitlab.com/soundtouch/soundtouch">SoundTouch</a> ，具体实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BaseAudioChannel::setSoundTouchData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (status &amp;&amp; !status-&gt;<span class="built_in">exit</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            finished = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mBufSize &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;out_pcm_buffer) &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutexSpeed);</span><br><span class="line">                soundTouch-&gt;putSamples(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> SAMPLETYPE *&gt;(<span class="keyword">this</span>-&gt;out_pcm_buffer), <span class="keyword">this</span>-&gt;oldSize);</span><br><span class="line">                num = soundTouch-&gt;receiveSamples(<span class="keyword">reinterpret_cast</span>&lt;SAMPLETYPE *&gt;(<span class="keyword">this</span>-&gt;out_pcm_buffer),</span><br><span class="line">                                                 <span class="keyword">this</span>-&gt;mBufSize / <span class="number">4</span>);</span><br><span class="line">                pthread_mutex_unlock(&amp;mutexSpeed);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                soundTouch-&gt;<span class="built_in">flush</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            finished = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="seek-指定在某个时间段播放"><a href="#seek-指定在某个时间段播放" class="headerlink" title="seek 指定在某个时间段播放"></a>seek 指定在某个时间段播放</h3><p>seek 功能直接调取的 FFmpeg API ，操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseDecodec::seek</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (number &gt;= <span class="number">0</span> &amp;&amp; number &lt;= number) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> rel = number * AV_TIME_BASE;</span><br><span class="line">        avcodec_flush_buffers(<span class="keyword">this</span>-&gt;avCodecContext);</span><br><span class="line">        avformat_seek_file(<span class="keyword">this</span>-&gt;avFormatContext, <span class="number">-1</span>, INT64_MIN, rel, INT64_MAX, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="截取-PCM"><a href="#截取-PCM" class="headerlink" title="截取 PCM"></a>截取 PCM</h3><p>截取 PCM 原理其实很简单，比如一段音频的总长为  500s ，我想要截取 300 - 400s 部分，那么我首先 seek(300)作为起点，如果解码帧的时间到了 500 那么就直接退出就 OK 了，是不是很简单。</p>
<p>这里我说下怎么获取时间:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是基本的时间单位（以秒为单位）表示其中的帧时间戳。</span></span><br><span class="line"><span class="keyword">this</span>-&gt;time_base = (*pFormatCtx)-&gt;streams[i]-&gt;time_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 初始化 FFmpeg 读取流 header 信息可以获取</span></span><br><span class="line"><span class="keyword">int</span> audioDuration = (*pFormatCtx)-&gt;streams[i]-&gt;duration / AV_TIME_BASE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 读取待解码 AVPacket 包获取时间</span></span><br><span class="line"><span class="keyword">int</span> readCurAudioTime = avPacket-&gt;pts * av_q2d(time_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 解码获取时间</span></span><br><span class="line"><span class="keyword">int</span> decodeAudioCurTime = avFrame-&gt;pts * av_q2d(time_base);</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我们的音频处理库就讲解完了，对于音视频感兴趣的可以作为学习资料，因为我本人不喜欢弄 UI ，不然我可以仿照一个 网易云音乐的 UI + 我自己的音频处理库来做一个音频 APP 。当然你可以这样来搞。</p>
<p>文章中所有的代码已上传 <a href="https://github.com/yangkun19921001/AudioManager">GitHub</a></p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><ul>
<li>Email: <a href="mailto:yang1001yk@gmail.com">yang1001yk@gmail.com</a></li>
<li>个人博客: <a href="https://www.devyk.top">https://www.devyk.top</a></li>
<li>GitHub: <a href="https://github.com/yangkun19921001">https://github.com/yangkun19921001</a></li>
<li>掘金博客: <a href="https://juejin.im/user/578259398ac2470061f3a3fb">https://juejin.im/user/578259398ac2470061f3a3fb/posts</a></li>
</ul>
<p><strong>扫码关注我的公众号，让我们离得更近一些!</strong></p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200315232530.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:24:00.000Z" title="2020-06-04T10:24:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">1 小时 读完 (大约 10130 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/Android-%E5%8D%81%E4%B8%80-Android-%E7%AB%AF-rtmp-%E6%8E%A8%E6%B5%81/">音视频学习 (十一) Android 端 rtmp 推流</a></h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302220507.png" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>咱们回顾了前面 2 篇文章，主要讲解了如何搭建 rtmp <a href="https://juejin.im/post/5e4ec66c5188254967067502">直播服务器</a>，和如何开发一款具有拉流功能的 Android <a href="https://juejin.im/post/5e495ec1e51d452713551017">播放器</a>。那么现在有了播放端和直播服务器还缺少推流端。该篇文章我们就一起来实现 Android 端的 rtmp 推流，想要实现 Android 端推流必须要经过如下几个阶段，见下图:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302154202.png" alt=""></p>
<p>该篇文章主要完成上图黄颜色功能部分，下面就开始进入正题，代码编写了。</p>
<h2 id="项目效果"><a href="#项目效果" class="headerlink" title="项目效果"></a>项目效果</h2><h2 id="推流监控"><a href="#推流监控" class="headerlink" title="推流监控"></a>推流监控</h2><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302204444.png" alt=""></p>
<h3 id="软编码"><a href="#软编码" class="headerlink" title="软编码"></a>软编码</h3><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302210529.gif" alt=""></p>
<h3 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h3><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302210914.gif" alt=""></p>
<p>文章末尾会介绍软硬编解码。</p>
<h2 id="音频采集"><a href="#音频采集" class="headerlink" title="音频采集"></a>音频采集</h2><p>Android SDK 提供了两套音频采集的 API ,分别是 MediaRecorder 、AudioRecord 。前者是一个上层 API ,它可以直接对手机麦克风录入的音频数据进行编码压缩(如 AMR/MP3) 等，并存储为文件；后者则更接近底层，能够更加自由灵活地控制，其可以让开发者得到内存中的 PCM 原始音频数据流。如果想做一个简单的录音机，输出音频文件则推荐使用 MediaRecorder ； 如果需要对音频做进一步的算法处理，或者需要采用第三方的编码库进行编码，又或者需要用到网络传输等场景中，那么只能使用 AudioRecord 或者 OpenSL ES ，其实 MediaRecorder 底层也是调用了 AudioRecord 与 Android Framework 层的 AudioFlinger 进行交互的。而我们该篇的场景更倾向于第二种实现方式，即使用 AudioRecord 来采集音频。</p>
<p>如果想要使用 AudioRecord 这个 API ,则需要在应用 AndroidManifest.xml 的配置文件中进行如下配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECORD_AUDIO"</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，如果你想把采集到的 PCM 原始数据，存储 sdcard 中，还需要额外添加写入权限:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来了解一下 AudioRecord 的工作流程。</p>
<h3 id="1-初始化-AudioRecord"><a href="#1-初始化-AudioRecord" class="headerlink" title="1. 初始化 AudioRecord"></a>1. 初始化 AudioRecord</h3><p>首先来看一下 AudioRecord 的配置参数，AudioRecord 是通过构造函数来配置参数的，其函数原型如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AudioRecord</span><span class="params">(<span class="keyword">int</span> audioSource, <span class="keyword">int</span> sampleRateInHz, <span class="keyword">int</span> channelConfig, <span class="keyword">int</span> audioFormat,<span class="keyword">int</span> bufferSizeInBytes)</span></span></span><br></pre></td></tr></table></figure>

<p>上述参数所代表的函数及其在各种场景下应该传递的值的含义参考如下说明:</p>
<p><strong>audioSource:</strong> 该参数指的是音频采集的输入源，可选值以常量的形式定义在类 AudioSource （MediaRecorder 中的一个内部类）中，常用的值包过:</p>
<ul>
<li>DEFAULT(默认)</li>
<li>VOICE_RECOGNITION (用于语音识别，等同于默认)</li>
<li>MIC (由手机麦克风输入)</li>
<li>VOICE_COMMUNICATION (用于 VOIP 应用场景)</li>
</ul>
<p><strong>sampleRateInHz:</strong> 用于指定以多大的采样频率来采集音频，现在用的最多的兼容最好是 44100 (44.1KHZ)采样频率。</p>
<p><strong>channelConfig:</strong> 该参数用于指定录音器采集几个声道的声音，可选值以常量的形式定义在 AudioFormat 类中，常用的值包括:</p>
<ul>
<li>CHANNEL_IN_MONO 单声道 (移动设备上目前推荐使用)</li>
<li>CHANNEL_IN_STEREO 立体声</li>
</ul>
<p><strong>audioFormat:</strong> 采样格式，以常量的形式定义在 AudioFormat 类中，常用的值包括:</p>
<ul>
<li>ENCODING_PCM_16BIT (16bit 兼容大部分 Android 手机)</li>
<li>ENCODING_PCM_8BIT (8bit)</li>
</ul>
<p><strong>bufferSizeInBytes:</strong> 配置内部音频缓冲区的大小(配置的缓存值越小，延时就越低)，而具体的大小，有可能在不同的手机上会有不同的值，那么可以使用如下 API 进行确定缓冲大小:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioRecord.getMinBufferSize(<span class="keyword">int</span> sampleRateInHz, <span class="keyword">int</span> channelConfig, <span class="keyword">int</span> audioFormat);</span><br></pre></td></tr></table></figure>

<p>配置好之后，检查一下 AudioRecord 当前的状态是否可以进行录制，可以通过 AudioRecord##getState 来获取当前的状态:</p>
<ul>
<li>STATE_UNINITIALIZED 还没有初始化，或者初始化失败了</li>
<li>STATE_INITIALIZED 已经初始化成功了。</li>
</ul>
<h3 id="2-开启采集"><a href="#2-开启采集" class="headerlink" title="2. 开启采集"></a>2. 开启采集</h3><p>创建好 AudioRecord 之后，就可以开启音频数据的采集了，可以通过调用下面的函数进行控制麦克风的采集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mAudioRecord.startRecording();</span><br></pre></td></tr></table></figure>

<h3 id="3-提取数据"><a href="#3-提取数据" class="headerlink" title="3. 提取数据"></a>3. 提取数据</h3><p>执行完上一步之后，需要开启一个子线程用于不断的从 AudioRecord 缓冲区读取 PCM 数据，调用如下函数进行读取数据:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(@NonNull <span class="keyword">byte</span>[] audioData, <span class="keyword">int</span> offsetInBytes, <span class="keyword">int</span> sizeInBytes)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-停止采集"><a href="#4-停止采集" class="headerlink" title="4. 停止采集"></a>4. 停止采集</h3><p>如果想要停止采集，那么只需要调用 AudioRecord 的 stop 方法来实现，最后可以通过一个变量先控制子线程停止读取数据，然后在调用 stop 停止最后释放 AudioRecord 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopEncode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//停止的变量标记</span></span><br><span class="line">    mStopFlag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mAudioEncoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">//停止采集</span></span><br><span class="line">        mAudioEncoder.stop();</span><br><span class="line">      	<span class="comment">//释放内存</span></span><br><span class="line">        mAudioEncoder = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视频采集"><a href="#视频采集" class="headerlink" title="视频采集"></a>视频采集</h2><p>视频画面的采集主要是使用各个平台提供的摄像头 API 来实现的，在为摄像头设置了合适的参数之后，将摄像头实时采集的视频帧渲染到屏幕上提供给用户预览，然后将该视频帧传递给编码通道，进行编码。</p>
<h3 id="1-权限配置"><a href="#1-权限配置" class="headerlink" title="1. 权限配置"></a>1. 权限配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name="android.permission.CAMERA"&gt;&lt;/uses-permission&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-打开摄像头"><a href="#2-打开摄像头" class="headerlink" title="2. 打开摄像头"></a>2. 打开摄像头</h3><h4 id="2-1-检查摄像头"><a href="#2-1-检查摄像头" class="headerlink" title="2.1 检查摄像头"></a>2.1 检查摄像头</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCameraService</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CameraDisabledException </span>&#123;</span><br><span class="line">    <span class="comment">// Check if device policy has disabled the camera.</span></span><br><span class="line">    DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(</span><br><span class="line">            Context.DEVICE_POLICY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (dpm.getCameraDisabled(<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CameraDisabledException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-检查摄像头的个数"><a href="#2-2-检查摄像头的个数" class="headerlink" title="2.2 检查摄像头的个数"></a>2.2 检查摄像头的个数</h4><p>检查完摄像头服务后，还需要检查手机上摄像头的个数，如果个数为 0，则说明手机上没有摄像头，这样的话也是不能进行后续操作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;CameraData&gt; <span class="title">getAllCamerasData</span><span class="params">(<span class="keyword">boolean</span> isBackFirst)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;CameraData&gt; cameraDatas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Camera.CameraInfo cameraInfo = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line">    <span class="keyword">int</span> numberOfCameras = Camera.getNumberOfCameras();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfCameras; i++) &#123;</span><br><span class="line">        Camera.getCameraInfo(i, cameraInfo);</span><br><span class="line">        <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">            CameraData cameraData = <span class="keyword">new</span> CameraData(i, CameraData.FACING_FRONT);</span><br><span class="line">            <span class="keyword">if</span>(isBackFirst) &#123;</span><br><span class="line">                cameraDatas.add(cameraData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cameraDatas.add(<span class="number">0</span>, cameraData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">            CameraData cameraData = <span class="keyword">new</span> CameraData(i, CameraData.FACING_BACK);</span><br><span class="line">            <span class="keyword">if</span>(isBackFirst) &#123;</span><br><span class="line">                cameraDatas.add(<span class="number">0</span>, cameraData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cameraDatas.add(cameraData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cameraDatas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的方法中，需要传入一个是否先开启背面摄像头的 boolean 变量，如果变量为 true，则把背面摄像头放在列表第一个，之后打开摄像头的时候，直接获取列表中第一个摄像头相关参数，然后进行打开。这样的设计使得切换摄像头也变得十分简单，切换摄像头时，先关闭当前摄像头，然后变化摄像头列表中的顺序，然后再打开摄像头即可，也就是每次打开摄像头都打开摄像头列表中第一个摄像头参数所指向的摄像头。</p>
<h4 id="2-3-打开摄像头"><a href="#2-3-打开摄像头" class="headerlink" title="2.3 打开摄像头"></a>2.3 打开摄像头</h4><p>打开摄像头之前，先从摄像头列表中获取第一个摄像头参数，之后根据参数中的 CameraId 来打开摄像头，打开成功后改变相关状态。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Camera <span class="title">openCamera</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CameraHardwareException, CameraNotSupportException </span>&#123;</span><br><span class="line">    CameraData cameraData = mCameraDatas.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mCameraDevice != <span class="keyword">null</span> &amp;&amp; mCameraData == cameraData) &#123;</span><br><span class="line">        <span class="keyword">return</span> mCameraDevice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCameraDevice != <span class="keyword">null</span>) &#123;</span><br><span class="line">        releaseCamera();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"open camera "</span> + cameraData.cameraID);</span><br><span class="line">        mCameraDevice = Camera.open(cameraData.cameraID);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"fail to connect Camera"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CameraHardwareException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mCameraDevice == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CameraNotSupportException();</span><br><span class="line">    &#125;</span><br><span class="line">    mCameraData = cameraData;</span><br><span class="line">    mState = State.OPENED;</span><br><span class="line">    <span class="keyword">return</span> mCameraDevice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面需要注意的是，在 Android 提供的 Camera 源码中，Camera.open(cameraData.cameraID) 抛出异常则说明Camera 不可用，否则说明 Camera 可用，但是在一些手机上 Camera.open(cameraData.cameraID) 不是抛出异常，而是返回 null。</p>
<h3 id="3-配置摄像头参数"><a href="#3-配置摄像头参数" class="headerlink" title="3. 配置摄像头参数"></a>3. 配置摄像头参数</h3><p>在给摄像头设置参数后，需要记录这些参数，以方便其他地方使用。比如记录当前摄像头是否有闪光点，从而可以决定 UI 界面上是否显示打开闪光灯按钮。在直播项目中使用 CameraData 来记录这些参数，CameraData 类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FACING_FRONT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FACING_BACK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cameraID;            <span class="comment">//camera的id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cameraFacing;        <span class="comment">//区分前后摄像头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cameraWidth;         <span class="comment">//camera的采集宽度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cameraHeight;        <span class="comment">//camera的采集高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> hasLight;        <span class="comment">//camera是否有闪光灯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> orientation;         <span class="comment">//camera旋转角度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> supportTouchFocus;   <span class="comment">//camera是否支持手动对焦</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> touchFocusMode;      <span class="comment">//camera是否处在自动对焦模式</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraData</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> facing, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        cameraID = id;</span><br><span class="line">        cameraFacing = facing;</span><br><span class="line">        cameraWidth = width;</span><br><span class="line">        cameraHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraData</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> facing)</span> </span>&#123;</span><br><span class="line">        cameraID = id;</span><br><span class="line">        cameraFacing = facing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给摄像头设置参数的时候，有一点需要注意：设置的参数不生效会抛出异常，因此需要每个参数单独设置，这样就避免一个参数不生效后抛出异常，导致之后所有的参数都没有设置。</p>
<h3 id="4-摄像头开启预览"><a href="#4-摄像头开启预览" class="headerlink" title="4. 摄像头开启预览"></a>4. 摄像头开启预览</h3><p>设置预览界面有两种方式：1、通过 SurfaceView 显示；2、通过 GLSurfaceView 显示。当为 SurfaceView 显示时，需要传给 Camera 这个 SurfaceView 的 SurfaceHolder。当使用 GLSurfaceView 显示时，需要使用Renderer 进行渲染，先通过 OpenGL 生成纹理，通过生成纹理的纹理 id 生成 SurfaceTexture ，将SurfaceTexture 交给 Camera ，那么在 Render 中便可以使用这个纹理进行相应的渲染，最后通过GLSurfaceView 显示。</p>
<h4 id="4-1-设置预览回调"><a href="#4-1-设置预览回调" class="headerlink" title="4.1 设置预览回调"></a>4.1 设置预览回调</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPreviewFormat</span><span class="params">(Camera camera, Camera.Parameters parameters)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置预览回调的图片格式</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parameters.setPreviewFormat(ImageFormat.NV21);</span><br><span class="line">        camera.setParameters(parameters);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当设置预览好预览回调的图片格式后，需要设置预览回调的 Callback。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Camera.PreviewCallback myCallback = <span class="keyword">new</span> Camera.PreviewCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//得到相应的图片数据</span></span><br><span class="line">        <span class="comment">//Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPreviewCallback</span><span class="params">(Camera camera, Camera.PreviewCallback callback)</span> </span>&#123;</span><br><span class="line">    camera.setPreviewCallback(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Android 推荐的 PreViewFormat 是 NV21，在 PreviewCallback 中会返回 Preview 的 N21 图片。如果是软编的话，由于 H264 支持 I420 的图片格式，因此需要将 N21格式转为 I420 格式，然后交给 x264 编码库。如果是硬编的话，由于 Android 硬编编码器支持 I420(COLOR_FormatYUV420Planar) 和NV12(COLOR_FormatYUV420SemiPlanar)，因此可以将 N21 的图片转为 I420 或者 NV12 ，然后交给硬编编码器。</p>
<h4 id="4-2-设置预览图像大小"><a href="#4-2-设置预览图像大小" class="headerlink" title="4.2 设置预览图像大小"></a>4.2 设置预览图像大小</h4><p>在摄像头相关处理中，一个比较重要的是 <strong>屏幕显示大小和摄像头预览大小比例不一致</strong> 的处理。在 Android 中，摄像头有一系列的 PreviewSize，我们需要从中选出适合的 PreviewSize 。选择合适的摄像头 PreviewSize 的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Camera.<span class="function">Size <span class="title">getOptimalPreviewSize</span><span class="params">(Camera camera, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    Camera.Size optimalSize = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">double</span> minHeightDiff = Double.MAX_VALUE;</span><br><span class="line">    <span class="keyword">double</span> minWidthDiff = Double.MAX_VALUE;</span><br><span class="line">    List&lt;Camera.Size&gt; sizes = camera.getParameters().getSupportedPreviewSizes();</span><br><span class="line">    <span class="keyword">if</span> (sizes == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//找到宽度差距最小的</span></span><br><span class="line">    <span class="keyword">for</span>(Camera.Size size:sizes)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(size.width - width) &lt; minWidthDiff) &#123;</span><br><span class="line">            minWidthDiff = Math.abs(size.width - width);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在宽度差距最小的里面，找到高度差距最小的</span></span><br><span class="line">    <span class="keyword">for</span>(Camera.Size size:sizes)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(size.width - width) == minWidthDiff) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(size.height - height) &lt; minHeightDiff) &#123;</span><br><span class="line">                optimalSize = size;</span><br><span class="line">                minHeightDiff = Math.abs(size.height - height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> optimalSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPreviewSize</span><span class="params">(Camera camera, Camera.Size size, Camera.Parameters parameters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;    </span><br><span class="line">        parameters.setPreviewSize(size.width, size.height);           </span><br><span class="line">        camera.setParameters(parameters);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;    </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设置好最适合的 PreviewSize 之后，将 size 信息存储在 CameraData 中。当选择了 SurfaceView 显示的方式，可以将 SurfaceView 放置在一个 LinearLayout 中，然后根据摄像头 PreviewSize 的比例改变 SurfaceView 的大小，从而使得两者比例一致，确保图像正常。当选择了GLSurfaceView 显示的时候，可以通过裁剪纹理，使得纹理的大小比例和 GLSurfaceView 的大小比例保持一致，从而确保图像显示正常。</p>
<h4 id="4-3-图像旋转"><a href="#4-3-图像旋转" class="headerlink" title="4.3 图像旋转"></a>4.3 图像旋转</h4><p>在 Android 中摄像头出来的图像需要进行一定的旋转，然后才能交给屏幕显示，而且如果应用支持屏幕旋转的话，也需要根据旋转的状况实时调整摄像头的角度。在 Android 中旋转摄像头图像同样有两种方法，一是通过摄像头的 setDisplayOrientation(result) 方法，一是通过 OpenGL 的矩阵进行旋转。下面是通过setDisplayOrientation(result) 方法进行旋转的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDisplayRotation</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">    <span class="keyword">switch</span> (rotation) &#123;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_0: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_90: <span class="keyword">return</span> <span class="number">90</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_180: <span class="keyword">return</span> <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_270: <span class="keyword">return</span> <span class="number">270</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCameraDisplayOrientation</span><span class="params">(Activity activity, <span class="keyword">int</span> cameraId, Camera camera)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See android.hardware.Camera.setCameraDisplayOrientation for</span></span><br><span class="line">    <span class="comment">// documentation.</span></span><br><span class="line">    Camera.CameraInfo info = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line">    Camera.getCameraInfo(cameraId, info);</span><br><span class="line">    <span class="keyword">int</span> degrees = getDisplayRotation(activity);</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">        result = (info.orientation + degrees) % <span class="number">360</span>;</span><br><span class="line">        result = (<span class="number">360</span> - result) % <span class="number">360</span>; <span class="comment">// compensate the mirror</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// back-facing</span></span><br><span class="line">        result = (info.orientation - degrees + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    camera.setDisplayOrientation(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-设置预览帧率"><a href="#4-4-设置预览帧率" class="headerlink" title="4.4 设置预览帧率"></a>4.4 设置预览帧率</h4><p>通过 Camera.Parameters 中 getSupportedPreviewFpsRange() 可以获得摄像头支持的帧率变化范围，从中选取合适的设置给摄像头即可。相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCameraFps</span><span class="params">(Camera camera, <span class="keyword">int</span> fps)</span> </span>&#123;</span><br><span class="line">    Camera.Parameters params = camera.getParameters();</span><br><span class="line">    <span class="keyword">int</span>[] range = adaptPreviewFps(fps, params.getSupportedPreviewFpsRange());</span><br><span class="line">    params.setPreviewFpsRange(range[<span class="number">0</span>], range[<span class="number">1</span>]);</span><br><span class="line">    camera.setParameters(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] adaptPreviewFps(<span class="keyword">int</span> expectedFps, List&lt;<span class="keyword">int</span>[]&gt; fpsRanges) &#123;</span><br><span class="line">    expectedFps *= <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span>[] closestRange = fpsRanges.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> measure = Math.abs(closestRange[<span class="number">0</span>] - expectedFps) + Math.abs(closestRange[<span class="number">1</span>] - expectedFps);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] range : fpsRanges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (range[<span class="number">0</span>] &lt;= expectedFps &amp;&amp; range[<span class="number">1</span>] &gt;= expectedFps) &#123;</span><br><span class="line">            <span class="keyword">int</span> curMeasure = Math.abs(range[<span class="number">0</span>] - expectedFps) + Math.abs(range[<span class="number">1</span>] - expectedFps);</span><br><span class="line">            <span class="keyword">if</span> (curMeasure &lt; measure) &#123;</span><br><span class="line">                closestRange = range;</span><br><span class="line">                measure = curMeasure;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closestRange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-设置相机对焦"><a href="#4-5-设置相机对焦" class="headerlink" title="4.5 设置相机对焦"></a>4.5 设置相机对焦</h4><p>一般摄像头对焦的方式有两种：手动对焦和触摸对焦。下面的代码分别是设置自动对焦和触摸对焦的模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAutoFocusMode</span><span class="params">(Camera camera)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Camera.Parameters parameters = camera.getParameters();</span><br><span class="line">        List&lt;String&gt; focusModes = parameters.getSupportedFocusModes();</span><br><span class="line">        <span class="keyword">if</span> (focusModes.size() &gt; <span class="number">0</span> &amp;&amp; focusModes.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) &#123;</span><br><span class="line">            parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (focusModes.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            parameters.setFocusMode(focusModes.get(<span class="number">0</span>));</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTouchFocusMode</span><span class="params">(Camera camera)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Camera.Parameters parameters = camera.getParameters();</span><br><span class="line">        List&lt;String&gt; focusModes = parameters.getSupportedFocusModes();</span><br><span class="line">        <span class="keyword">if</span> (focusModes.size() &gt; <span class="number">0</span> &amp;&amp; focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) &#123;</span><br><span class="line">            parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (focusModes.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            parameters.setFocusMode(focusModes.get(<span class="number">0</span>));</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于自动对焦这样设置后就完成了工作，但是对于触摸对焦则需要设置对应的对焦区域。要准确地设置对焦区域，有三个步骤：一、得到当前点击的坐标位置；二、通过点击的坐标位置转换到摄像头预览界面坐标系统上的坐标；三、根据坐标生成对焦区域并且设置给摄像头。整个摄像头预览界面定义了如下的坐标系统，对焦区域也需要对应到这个坐标系统中。<br><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302170719.png" alt=""></p>
<p>如果摄像机预览界面是通过 SurfaceView 显示的则比较简单，由于要确保不变形，会将 SurfaceView 进行拉伸，从而使得 SurfaceView 和预览图像大小比例一致，因此整个 SurfaceView 相当于预览界面，只需要得到当前点击点在整个 SurfaceView 上对应的坐标，然后转化为相应的对焦区域即可。如果摄像机预览界面是通过GLSurfaceView 显示的则要复杂一些，由于纹理需要进行裁剪，才能使得显示不变形，这样的话，我们要还原出整个预览界面的大小，然后通过当前点击的位置换算成预览界面坐标系统上的坐标，然后得到相应的对焦区域，然后设置给摄像机。当设置好对焦区域后，通过调用 Camera 的 autoFocus() 方法即可完成触摸对焦。<br>整个过程代码量较多，请自行阅读项目源码。</p>
<h4 id="4-6-设置缩放"><a href="#4-6-设置缩放" class="headerlink" title="4.6 设置缩放"></a>4.6 设置缩放</h4><p>当检测到手势缩放的时候，我们往往希望摄像头也能进行相应的缩放，其实这个实现还是比较简单的。首先需要加入缩放的手势识别，当识别到缩放的手势的时候，根据缩放的大小来对摄像头进行缩放。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles the pinch-to-zoom gesture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoomGestureListener</span> <span class="keyword">extends</span> <span class="title">ScaleGestureDetector</span>.<span class="title">SimpleOnScaleGestureListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScale</span><span class="params">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mIsFocusing) &#123;</span><br><span class="line">            <span class="keyword">float</span> progress = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (detector.getScaleFactor() &gt; <span class="number">1.0f</span>) &#123;</span><br><span class="line">                progress = CameraHolder.instance().cameraZoom(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (detector.getScaleFactor() &lt; <span class="number">1.0f</span>) &#123;</span><br><span class="line">                progress = CameraHolder.instance().cameraZoom(<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mZoomListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mZoomListener.onZoomProgress(progress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cameraZoom</span><span class="params">(<span class="keyword">boolean</span> isBig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mState != State.PREVIEW || mCameraDevice == <span class="keyword">null</span> || mCameraData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Camera.Parameters params = mCameraDevice.getParameters();</span><br><span class="line">    <span class="keyword">if</span>(isBig) &#123;</span><br><span class="line">        params.setZoom(Math.min(params.getZoom() + <span class="number">1</span>, params.getMaxZoom()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        params.setZoom(Math.max(params.getZoom() - <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    mCameraDevice.setParameters(params);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>) params.getZoom()/params.getMaxZoom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-闪光灯操作"><a href="#4-7-闪光灯操作" class="headerlink" title="4.7 闪光灯操作"></a>4.7 闪光灯操作</h4><p>一个摄像头可能有相应的闪光灯，也可能没有，因此在使用闪光灯功能的时候先要确认是否有相应的闪光灯。检测摄像头是否有闪光灯的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">supportFlash</span><span class="params">(Camera camera)</span></span>&#123;</span><br><span class="line">    Camera.Parameters params = camera.getParameters();</span><br><span class="line">    List&lt;String&gt; flashModes = params.getSupportedFlashModes();</span><br><span class="line">    <span class="keyword">if</span>(flashModes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String flashMode : flashModes) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切换闪光灯的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">switchLight</span><span class="params">(Camera camera, Camera.Parameters cameraParameters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cameraParameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_OFF)) &#123;</span><br><span class="line">        cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        camera.setParameters(cameraParameters);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-开始预览"><a href="#4-8-开始预览" class="headerlink" title="4.8 开始预览"></a>4.8 开始预览</h4><p>当打开了摄像头，并且设置好了摄像头相关的参数后，便可以通过调用 Camera 的 startPreview() 方法开始预览。有一个需要说明，无论是 SurfaceView 还是 GLSurfaceView ，都可以设置 SurfaceHolder.Callback ，当界面开始显示的时候打开摄像头并且开始预览，当界面销毁的时候停止预览并且关闭摄像头，这样的话当程序退到后台，其他应用也能调用摄像头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private SurfaceHolder.Callback mSurfaceHolderCallback &#x3D; new SurfaceHolder.Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceDestroyed(SurfaceHolder holder) &#123;</span><br><span class="line">        Log.d(SopCastConstant.TAG, &quot;SurfaceView destroy&quot;);</span><br><span class="line">        CameraHolder.instance().stopPreview();</span><br><span class="line">        CameraHolder.instance().releaseCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.GINGERBREAD)</span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceCreated(SurfaceHolder holder) &#123;</span><br><span class="line">        Log.d(SopCastConstant.TAG, &quot;SurfaceView created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</span><br><span class="line">     Log.d(SopCastConstant.TAG, &quot;SurfaceView width:&quot; + width + &quot; height:&quot; + height);</span><br><span class="line">        CameraHolder.instance().openCamera();</span><br><span class="line">        CameraHolder.instance().startPreview();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-停止预览"><a href="#5-停止预览" class="headerlink" title="5. 停止预览"></a>5. 停止预览</h3><p>停止预览只需要释放掉相机资源即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">releaseCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == State.PREVIEW) &#123;</span><br><span class="line">        stopPreview();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mState != State.OPENED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCameraDevice == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCameraDevice.release();</span><br><span class="line">    mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">    mCameraData = <span class="keyword">null</span>;</span><br><span class="line">    mState = State.INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h2><p>AudioRecord 采集完之后需要对 PCM 数据进行实时的编码 (软编利用 <a href="https://sourceforge.net/projects/faac/files/faac-src/">libfaac</a> 通过 NDK 交叉编译静态库、硬编使用 Android SDK MediaCodec 进行编码)。</p>
<h3 id="软编"><a href="#软编" class="headerlink" title="软编"></a>软编</h3><p>语音软编这里们用主流的编码库 libfaac 进行编码 AAC 语音格式数据。 </p>
<h4 id="1-编译-libfaac"><a href="#1-编译-libfaac" class="headerlink" title="1. 编译 libfaac"></a>1. 编译 libfaac</h4><h5 id="1-1-下载-libfaac"><a href="#1-1-下载-libfaac" class="headerlink" title="1.1 下载 libfaac"></a>1.1 下载 libfaac</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceforge.net/projects/faac/files/faac-src/faac-1.29/faac-1.29.9.2.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="1-2-编写交叉编译脚本"><a href="#1-2-编写交叉编译脚本" class="headerlink" title="1.2 编写交叉编译脚本"></a>1.2 编写交叉编译脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打包地址</span></span><br><span class="line">PREFIX=`pwd`/android/armeabi-v7a</span><br><span class="line"><span class="meta">#</span><span class="bash">配置NDK 环境变量</span></span><br><span class="line">NDK_ROOT=$NDK_HOME</span><br><span class="line"><span class="meta">#</span><span class="bash">指定 CPU</span></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"><span class="meta">#</span><span class="bash">指定 Android API</span></span><br><span class="line">ANDROID_API=17</span><br><span class="line"><span class="meta">#</span><span class="bash">编译工具链目录</span></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">FLAGS="-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS  -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC"</span><br><span class="line"></span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi</span><br><span class="line">export CC="$CROSS_COMPILE-gcc --sysroot=$NDK_ROOT/platforms/android-17/arch-arm"</span><br><span class="line">export CFLAGS="$FLAGS"</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--with-pic \</span><br><span class="line">--enable-shared=no</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="2-CMakeLists-txt-配置"><a href="#2-CMakeLists-txt-配置" class="headerlink" title="2. CMakeLists.txt 配置"></a>2. CMakeLists.txt 配置</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"><span class="comment">#语音编码器</span></span><br><span class="line"><span class="keyword">set</span>(faac <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/faac)</span><br><span class="line"><span class="comment">#加载 faac 头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;faac&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#指定 faac 静态库文件目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;faac&#125;/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"><span class="comment">#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了</span></span><br><span class="line"><span class="keyword">file</span>(GLOB Push_CPP <span class="variable">$&#123;ykpusher&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment">#添加自己编写 cpp 源文件生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(ykpusher SHARED <span class="variable">$&#123;Push_CPP&#125;</span>)</span><br><span class="line"><span class="comment">#找系统中 NDK log库</span></span><br><span class="line"><span class="keyword">find_library</span>(log_lib</span><br><span class="line">        log)</span><br><span class="line"><span class="comment">#推流 so</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        <span class="comment">#播放 so</span></span><br><span class="line">        ykpusher</span><br><span class="line"><span class="comment">#        # 写了此命令不用在乎添加 ffmpeg lib 顺序问题导致应用崩溃</span></span><br><span class="line"><span class="comment">#        -Wl,--start-group</span></span><br><span class="line"><span class="comment">#        avcodec avfilter avformat avutil swresample swscale</span></span><br><span class="line"><span class="comment">#        -Wl,--end-group</span></span><br><span class="line"><span class="comment">#        z</span></span><br><span class="line">        <span class="comment">#推流库</span></span><br><span class="line">        rtmp</span><br><span class="line">        <span class="comment">#视频编码</span></span><br><span class="line">        x264</span><br><span class="line">        <span class="comment">#语音编码</span></span><br><span class="line">        faac</span><br><span class="line">        <span class="comment">#本地库</span></span><br><span class="line">        android</span><br><span class="line">        <span class="variable">$&#123;log_lib&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h4 id="3-配置-faac-编码参数"><a href="#3-配置-faac-编码参数" class="headerlink" title="3. 配置 faac 编码参数"></a>3. 配置 faac 编码参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置语音软编码参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioEncoderChannel::setAudioEncoderInfo</span><span class="params">(<span class="keyword">int</span> samplesHZ, <span class="keyword">int</span> channel)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//如果已经初始化，需要释放</span></span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line">    <span class="comment">//通道 默认单声道</span></span><br><span class="line">    mChannels = channel;</span><br><span class="line">    <span class="comment">//打开编码器</span></span><br><span class="line">    <span class="comment">//3、一次最大能输入编码器的样本数量 也编码的数据的个数 (一个样本是16位 2字节)</span></span><br><span class="line">    <span class="comment">//4、最大可能的输出数据  编码后的最大字节数</span></span><br><span class="line">    mAudioCodec = faacEncOpen(samplesHZ, channel, &amp;mInputSamples, &amp;mMaxOutputBytes);</span><br><span class="line">    <span class="keyword">if</span> (!mAudioCodec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIPushCallback) &#123;</span><br><span class="line">            mIPushCallback-&gt;onError(THREAD_MAIN, FAAC_ENC_OPEN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置编码器参数</span></span><br><span class="line">    faacEncConfigurationPtr <span class="built_in">config</span> = faacEncGetCurrentConfiguration(mAudioCodec);</span><br><span class="line">    <span class="comment">//指定为 mpeg4 标准</span></span><br><span class="line">    <span class="built_in">config</span>-&gt;mpegVersion = MPEG4;</span><br><span class="line">    <span class="comment">//lc 标准</span></span><br><span class="line">    <span class="built_in">config</span>-&gt;aacObjectType = <span class="literal">LOW</span>;</span><br><span class="line">    <span class="comment">//16位</span></span><br><span class="line">    <span class="built_in">config</span>-&gt;inputFormat = FAAC_INPUT_16BIT;</span><br><span class="line">    <span class="comment">// 编码出原始数据 既不是adts也不是adif</span></span><br><span class="line">    <span class="built_in">config</span>-&gt;outputFormat = <span class="number">0</span>;</span><br><span class="line">    faacEncSetConfiguration(mAudioCodec, <span class="built_in">config</span>);</span><br><span class="line">    <span class="comment">//输出缓冲区 编码后的数据 用这个缓冲区来保存</span></span><br><span class="line">    mBuffer = <span class="keyword">new</span> u_char[mMaxOutputBytes];</span><br><span class="line">  	<span class="comment">//设置一个标志，用于开启编码</span></span><br><span class="line">    isStart = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-配置-AAC-包头"><a href="#4-配置-AAC-包头" class="headerlink" title="4. 配置 AAC 包头"></a>4. 配置 AAC 包头</h4><p>在发送 rtmp 音视频包的时候需要将语音包头第一个发送</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频头包数据</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">RTMPPacket *<span class="title">AudioEncoderChannel::getAudioTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAudioCodec) &#123;</span><br><span class="line">        setAudioEncoderInfo(FAAC_DEFAUTE_SAMPLE_RATE, FAAC_DEFAUTE_SAMPLE_CHANNEL);</span><br><span class="line">        <span class="keyword">if</span> (!mAudioCodec)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    u_char *buf;</span><br><span class="line">    u_long len;</span><br><span class="line">    faacEncGetDecoderSpecificInfo(mAudioCodec, &amp;buf, &amp;len);</span><br><span class="line">    <span class="keyword">int</span> bodySize = <span class="number">2</span> + len;</span><br><span class="line">    RTMPPacket *packet = <span class="keyword">new</span> RTMPPacket;</span><br><span class="line">    RTMPPacket_Alloc(packet, bodySize);</span><br><span class="line">    <span class="comment">//双声道</span></span><br><span class="line">    packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0xAF</span>;</span><br><span class="line">    <span class="keyword">if</span> (mChannels == <span class="number">1</span>) &#123; <span class="comment">//单身道</span></span><br><span class="line">        packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0xAE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    packet-&gt;m_body[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//将包头数据 copy 到RTMPPacket 中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[<span class="number">2</span>], buf, len);</span><br><span class="line">		<span class="comment">//是否使用绝对时间戳</span></span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = FALSE;</span><br><span class="line">  	<span class="comment">//包大小</span></span><br><span class="line">    packet-&gt;m_nBodySize = bodySize;</span><br><span class="line">  	<span class="comment">//包类型</span></span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO;</span><br><span class="line">  	<span class="comment">//语音通道</span></span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x11</span>;</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    <span class="keyword">return</span> packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-开始实时编码"><a href="#5-开始实时编码" class="headerlink" title="5. 开始实时编码"></a>5. 开始实时编码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioEncoderChannel::encodeData</span><span class="params">(<span class="keyword">int8_t</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAudioCodec || !isStart)<span class="comment">//不符合编码要求，退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//返回编码后的数据字节长度</span></span><br><span class="line">    <span class="keyword">int</span> bytelen = faacEncEncode(mAudioCodec, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int32_t</span> *&gt;(data), mInputSamples,mBuffer, mMaxOutputBytes);</span><br><span class="line">    <span class="keyword">if</span> (bytelen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//开始打包 rtmp</span></span><br><span class="line">        <span class="keyword">int</span> bodySize = <span class="number">2</span> + bytelen;</span><br><span class="line">        RTMPPacket *packet = <span class="keyword">new</span> RTMPPacket;</span><br><span class="line">        RTMPPacket_Alloc(packet, bodySize);</span><br><span class="line">        <span class="comment">//双声道</span></span><br><span class="line">        packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0xAF</span>;</span><br><span class="line">        <span class="keyword">if</span> (mChannels == <span class="number">1</span>) &#123;</span><br><span class="line">            packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0xAE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编码出的音频 都是 0x01</span></span><br><span class="line">        packet-&gt;m_body[<span class="number">1</span>] = <span class="number">0x01</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[<span class="number">2</span>], mBuffer, bytelen);</span><br><span class="line"></span><br><span class="line">        packet-&gt;m_hasAbsTimestamp = FALSE;</span><br><span class="line">        packet-&gt;m_nBodySize = bodySize;</span><br><span class="line">        packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO;</span><br><span class="line">        packet-&gt;m_nChannel = <span class="number">0x11</span>;</span><br><span class="line">        packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">        <span class="comment">//发送 rtmp packet，回调给 RTMP send 模块</span></span><br><span class="line">        mAudioCallback(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-释放编码器"><a href="#6-释放编码器" class="headerlink" title="6. 释放编码器"></a>6. 释放编码器</h4><p>在不需要编码或者退出编码的时候需要主动释放编码器，释放 native 内存，可以通过如下函数来实现释放编码器的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioEncoderChannel::release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//退出编码的标志</span></span><br><span class="line">    isStart = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//释放编码器</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioCodec) &#123;</span><br><span class="line">      	<span class="comment">//关闭编码器</span></span><br><span class="line">        faacEncClose(mAudioCodec);</span><br><span class="line">      	<span class="comment">//释放缓冲区</span></span><br><span class="line">      	DELETE(mBuffer);</span><br><span class="line">        mAudioCodec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬编"><a href="#硬编" class="headerlink" title="硬编"></a>硬编</h3><p>软编码介绍完了下面利用 Android SDK 自带的 MediaCodec 函数进行对 PCM 编码为 AAC 的格式音频数据。使用 MediaCodec 编码 AAC 对 Android 系统是有要求的，必须是 4.1系统以上，即要求 Android 的版本代号在 Build.VERSION_CODES.JELLY_BEAN (16) 以上。MediaCodec 是 Android 系统提供的硬件编码器，它可以利用设备的硬件来完成编码，从而大大提高编码的效率，还可以降低电量的使用，但是其在兼容性方面不如软编号，因为 Android 设备的锁片化太严重，所以读者可以自己衡量在应用中是否使用 Android 平台的硬件编码特性。</p>
<h4 id="1-创建-quot-audio-mp4a-latm-quot-类型的硬编码器"><a href="#1-创建-quot-audio-mp4a-latm-quot-类型的硬编码器" class="headerlink" title="1. 创建 &quot;audio/mp4a-latm&quot; 类型的硬编码器"></a>1. 创建 <code>&quot;audio/mp4a-latm&quot;</code> 类型的硬编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaCodec = MediaCodec.createEncoderByType(configuration.mime);</span><br></pre></td></tr></table></figure>

<h4 id="2-配置音频硬编码器"><a href="#2-配置音频硬编码器" class="headerlink" title="2.   配置音频硬编码器"></a>2.   配置音频硬编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MediaCodec <span class="title">getAudioMediaCodec</span><span class="params">(AudioConfiguration configuration)</span></span>&#123;</span><br><span class="line">    MediaFormat format = MediaFormat.createAudioFormat(configuration.mime, configuration.frequency, configuration.channelCount);</span><br><span class="line">    <span class="keyword">if</span>(configuration.mime.equals(AudioConfiguration.DEFAULT_MIME)) &#123;</span><br><span class="line">        format.setInteger(MediaFormat.KEY_AAC_PROFILE, configuration.aacProfile);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//语音码率</span></span><br><span class="line">    format.setInteger(MediaFormat.KEY_BIT_RATE, configuration.maxBps * <span class="number">1024</span>);</span><br><span class="line">  	<span class="comment">//语音采样率 44100</span></span><br><span class="line">    format.setInteger(MediaFormat.KEY_SAMPLE_RATE, configuration.frequency);</span><br><span class="line">    <span class="keyword">int</span> maxInputSize = AudioUtils.getRecordBufferSize(configuration);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, configuration.channelCount);</span><br><span class="line"></span><br><span class="line">    MediaCodec mediaCodec = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mediaCodec = MediaCodec.createEncoderByType(configuration.mime);</span><br><span class="line">      	<span class="comment">//MediaCodec.CONFIGURE_FLAG_ENCODE 代表编码器，解码传 0 即可</span></span><br><span class="line">        mediaCodec.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (mediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mediaCodec.stop();</span><br><span class="line">            mediaCodec.release();</span><br><span class="line">            mediaCodec = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mediaCodec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-开启音频硬编码器"><a href="#3-开启音频硬编码器" class="headerlink" title="3. 开启音频硬编码器"></a>3. 开启音频硬编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepareEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   mMediaCodec = AudioMediaCodec.getAudioMediaCodec(mAudioConfiguration);</span><br><span class="line">   mMediaCodec.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-拿到硬编码输入-PCM-输出-AAC-ByteBufferer"><a href="#4-拿到硬编码输入-PCM-输出-AAC-ByteBufferer" class="headerlink" title="4. 拿到硬编码输入(PCM)输出(AAC) ByteBufferer"></a>4. 拿到硬编码输入(PCM)输出(AAC) ByteBufferer</h4><p>到了这一步说明，音频编码器配置完成并且也成功开启了，现在就可以从 MediaCodec 实例中获取两个 buffer ，一个是输入 buffer 一个是输出 buffer , 输入 buffer 类似于 FFmpeg 中的 AVFrame 存放待编码的 PCM 数据，输出 buffer 类似于 FFmpeg 的 AVPacket 编码之后的 AAC 数据, 其代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放的是 PCM 数据</span></span><br><span class="line">ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers();</span><br><span class="line"><span class="comment">//存放的是编码之后的 AAC 数据</span></span><br><span class="line">ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers();</span><br></pre></td></tr></table></figure>

<h4 id="5-开始-PCM-硬编码为-AAC"><a href="#5-开始-PCM-硬编码为-AAC" class="headerlink" title="5. 开始 PCM 硬编码为 AAC"></a>5. 开始 PCM 硬编码为 AAC</h4><p>到此，所有初始化方法已实现完毕，下面来看一下 MediaCodec 的工作原理如下图所示，左边 Client 元素代表要将 PCM 放到 inputBuffer 中的某个具体的 buffer 中去，右边的 Client 元素代表将编码之后的原始 AAC 数据从 outputBuffer 中的某个具体 buffer 中取出来，👈 左边的小方块代表各个 inputBuffer 元素，右边的小方块则代表各个 outputBuffer 元素。详细介绍可以看 <a href="https://developer.android.com/reference/android/media/MediaCodec">MediaCodec 类介绍</a>。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302185720.png" alt=""></p>
<p>代表具体实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//input:PCM  </span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">offerEncoder</span><span class="params">(<span class="keyword">byte</span>[] input)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(mMediaCodec == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers();</span><br><span class="line">       ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers();</span><br><span class="line">       <span class="keyword">int</span> inputBufferIndex = mMediaCodec.dequeueInputBuffer(<span class="number">12000</span>);</span><br><span class="line">       <span class="keyword">if</span> (inputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           ByteBuffer inputBuffer = inputBuffers[inputBufferIndex];</span><br><span class="line">           inputBuffer.clear();</span><br><span class="line">           inputBuffer.put(input);</span><br><span class="line">           mMediaCodec.queueInputBuffer(inputBufferIndex, <span class="number">0</span>, input.length, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> outputBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">12000</span>);</span><br><span class="line">       <span class="keyword">while</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           ByteBuffer outputBuffer = outputBuffers[outputBufferIndex];</span><br><span class="line">           <span class="keyword">if</span>(mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">             	<span class="comment">//将 AAC 数据回调出去</span></span><br><span class="line">               mListener.onAudioEncode(outputBuffer, mBufferInfo);</span><br><span class="line">           &#125;</span><br><span class="line">         	<span class="comment">//释放当前内部编码内存</span></span><br><span class="line">           mMediaCodec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">           outputBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-AAC-打包为-flv"><a href="#6-AAC-打包为-flv" class="headerlink" title="6. AAC 打包为 flv"></a>6. AAC 打包为 flv</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioData</span><span class="params">(ByteBuffer bb, MediaCodec.BufferInfo bi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packetListener == <span class="keyword">null</span> || !isHeaderWrite || !isKeyFrameWrite) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bb.position(bi.offset);</span><br><span class="line">    bb.limit(bi.offset + bi.size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] audio = <span class="keyword">new</span> <span class="keyword">byte</span>[bi.size];</span><br><span class="line">    bb.get(audio);</span><br><span class="line">    <span class="keyword">int</span> size = AUDIO_HEADER_SIZE + audio.length;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(size);</span><br><span class="line">    FlvPackerHelper.writeAudioTag(buffer, audio, <span class="keyword">false</span>, mAudioSampleSize);</span><br><span class="line">    packetListener.onPacket(buffer.array(), AUDIO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAudioTag</span><span class="params">(ByteBuffer buffer, <span class="keyword">byte</span>[] audioInfo, <span class="keyword">boolean</span> isFirst, <span class="keyword">int</span> audioSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//写入音频头信息</span></span><br><span class="line">    writeAudioHeader(buffer, isFirst, audioSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入音频信息</span></span><br><span class="line">    buffer.put(audioInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-释放编码器"><a href="#7-释放编码器" class="headerlink" title="7. 释放编码器"></a>7. 释放编码器</h4><p>在使用完 MediaCodec 编码器之后，就需要停止运行并释放编码器，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMediaCodec.stop();</span><br><span class="line">        mMediaCodec.release();</span><br><span class="line">        mMediaCodec = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h2><p>Camera 采集完之后需要对 YUV 数据进行实时的编码 (软编利用 <a href="https://www.videolan.org/developers/x264.html">x264</a> 通过 NDK 交叉编译静态库、硬编使用 Android SDK MediaCodec 进行编码)。</p>
<h3 id="软编-1"><a href="#软编-1" class="headerlink" title="软编"></a>软编</h3><p>视频软编这里们用主流的编码库 x264 进行编码 H264 视频格式数据。 </p>
<h4 id="1-交叉编译-x264"><a href="#1-交叉编译-x264" class="headerlink" title="1. 交叉编译 x264"></a>1. 交叉编译 x264</h4><h5 id="1-1-下载-x264"><a href="#1-1-下载-x264" class="headerlink" title="1.1 下载 x264"></a>1.1 下载 x264</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式 一</span><br><span class="line">git clone https://code.videolan.org/videolan/x264.git</span><br><span class="line">//方式 二</span><br><span class="line">wget ftp://ftp.videolan.org/pub/x264/snapshots/last_x264.tar.bz2</span><br></pre></td></tr></table></figure>

<h5 id="1-2-编写编译脚本"><a href="#1-2-编写编译脚本" class="headerlink" title="1.2 编写编译脚本"></a>1.2 编写编译脚本</h5><p>在编写脚本之前需要在 configure 中添加一处代码 <code>-Werror=implicit-function-declaration</code>,如下所示:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200302192219.png" alt=""></p>
<p>交叉编译脚本如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#打包地址</span><br><span class="line">PREFIX=./android/armeabi-v7a</span><br><span class="line"></span><br><span class="line">#配置NDK 环境变量</span><br><span class="line">NDK_ROOT=$NDK_HOME</span><br><span class="line"></span><br><span class="line">#指定 CPU</span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">#指定 Android API</span><br><span class="line">ANDROID_API=<span class="number">17</span></span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-<span class="number">4.9</span>/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">FLAGS=<span class="string">"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS  -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC"</span></span><br><span class="line"></span><br><span class="line">#--disable-cli 不需要命令行工具</span><br><span class="line">#--enable-static 静态库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--disable-cli \</span><br><span class="line">--enable-<span class="keyword">static</span> \</span><br><span class="line">--enable-pic \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-<span class="number">17</span>/arch-arm \</span><br><span class="line">--extra-cflags=<span class="string">"$FLAGS"</span></span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="2-CMakeList-txt-配置"><a href="#2-CMakeList-txt-配置" class="headerlink" title="2. CMakeList.txt 配置"></a>2. CMakeList.txt 配置</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#视频编码器</span></span><br><span class="line"><span class="keyword">set</span>(x264 <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/x264)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载 x264 头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;x264&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定 x264 静态库文件目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;x264&#125;/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了</span></span><br><span class="line"><span class="keyword">file</span>(GLOB Player_CPP <span class="variable">$&#123;ykplayer&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB Push_CPP <span class="variable">$&#123;ykpusher&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment">#添加自己编写 cpp 源文件生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(ykpusher SHARED <span class="variable">$&#123;Push_CPP&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#找系统中 NDK log库</span></span><br><span class="line"><span class="keyword">find_library</span>(log_lib</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment">#推流 so</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        <span class="comment">#播放 so</span></span><br><span class="line">        ykpusher</span><br><span class="line"><span class="comment">#        # 写了此命令不用在乎添加 ffmpeg lib 顺序问题导致应用崩溃</span></span><br><span class="line"><span class="comment">#        -Wl,--start-group</span></span><br><span class="line"><span class="comment">#        avcodec avfilter avformat avutil swresample swscale</span></span><br><span class="line"><span class="comment">#        -Wl,--end-group</span></span><br><span class="line"><span class="comment">#        z</span></span><br><span class="line">        <span class="comment">#推流库</span></span><br><span class="line">        rtmp</span><br><span class="line">        <span class="comment">#视频编码</span></span><br><span class="line">        x264</span><br><span class="line">        <span class="comment">#语音编码</span></span><br><span class="line">        faac</span><br><span class="line">        <span class="comment">#本地库</span></span><br><span class="line">        android</span><br><span class="line">        <span class="variable">$&#123;log_lib&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h4 id="3-配置并打开-x264-编码器"><a href="#3-配置并打开-x264-编码器" class="headerlink" title="3. 配置并打开 x264 编码器"></a>3. 配置并打开 x264 编码器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::setVideoEncoderInfo</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> fps, <span class="keyword">int</span> <span class="built_in">bit</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mMutex);</span><br><span class="line">    <span class="keyword">this</span>-&gt;mWidth = <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mHeight = <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mFps = fps;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mBit = <span class="built_in">bit</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mY_Size = <span class="built_in">width</span> * <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mUV_Size = mY_Size / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果编码器已经存在，需要释放</span></span><br><span class="line">    <span class="keyword">if</span> (mVideoCodec || pic_in) &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开x264编码器</span></span><br><span class="line">    <span class="comment">//x264编码器的属性</span></span><br><span class="line">    <span class="keyword">x264_param_t</span> param;</span><br><span class="line">    <span class="comment">//2： 最快</span></span><br><span class="line">    <span class="comment">//3:  无延迟编码</span></span><br><span class="line">    x264_param_default_preset(&amp;param, x264_preset_names[<span class="number">0</span>], x264_tune_names[<span class="number">7</span>]);</span><br><span class="line">    <span class="comment">//base_line 3.2 编码规格</span></span><br><span class="line">    param.i_level_idc = <span class="number">32</span>;</span><br><span class="line">    <span class="comment">//输入数据格式</span></span><br><span class="line">    param.i_csp = X264_CSP_I420;</span><br><span class="line">    param.i_width = <span class="built_in">width</span>;</span><br><span class="line">    param.i_height = <span class="built_in">height</span>;</span><br><span class="line">    <span class="comment">//无b帧</span></span><br><span class="line">    param.i_bframe = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//参数i_rc_method表示码率控制，CQP(恒定质量)，CRF(恒定码率)，ABR(平均码率)</span></span><br><span class="line">    param.rc.i_rc_method = X264_RC_ABR;</span><br><span class="line">    <span class="comment">//码率(比特率,单位Kbps)</span></span><br><span class="line">    param.rc.i_bitrate = mBit;</span><br><span class="line">    <span class="comment">//瞬时最大码率</span></span><br><span class="line">    param.rc.i_vbv_max_bitrate = mBit * <span class="number">1.2</span>;</span><br><span class="line">    <span class="comment">//设置了i_vbv_max_bitrate必须设置此参数，码率控制区大小,单位kbps</span></span><br><span class="line">    param.rc.i_vbv_buffer_size = mBit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//帧率</span></span><br><span class="line">    param.i_fps_num = fps;</span><br><span class="line">    param.i_fps_den = <span class="number">1</span>;</span><br><span class="line">    param.i_timebase_den = param.i_fps_num;</span><br><span class="line">    param.i_timebase_num = param.i_fps_den;</span><br><span class="line"><span class="comment">//    param.pf_log = x264_log_default2;</span></span><br><span class="line">    <span class="comment">//用fps而不是时间戳来计算帧间距离</span></span><br><span class="line">    param.b_vfr_input = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//帧距离(关键帧)  2s一个关键帧</span></span><br><span class="line">    param.i_keyint_max = fps * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 是否复制sps和pps放在每个关键帧的前面 该参数设置是让每个关键帧(I帧)都附带sps/pps。</span></span><br><span class="line">    param.b_repeat_headers = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//多线程</span></span><br><span class="line">    param.i_threads = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    x264_param_apply_profile(&amp;param, <span class="string">"baseline"</span>);</span><br><span class="line">    <span class="comment">//打开编码器</span></span><br><span class="line">    mVideoCodec = x264_encoder_open(&amp;param);</span><br><span class="line">    pic_in = <span class="keyword">new</span> <span class="keyword">x264_picture_t</span>;</span><br><span class="line">    x264_picture_alloc(pic_in, X264_CSP_I420, <span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">    <span class="comment">//相当于重启编码器</span></span><br><span class="line">    isStart = <span class="literal">true</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-开始编码"><a href="#4-开始编码" class="headerlink" title="4. 开始编码"></a>4. 开始编码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::onEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isStart) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mVideoCodec) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int8_t</span> *data = <span class="number">0</span>;</span><br><span class="line">        mVideoPackets.pop(data);</span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            LOGE(<span class="string">"获取 YUV 数据错误"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//copy Y 数据</span></span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;pic_in-&gt;img.plane[<span class="number">0</span>], data, mY_Size);</span><br><span class="line">        <span class="comment">//拿到 UV 数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mUV_Size; ++i) &#123;</span><br><span class="line">            <span class="comment">//拿到 u 数据</span></span><br><span class="line">            *(pic_in-&gt;img.plane[<span class="number">1</span>] + i) = *(data + mY_Size + i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//拿到 v 数据</span></span><br><span class="line">            *(pic_in-&gt;img.plane[<span class="number">2</span>] + i) = *(data + mY_Size + i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编码出来的数据</span></span><br><span class="line">        <span class="keyword">x264_nal_t</span> *pp_nal;</span><br><span class="line">        <span class="comment">//编码出来的帧数量</span></span><br><span class="line">        <span class="keyword">int</span> pi_nal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">x264_picture_t</span> pic_out;</span><br><span class="line">        <span class="comment">//开始编码</span></span><br><span class="line">        <span class="keyword">int</span> ret = x264_encoder_encode(mVideoCodec, &amp;pp_nal, &amp;pi_nal, pic_in, &amp;pic_out);</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            LOGE(<span class="string">"编码失败"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是关键帧</span></span><br><span class="line">        <span class="keyword">int</span> sps_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pps_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span> sps[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">uint8_t</span> pps[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pi_nal; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pp_nal[i].i_type == NAL_SPS) &#123;</span><br><span class="line">                <span class="comment">//排除掉 h264的间隔 00 00 00 01</span></span><br><span class="line">                sps_len = pp_nal[i].i_payload - <span class="number">4</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(sps, pp_nal[i].p_payload + <span class="number">4</span>, sps_len);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp_nal[i].i_type == NAL_PPS) &#123;</span><br><span class="line">                pps_len = pp_nal[i].i_payload - <span class="number">4</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(pps, pp_nal[i].p_payload + <span class="number">4</span>, pps_len);</span><br><span class="line">                <span class="comment">//pps肯定是跟着sps的</span></span><br><span class="line">                sendSpsPps(sps, pps, sps_len, pps_len);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//编码之后的 H264 数据</span></span><br><span class="line">                sendFrame(pp_nal[i].i_type, pp_nal[i].p_payload, pp_nal[i].i_payload, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送 sps pps</span></span><br><span class="line"><span class="comment"> * @param sps  编码第一帧数据</span></span><br><span class="line"><span class="comment"> * @param pps  编码第二帧数据</span></span><br><span class="line"><span class="comment"> * @param sps_len  编码第一帧数据的长度</span></span><br><span class="line"><span class="comment"> * @param pps_len  编码第二帧数据的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::sendSpsPps</span><span class="params">(<span class="keyword">uint8_t</span> *sps, <span class="keyword">uint8_t</span> *pps, <span class="keyword">int</span> sps_len, <span class="keyword">int</span> pps_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bodySize = <span class="number">13</span> + sps_len + <span class="number">3</span> + pps_len;</span><br><span class="line">    RTMPPacket *packet = <span class="keyword">new</span> RTMPPacket;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    RTMPPacket_Alloc(packet, bodySize);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//固定头</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x17</span>;</span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//composition time 0x000000</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x00</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x00</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//版本</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">//编码规格</span></span><br><span class="line">    packet-&gt;m_body[i++] = sps[<span class="number">1</span>];</span><br><span class="line">    packet-&gt;m_body[i++] = sps[<span class="number">2</span>];</span><br><span class="line">    packet-&gt;m_body[i++] = sps[<span class="number">3</span>];</span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个sps</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0xE1</span>;</span><br><span class="line">    <span class="comment">//sps长度</span></span><br><span class="line">    packet-&gt;m_body[i++] = (sps_len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = sps_len &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[i], sps, sps_len);</span><br><span class="line">    i += sps_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pps</span></span><br><span class="line">    packet-&gt;m_body[i++] = <span class="number">0x01</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = (pps_len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[i++] = (pps_len) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[i], pps, pps_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视频</span></span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    packet-&gt;m_nBodySize = bodySize;</span><br><span class="line">    <span class="comment">//随意分配一个管道（尽量避开rtmp.c中使用的）</span></span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x10</span>;</span><br><span class="line">    <span class="comment">//sps pps没有时间戳</span></span><br><span class="line">    packet-&gt;m_nTimeStamp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//不使用绝对时间</span></span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = <span class="number">0</span>;</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_MEDIUM;</span><br><span class="line">    <span class="keyword">if</span> (mVideoCallback &amp;&amp; isStart)</span><br><span class="line">        mVideoCallback(packet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送视频帧 -- 关键帧</span></span><br><span class="line"><span class="comment"> * @param type</span></span><br><span class="line"><span class="comment"> * @param payload</span></span><br><span class="line"><span class="comment"> * @param i_playload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::sendFrame</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">uint8_t</span> *payload, <span class="keyword">int</span> i_payload, <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (payload[<span class="number">2</span>] == <span class="number">0x00</span>) &#123;</span><br><span class="line">        i_payload -= <span class="number">4</span>;</span><br><span class="line">        payload += <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i_payload -= <span class="number">3</span>;</span><br><span class="line">        payload += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看表</span></span><br><span class="line">    <span class="keyword">int</span> bodySize = <span class="number">9</span> + i_payload;</span><br><span class="line">    RTMPPacket *packet = <span class="keyword">new</span> RTMPPacket;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    RTMPPacket_Alloc(packet, bodySize);</span><br><span class="line"></span><br><span class="line">    packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0x27</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == NAL_SLICE_IDR) &#123;</span><br><span class="line">        packet-&gt;m_body[<span class="number">0</span>] = <span class="number">0x17</span>;</span><br><span class="line">        LOGE(<span class="string">"关键帧"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    packet-&gt;m_body[<span class="number">1</span>] = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">//时间戳</span></span><br><span class="line">    packet-&gt;m_body[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//数据长度 int 4个字节</span></span><br><span class="line">    packet-&gt;m_body[<span class="number">5</span>] = (i_payload &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">6</span>] = (i_payload &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">7</span>] = (i_payload &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    packet-&gt;m_body[<span class="number">8</span>] = (i_payload) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;packet-&gt;m_body[<span class="number">9</span>], payload, i_payload);</span><br><span class="line"></span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = <span class="number">0</span>;</span><br><span class="line">    packet-&gt;m_nBodySize = bodySize;</span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x10</span>;</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    <span class="keyword">if</span> (mVideoCallback &amp;&amp; isStart)</span><br><span class="line">        mVideoCallback(packet);<span class="comment">//回调给 RTMP 模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-释放编码器"><a href="#5-释放编码器" class="headerlink" title="5. 释放编码器"></a>5. 释放编码器</h4><p>当我们不需要编码的时候需要释放编码器，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x264_encoder_close(mVideoCodec);</span><br></pre></td></tr></table></figure>

<h3 id="硬编-1"><a href="#硬编-1" class="headerlink" title="硬编"></a>硬编</h3><p>在 Android 4.3 系统以后，用 MediaCodec 编码视频成为了主流的使用场景，尽管 Android 的碎片化很严重，会导致一些兼容性问题，但是硬件编码器的性能以及速度是非常可观的，并且在 4.3 系统之后可以通过 Surface 来配置编码器的输入，大大降低了显存到内存的交换过程所使用的时间，从而使得整个应用的体验得到大大提升。由于输入和输出已经确定，因此接下来将直接编写 MediaCodec 编码视频帧的过程。</p>
<h4 id="1-创建-“video-avc”-类型的硬编码器"><a href="#1-创建-“video-avc”-类型的硬编码器" class="headerlink" title="1. 创建 “video/avc” 类型的硬编码器"></a>1. 创建 “video/avc” 类型的硬编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaCodec = MediaCodec.createEncoderByType(videoConfiguration.mime);</span><br></pre></td></tr></table></figure>

<h4 id="2-配置视频编码器"><a href="#2-配置视频编码器" class="headerlink" title="2. 配置视频编码器"></a>2. 配置视频编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MediaCodec <span class="title">getVideoMediaCodec</span><span class="params">(VideoConfiguration videoConfiguration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> videoWidth = getVideoSize(videoConfiguration.width);</span><br><span class="line">    <span class="keyword">int</span> videoHeight = getVideoSize(videoConfiguration.height);</span><br><span class="line">    MediaFormat format = MediaFormat.createVideoFormat(videoConfiguration.mime, videoWidth, videoHeight);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_COLOR_FORMAT,</span><br><span class="line">            MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_BIT_RATE, videoConfiguration.maxBps* <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">int</span> fps = videoConfiguration.fps;</span><br><span class="line">    <span class="comment">//设置摄像头预览帧率</span></span><br><span class="line">    <span class="keyword">if</span>(BlackListHelper.deviceInFpsBlacklisted()) &#123;</span><br><span class="line">        SopCastLog.d(SopCastConstant.TAG, <span class="string">"Device in fps setting black list, so set mediacodec fps 15"</span>);</span><br><span class="line">        fps = <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    format.setInteger(MediaFormat.KEY_FRAME_RATE, fps);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, videoConfiguration.ifi);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_BITRATE_MODE, MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_VBR);</span><br><span class="line">    format.setInteger(MediaFormat.KEY_COMPLEXITY, MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_CBR);</span><br><span class="line">    MediaCodec mediaCodec = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mediaCodec = MediaCodec.createEncoderByType(videoConfiguration.mime);</span><br><span class="line">        mediaCodec.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (mediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mediaCodec.stop();</span><br><span class="line">            mediaCodec.release();</span><br><span class="line">            mediaCodec = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mediaCodec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-开启视频编码器"><a href="#3-开启视频编码器" class="headerlink" title="3. 开启视频编码器"></a>3. 开启视频编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mMediaCodec.start();</span><br></pre></td></tr></table></figure>

<h4 id="4-拿到编码之后的数据"><a href="#4-拿到编码之后的数据" class="headerlink" title="4. 拿到编码之后的数据"></a>4. 拿到编码之后的数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuffer[] outBuffers = mMediaCodec.getOutputBuffers();</span><br><span class="line">	<span class="keyword">while</span> (isStarted) &#123;</span><br><span class="line">		encodeLock.lock();</span><br><span class="line">		<span class="keyword">if</span>(mMediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> outBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">12000</span>);</span><br><span class="line">			<span class="keyword">if</span> (outBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				ByteBuffer bb = outBuffers[outBufferIndex];</span><br><span class="line">				<span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123; <span class="comment">//将编码好的 H264 数据回调出去</span></span><br><span class="line">					mListener.onVideoEncode(bb, mBufferInfo);</span><br><span class="line">				&#125;</span><br><span class="line">				mMediaCodec.releaseOutputBuffer(outBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// wait 10ms</span></span><br><span class="line">					Thread.sleep(<span class="number">10</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			encodeLock.unlock();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			encodeLock.unlock();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-H264-打包为-flv"><a href="#5-H264-打包为-flv" class="headerlink" title="5. H264 打包为 flv"></a>5. H264 打包为 flv</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//接收 H264 数据 </span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVideoData</span><span class="params">(ByteBuffer bb, MediaCodec.BufferInfo bi)</span> </span>&#123;</span><br><span class="line">       mAnnexbHelper.analyseVideoData(bb, bi);</span><br><span class="line">   &#125;   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将硬编得到的视频数据进行处理生成每一帧视频数据，然后传给flv打包器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bb 硬编后的数据buffer</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bi 硬编的BufferInfo</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyseVideoData</span><span class="params">(ByteBuffer bb, MediaCodec.BufferInfo bi)</span> </span>&#123;</span><br><span class="line">       bb.position(bi.offset);</span><br><span class="line">       bb.limit(bi.offset + bi.size);</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;<span class="keyword">byte</span>[]&gt; frames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">boolean</span> isKeyFrame = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(bb.position() &lt; bi.offset + bi.size) &#123;</span><br><span class="line">           <span class="keyword">byte</span>[] frame = annexbDemux(bb, bi);</span><br><span class="line">           <span class="keyword">if</span>(frame == <span class="keyword">null</span>) &#123;</span><br><span class="line">               LogUtils.e(<span class="string">"annexb not match."</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// ignore the nalu type aud(9)</span></span><br><span class="line">           <span class="keyword">if</span> (isAccessUnitDelimiter(frame)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// for pps</span></span><br><span class="line">           <span class="keyword">if</span>(isPps(frame)) &#123;</span><br><span class="line">               mPps = frame;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// for sps</span></span><br><span class="line">           <span class="keyword">if</span>(isSps(frame)) &#123;</span><br><span class="line">               mSps = frame;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// for IDR frame</span></span><br><span class="line">           <span class="keyword">if</span>(isKeyFrame(frame)) &#123;</span><br><span class="line">               isKeyFrame = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               isKeyFrame = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">byte</span>[] naluHeader = buildNaluHeader(frame.length);</span><br><span class="line">           frames.add(naluHeader);</span><br><span class="line">           frames.add(frame);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (mPps != <span class="keyword">null</span> &amp;&amp; mSps != <span class="keyword">null</span> &amp;&amp; mListener != <span class="keyword">null</span> &amp;&amp; mUploadPpsSps) &#123;</span><br><span class="line">           <span class="keyword">if</span>(mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mListener.onSpsPps(mSps, mPps);</span><br><span class="line">           &#125;</span><br><span class="line">           mUploadPpsSps = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(frames.size() == <span class="number">0</span> || mListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">byte</span>[] frame = frames.get(i);</span><br><span class="line">           size += frame.length;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">       <span class="keyword">int</span> currentSize = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">byte</span>[] frame = frames.get(i);</span><br><span class="line">           System.arraycopy(frame, <span class="number">0</span>, data, currentSize, frame.length);</span><br><span class="line">           currentSize += frame.length;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mListener.onVideo(data, isKeyFrame);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是从编码后的数据中解析得到NALU，然后判断NALU的类型，最后再把数据回调给 FlvPacker 去处理。</p>
<p>处理 spsPps:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpsPps</span><span class="params">(<span class="keyword">byte</span>[] sps, <span class="keyword">byte</span>[] pps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packetListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入第一个视频信息</span></span><br><span class="line">    writeFirstVideoTag(sps, pps);</span><br><span class="line">    <span class="comment">//写入第一个音频信息</span></span><br><span class="line">    writeFirstAudioTag();</span><br><span class="line">    isHeaderWrite = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理视频帧:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVideo</span><span class="params">(<span class="keyword">byte</span>[] video, <span class="keyword">boolean</span> isKeyFrame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packetListener == <span class="keyword">null</span> || !isHeaderWrite) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> packetType = INTER_FRAME;</span><br><span class="line">    <span class="keyword">if</span> (isKeyFrame) &#123;</span><br><span class="line">        isKeyFrameWrite = <span class="keyword">true</span>;</span><br><span class="line">        packetType = KEY_FRAME;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保第一帧是关键帧，避免一开始出现灰色模糊界面</span></span><br><span class="line">    <span class="keyword">if</span> (!isKeyFrameWrite) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = VIDEO_HEADER_SIZE + video.length;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(size);</span><br><span class="line">    FlvPackerHelper.writeH264Packet(buffer, video, isKeyFrame);</span><br><span class="line">    packetListener.onPacket(buffer.array(), packetType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-释放编码器-并释放-Surface"><a href="#6-释放编码器-并释放-Surface" class="headerlink" title="6. 释放编码器,并释放 Surface"></a>6. 释放编码器,并释放 Surface</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放编码器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mMediaCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mMediaCodec.signalEndOfInputStream();</span><br><span class="line">		mMediaCodec.stop();</span><br><span class="line">		mMediaCodec.release();</span><br><span class="line">		mMediaCodec = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mInputSurface != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mInputSurface.release();</span><br><span class="line">		mInputSurface = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放 OpenGL ES 渲染，Surface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface);</span><br><span class="line">	EGL14.eglDestroyContext(mEGLDisplay, mEGLContext);</span><br><span class="line">	EGL14.eglReleaseThread();</span><br><span class="line">	EGL14.eglTerminate(mEGLDisplay);</span><br><span class="line"></span><br><span class="line">	mSurface.release();</span><br><span class="line"></span><br><span class="line">	mSurface    = <span class="keyword">null</span>;</span><br><span class="line">	mEGLDisplay = <span class="keyword">null</span>;</span><br><span class="line">	mEGLContext = <span class="keyword">null</span>;</span><br><span class="line">	mEGLSurface = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rtmp-推流"><a href="#rtmp-推流" class="headerlink" title="rtmp 推流"></a>rtmp 推流</h2><p>注: 实际项目 rtmp 需要先连接上才有后续操作。</p>
<p>rtmp 模块我们已在开发 <a href="https://juejin.im/post/5e495ec1e51d452713551017">播放器</a> 的时候，将它和 ffmpeg 一并编译了。所以我们直接使用上次的静态库和头文件就可以了，如果对 rtmp 协议不了解的可以参考上一篇文章，里面也有介绍 <a href="https://juejin.im/post/5e4ec66c5188254967067502">搭建 RTMP 直播服务器</a>。</p>
<p>到这里软编码和硬编码数据都已准备好了现在，需要发送给 rtmp 模块，也就是在 native 中，先看 java 发送出口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打包之后的数据，和裸流数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == RtmpPacker.FIRST_AUDIO || type == RtmpPacker.AUDIO) &#123;<span class="comment">//音频 AAC 数据,已打包 </span></span><br><span class="line">        mPusherManager.pushAACData(data, data.length, type);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RtmpPacker.FIRST_VIDEO ||</span><br><span class="line">            type == RtmpPacker.INTER_FRAME || type == RtmpPacker.KEY_FRAME) &#123;<span class="comment">//H264 视频数据,已打包</span></span><br><span class="line">        mPusherManager.pushH264(data, type, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RtmpPacker.PCM) &#123; <span class="comment">//PCM 裸流数据</span></span><br><span class="line">        mPusherManager.pushPCM(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RtmpPacker.YUV) &#123; <span class="comment">//YUV 裸流数据</span></span><br><span class="line">        mPusherManager.pushYUV(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送 H264 数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h264</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">pushH264</span><span class="params">(<span class="keyword">byte</span>[] h264, <span class="keyword">int</span> type, <span class="keyword">long</span> timeStamp)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> audio     直接推编码完成之后的音频流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">pushAACData</span><span class="params">(<span class="keyword">byte</span>[] audio, <span class="keyword">int</span> length, <span class="keyword">int</span> timestamp)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送 PCM 原始数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> audioData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">native_pushAudio</span><span class="params">(<span class="keyword">byte</span>[] audioData)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * push 视频原始 nv21</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">native_push_video</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-Rtmp-链接"><a href="#1-Rtmp-链接" class="headerlink" title="1. Rtmp 链接"></a>1. Rtmp 链接</h3><p>Rtmp 底层是 TCP 协议，所以你可以使用 Java Socket 进行连接，也可以使用 c++ librtmp 库来进行连接，咱么这里就使用 librtmp 来进行连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正 rtmp 连接的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTMPModel::onConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 初始化</span></span><br><span class="line">    RTMP_Init(rtmp);</span><br><span class="line">    <span class="comment">//2. 设置rtmp地址</span></span><br><span class="line">    <span class="keyword">int</span> ret = RTMP_SetupURL(rtmp, <span class="keyword">this</span>-&gt;url)</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//3. 确认写入 rtmp</span></span><br><span class="line">    RTMP_EnableWrite(rtmp);</span><br><span class="line">		<span class="comment">//4. 开始链接</span></span><br><span class="line">    ret = RTMP_Connect(rtmp, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//5. 连接成功之后需要连接一个流</span></span><br><span class="line">    ret = RTMP_ConnectStream(rtmp, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Native-音频模块接收-AAC-Flv-打包数据"><a href="#2-Native-音频模块接收-AAC-Flv-打包数据" class="headerlink" title="2. Native 音频模块接收 AAC Flv 打包数据"></a>2. Native 音频模块接收 AAC Flv 打包数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接推送 AAC 硬编码</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioEncoderChannel::pushAAC</span><span class="params">(u_char *data, <span class="keyword">int</span> dataLen, <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    RTMPPacket *packet = (RTMPPacket *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(packet, dataLen);</span><br><span class="line">    RTMPPacket_Reset(packet);</span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x05</span>; <span class="comment">//音频</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet-&gt;m_body, data, dataLen);</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = FALSE;</span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO;</span><br><span class="line">    packet-&gt;m_nBodySize = dataLen;</span><br><span class="line">    <span class="keyword">if</span> (mAudioCallback)</span><br><span class="line">        mAudioCallback(packet); <span class="comment">//发送给 rtmp 模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Native-视频模块接收-H264-Flv-打包数据"><a href="#3-Native-视频模块接收-H264-Flv-打包数据" class="headerlink" title="3. Native 视频模块接收 H264 Flv 打包数据"></a>3. Native 视频模块接收 H264 Flv 打包数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param type  视频帧类型</span></span><br><span class="line"><span class="comment"> * @param buf  H264</span></span><br><span class="line"><span class="comment"> * @param len H264 长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoEncoderChannel::sendH264</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> dataLen, <span class="keyword">int</span> timeStamp)</span> </span>&#123;</span><br><span class="line">    RTMPPacket *packet = (RTMPPacket *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(packet, dataLen);</span><br><span class="line">    RTMPPacket_Reset(packet);</span><br><span class="line"></span><br><span class="line">    packet-&gt;m_nChannel = <span class="number">0x04</span>; <span class="comment">//视频</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == RTMP_PACKET_KEY_FRAME) &#123;</span><br><span class="line">        LOGE(<span class="string">"视频关键帧"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(packet-&gt;m_body, data, dataLen);</span><br><span class="line">    packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    packet-&gt;m_hasAbsTimestamp = FALSE;</span><br><span class="line">    packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    packet-&gt;m_nBodySize = dataLen;</span><br><span class="line">    mVideoCallback(packet);<span class="comment">//发送给 rtmp 模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-RTMP-发送数据"><a href="#4-RTMP-发送数据" class="headerlink" title="4. RTMP 发送数据"></a>4. RTMP 发送数据</h3><h4 id="4-1-将接收到的数据入发送队列"><a href="#4-1-将接收到的数据入发送队列" class="headerlink" title="4.1 将接收到的数据入发送队列"></a>4.1 将接收到的数据入发送队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不管是软编码还是硬编码所有发送数据都需要入队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(RTMPPacket *packet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rtmpModel) &#123;</span><br><span class="line">            <span class="comment">//设置时间戳</span></span><br><span class="line">            packet-&gt;m_nTimeStamp = RTMP_GetTime() - rtmpModel-&gt;mStartTime;</span><br><span class="line">            rtmpModel-&gt;mPackets.push(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-发送"><a href="#4-2-发送" class="headerlink" title="4.2 发送"></a>4.2 发送</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正推流的地方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTMPModel::onPush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RTMPPacket *packet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (isStart) &#123;</span><br><span class="line">      	<span class="comment">//从队列中获取发送的音视频数据</span></span><br><span class="line">        mPackets.pop(packet);</span><br><span class="line">        <span class="keyword">if</span> (!readyPushing) &#123;</span><br><span class="line">            releasePackets(packet);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!packet) &#123;</span><br><span class="line">            LOGE(<span class="string">"获取失败"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        packet-&gt;m_nInfoField2 = rtmp-&gt;m_stream_id;</span><br><span class="line">        <span class="keyword">int</span> ret = RTMP_SendPacket(rtmp, packet, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            LOGE(<span class="string">"发送失败"</span>)</span><br><span class="line">            <span class="keyword">if</span> (pushCallback) &#123;</span><br><span class="line">                pushCallback-&gt;onError(THREAD_CHILD, RTMP_PUSHER_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    releasePackets(packet);</span><br><span class="line">    <span class="built_in">release</span>();<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-关闭-RTMP"><a href="#5-关闭-RTMP" class="headerlink" title="5. 关闭 RTMP"></a>5. 关闭 RTMP</h3><p>当不需要发送音视频数据的时候需要关闭 rtmp 连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTMPModel::release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isStart = <span class="literal">false</span>;</span><br><span class="line">    readyPushing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (rtmp) &#123;</span><br><span class="line">        RTMP_DeleteStream(rtmp);</span><br><span class="line">        RTMP_Close(rtmp);</span><br><span class="line">        RTMP_Free(rtmp);</span><br><span class="line">        rtmp = <span class="number">0</span>;</span><br><span class="line">        LOGE(<span class="string">"释放 native 资源"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPackets.clearQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单谈谈软硬编解码"><a href="#简单谈谈软硬编解码" class="headerlink" title="简单谈谈软硬编解码"></a>简单谈谈软硬编解码</h2><h3 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h3><p><strong>软编码:</strong>  使用 CPU 进行编码。<br><strong>硬编码:</strong>  使用 GPU 进行编码。</p>
<h3 id="2-比较"><a href="#2-比较" class="headerlink" title="2. 比较"></a>2. 比较</h3><p><strong>软编码:</strong>  实现直接、简单，参数调整方便，升级容易，但 CPU 负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。<br><strong>硬编码:</strong>  性能高，低码率下通常质量低于软编码器，但部分产品在 GPU 硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><p><strong>软编码:</strong> 适用短时间操作，如录制短视频等。</p>
<p><strong>硬编码:</strong> 长时间编码或者对视频质量要求高(VOIP 实时通话)，可以推荐硬件编码 (前提是手机性能好)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里 Android 端软编推流，硬编推流都分别实现了。在项目上可以根据实际情况来选择到底是硬编还是软编。</p>
<p>硬编我是基于来疯开源项目进行二次开发:</p>
<p> <a href="https://github.com/yangkun19921001/NDK_AV_SAMPLE/tree/master/ykav_common">Android 推流项目地址</a></p>
<p> <a href="https://github.com/yangkun19921001/NDK_AV_SAMPLE/blob/master/ykav_sample/src/main/java/com/devyk/ykav_sample/PlayerActivity.java">Android 拉流项目地址</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/LaiFeng-Android/SopCastComponent">来疯直播项目</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:21:00.000Z" title="2020-06-04T10:21:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">1 小时 读完 (大约 7706 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B9%9D-FFmpeg-librtmp-%E5%AE%9E%E7%8E%B0%E6%8B%89%E6%B5%81%E6%92%AD%E6%94%BE%E5%99%A8/">音视频学习 (九) FFmpeg + librtmp 实现拉流播放器</a></h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在一个 APP 玩的花样是越来越多了几乎都离不开音频、视频、图片等数据显示，该篇就介绍其中的音视频播放，音视频播放可以用已经成熟开源的播放器，(推荐一个不错的播放器开源项目<a href="https://github.com/CarGuo/GSYVideoPlayer">GSYVideoPlayer</a>)。如果用已开源的播放器就没有太大的学习意义了，该篇文章会介绍从 0~1 开发一款 Android 播放器流程和实例代码编写。</p>
<p>开发一款播放器你首先要具备的知识有:</p>
<blockquote>
<ul>
<li>FFmpeg RTMP 混合交叉编译</li>
<li>C/C++ 基础</li>
<li>NDK、JNI</li>
<li>音视频解码、同步</li>
</ul>
</blockquote>
<p>学完之后我们的播放器大概效果如下:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200216155927.gif" alt=""></p>
<p>效果看起来有点卡，这跟实际网络环境有关，此播放器已具备 rtmp/http/URL/File 等协议播放。</p>
<h2 id="RTMP-与-FFmpeg-混合编译"><a href="#RTMP-与-FFmpeg-混合编译" class="headerlink" title="RTMP 与 FFmpeg 混合编译"></a>RTMP 与 FFmpeg 混合编译</h2><h3 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h3><p><strong>介绍:</strong></p>
<p>RTMP 是 Real Time Messaging Protocol（实时消息传输<a href="https://baike.baidu.com/item/协议/13020269">协议</a>）的首字母缩写。该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash/AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media Server/red5 等。RTMP 与 HTTP 一样，都属于 TCP/IP 四层模型的应用层。</p>
<p><strong>下载:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;yixia&#x2F;librtmp.git</span><br></pre></td></tr></table></figure>

<p><strong>脚本编写:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置NDK 环境变量</span></span><br><span class="line">NDK_ROOT=$NDK_HOME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定 CPU</span></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定 Android API</span></span><br><span class="line">ANDROID_API=17</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">export XCFLAGS="-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API"</span><br><span class="line">export XLDFLAGS="--sysroot=$&#123;NDK_ROOT&#125;/platforms/android-17/arch-arm "</span><br><span class="line">export CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-</span><br><span class="line"></span><br><span class="line">make install SYS=android prefix=`pwd`/result CRYPTO= SHARED=  XDEF=-DNO_SSL</span><br></pre></td></tr></table></figure>

<p>如果出现如下效果就证明编译成功了:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200116225959.gif" alt=""></p>
<h3 id="混合编译"><a href="#混合编译" class="headerlink" title="混合编译"></a>混合编译</h3><p>上一篇文章咱们编译了 FFmpeg 静态库，那么该小节咱们要把 librtmp 集成到 FFmpeg 中编译，首先我们需要到 <strong>configure</strong> 脚本中把  librtmp 模块注释掉，如下:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200116231025.png" alt=""></p>
<p><strong>修改 FFmpeg 编译脚本:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">NDK_ROOT 变量指向ndk目录</span></span><br><span class="line">NDK_ROOT=$NDK_HOME</span><br><span class="line"><span class="meta">#</span><span class="bash">TOOLCHAIN 变量指向ndk中的交叉编译gcc所在的目录</span></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定android api版本</span></span><br><span class="line">ANDROID_API=17</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">此变量用于编译完成之后的库与头文件存放在哪个目录</span></span><br><span class="line">PREFIX=./android/armeabi-v7a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">rtmp路径</span></span><br><span class="line">RTMP=/root/android/librtmp/result</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">执行configure脚本，用于生成makefile</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--prefix : 安装目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--<span class="built_in">enable</span>-small : 优化大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--<span class="built_in">disable</span>-programs : 不编译ffmpeg程序(命令行工具)，我们是需要获得静态(动态)库。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--<span class="built_in">disable</span>-avdevice : 关闭avdevice模块，此模块在android中无用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--<span class="built_in">disable</span>-encoders : 关闭所有编码器 (播放不需要编码)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--<span class="built_in">disable</span>-muxers :  关闭所有复用器(封装器)，不需要生成mp4这样的文件，所以关闭</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--<span class="built_in">disable</span>-filters :关闭视频滤镜</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--<span class="built_in">enable</span>-cross-compile : 开启交叉编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--cross-prefix: gcc的前缀 xxx/xxx/xxx-gcc 则给xxx/xxx/xxx-</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">disable</span>-shared <span class="built_in">enable</span>-static 不写也可以，默认就是这样的。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--sysroot: </span></span><br><span class="line"><span class="meta">#</span><span class="bash">--extra-cflags: 会传给gcc的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--arch --target-os : 必须要给</span></span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-librtmp \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-arm \</span><br><span class="line">--extra-cflags="-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS  -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC -I$RTMP/include" \</span><br><span class="line">--extra-ldflags="-L$RTMP/lib" \</span><br><span class="line">--extra-libs="-lrtmp" \</span><br><span class="line">--arch=arm \</span><br><span class="line">--target-os=android</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">上面运行脚本生成makefile之后，使用make执行脚本</span></span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>如果出现如下，证明开始编译了:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200116232052.png" alt=""></p>
<p>如果出现如下，证明编译成功了:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200116232956.png" alt=""></p>
<p>可以从上图中看到静态库和头文件库都已经编译成功了，下面我们就进入编写代码环节了。</p>
<h2 id="播放器开发"><a href="#播放器开发" class="headerlink" title="播放器开发"></a>播放器开发</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>想要实现一个网络/本地播放器，我们必须知道它的流程，如下图所示:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200120143323.png" alt=""></p>
<h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><ol>
<li><p>创建一个新的 Android 项目并导入各自库</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200118232929.png" alt=""></p>
</li>
<li><p>CmakeLists.txt 编译脚本编写</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 ffmpeg、rtmp 、yk_player 目录</span></span><br><span class="line"><span class="keyword">set</span>(FFMPEG <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/ffmpeg)</span><br><span class="line"><span class="keyword">set</span>(RTMP <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/librtmp)</span><br><span class="line"><span class="keyword">set</span>(YK_PLAYER <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/player)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定 ffmpeg 头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;FFMPEG&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定 ffmpeg 静态库文件目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;FFMPEG&#125;/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定 rtmp 静态库文件目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;RTMP&#125;/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了</span></span><br><span class="line"><span class="keyword">file</span>(GLOB ALL_CPP <span class="variable">$&#123;YK_PLAYER&#125;</span>/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加自己编写 cpp 源文件生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(YK_PLAYER SHARED <span class="variable">$&#123;ALL_CPP&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#找系统中 NDK log库</span></span><br><span class="line"><span class="keyword">find_library</span>(log_lib</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后才开始链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        YK_PLAYER</span><br><span class="line">        <span class="comment"># 写了此命令不用在乎添加 ffmpeg lib 顺序问题导致应用崩溃</span></span><br><span class="line">        -Wl,--start-group</span><br><span class="line">        avcodec avfilter avformat avutil swresample swscale</span><br><span class="line">        -Wl,--end-group</span><br><span class="line">        z</span><br><span class="line">        rtmp</span><br><span class="line">        android</span><br><span class="line">        <span class="comment">#音频播放</span></span><br><span class="line">        OpenSLES</span><br><span class="line">        <span class="variable">$&#123;log_lib&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 native 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前 ffmpeg 版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getFFmpegVersion</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置 surface</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> surface</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setSurfaceNative</span><span class="params">(Surface surface)</span></span>;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 做一些准备工作</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> mDataSource 播放气质</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">prepareNative</span><span class="params">(String mDataSource)</span></span>;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 准备工作完成，开始播放</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">startNative</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 如果点击停止播放，那么就调用该函数进行恢复播放</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">restartNative</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 停止播放</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">stopNative</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 释放资源</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">releaseNative</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否正在播放</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isPlayerNative</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="解封装"><a href="#解封装" class="headerlink" title="解封装"></a>解封装</h3><p>根据之前我们的流程图得知在调用设置数据源了之后，ffmpeg 就开始解封装 (可以理解为收到快递包裹，我们需要把包裹打开看看里面是什么，然后拿出来进行归类放置)，这里就是把一个数据源分解成经过编码的音频数据、视频数据、字幕等，下面通过 FFmpeg API 来进行分解数据，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数是真正的解封装，是在子线程开启并调用的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">YKPlayer::prepare_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGD(<span class="string">"第一步 打开流媒体地址"</span>);</span><br><span class="line">    <span class="comment">//1. 打开流媒体地址(文件路径、直播地址)</span></span><br><span class="line">    <span class="comment">// 可以初始为NULL，如果初始为NULL，当执行avformat_open_input函数时，内部会自动申请avformat_alloc_context，这里干脆手动申请</span></span><br><span class="line">    <span class="comment">// 封装了媒体流的格式信息</span></span><br><span class="line">    formatContext = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字典: 键值对</span></span><br><span class="line">    AVDictionary *dictionary = <span class="number">0</span>;</span><br><span class="line">    av_dict_set(&amp;dictionary, <span class="string">"timeout"</span>, <span class="string">"5000000"</span>, <span class="number">0</span>);<span class="comment">//单位是微妙</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param AVFormatContext: 传入一个 format 上下文是一个二级指针</span></span><br><span class="line"><span class="comment">     * @param const char *url: 播放源</span></span><br><span class="line"><span class="comment">     * @param ff_const59 AVInputFormat *fmt: 输入的封住格式，一般让 ffmpeg 自己去检测，所以给了一个 0</span></span><br><span class="line"><span class="comment">     * @param AVDictionary **options: 字典参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> result = avformat_open_input(&amp;formatContext, data_source, <span class="number">0</span>, &amp;dictionary);</span><br><span class="line">    <span class="comment">//result -13--&gt; 没有读写权限</span></span><br><span class="line">    <span class="comment">//result -99--&gt; 第三个参数写 NULl</span></span><br><span class="line">    LOGD(<span class="string">"avformat_open_input--&gt;    %d，%s"</span>, result, data_source);</span><br><span class="line">    <span class="comment">//释放字典</span></span><br><span class="line">    av_dict_free(&amp;dictionary);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;<span class="comment">//0 on success true</span></span><br><span class="line">        <span class="comment">// 你的文件路径，或，你的文件损坏了，需要告诉用户</span></span><br><span class="line">        <span class="comment">// 把错误信息，告诉给Java层去（回调给Java）</span></span><br><span class="line">        <span class="keyword">if</span> (pCallback) &#123;</span><br><span class="line">            pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_CAN_NOT_OPEN_URL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步 查找媒体中的音视频流的信息</span></span><br><span class="line">    LOGD(<span class="string">"第二步 查找媒体中的音视频流的信息"</span>);</span><br><span class="line">    result = avformat_find_stream_info(formatContext, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pCallback) &#123;</span><br><span class="line">            pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_CAN_NOT_FIND_STREAMS);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三步 根据流信息，流的个数，循环查找，音频流 视频流</span></span><br><span class="line">    LOGD(<span class="string">"第三步 根据流信息，流的个数，循环查找，音频流 视频流"</span>);</span><br><span class="line">    <span class="comment">//nb_streams = 流的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stream_index = <span class="number">0</span>; stream_index &lt; formatContext-&gt;nb_streams; ++stream_index) &#123;</span><br><span class="line">        <span class="comment">//第四步 获取媒体流 音视频</span></span><br><span class="line">        LOGD(<span class="string">"第四步 获取媒体流 音视频"</span>);</span><br><span class="line">        AVStream *stream = formatContext-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第五步 从 stream 流中获取解码这段流的参数信息，区分到底是 音频还是视频</span></span><br><span class="line">        LOGD(<span class="string">"第五步 从 stream 流中获取解码这段流的参数信息，区分到底是 音频还是视频"</span>);</span><br><span class="line">        AVCodecParameters *codecParameters = stream-&gt;codecpar;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第六步 通过流的编解码参数中的编解码 ID ,来获取当前流的解码器</span></span><br><span class="line">        LOGD(<span class="string">"第六步 通过流的编解码参数中的编解码 ID ,来获取当前流的解码器"</span>);</span><br><span class="line">        AVCodec *codec = avcodec_find_decoder(codecParameters-&gt;codec_id);</span><br><span class="line">        <span class="comment">//有可能不支持当前解码</span></span><br><span class="line">        <span class="comment">//找不到解码器，重新编译 ffmpeg --enable-librtmp</span></span><br><span class="line">        <span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">            pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_FIND_DECODER_FAIL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第七步 通过拿到的解码器，获取解码器上下文</span></span><br><span class="line">        LOGD(<span class="string">"第七步 通过拿到的解码器，获取解码器上下文"</span>);</span><br><span class="line">        AVCodecContext *codecContext = avcodec_alloc_context3(codec);</span><br><span class="line">        <span class="keyword">if</span> (!codecContext) &#123;</span><br><span class="line">            pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_ALLOC_CODEC_CONTEXT_FAIL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第八步 给解码器上下文 设置参数</span></span><br><span class="line">        LOGD(<span class="string">"第八步 给解码器上下文 设置参数"</span>);</span><br><span class="line">        result = avcodec_parameters_to_context(codecContext, codecParameters);</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_CODEC_CONTEXT_PARAMETERS_FAIL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第九步 打开解码器</span></span><br><span class="line">        LOGD(<span class="string">"第九步 打开解码器"</span>);</span><br><span class="line">        result = avcodec_open2(codecContext, codec, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_OPEN_DECODER_FAIL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//媒体流里面可以拿到时间基</span></span><br><span class="line">        AVRational baseTime = stream-&gt;time_base;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第十步 从编码器参数中获取流类型 codec_type</span></span><br><span class="line">        LOGD(<span class="string">"第十步 从编码器参数中获取流类型 codec_type"</span>);</span><br><span class="line">        <span class="keyword">if</span> (codecParameters-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            audioChannel = <span class="keyword">new</span> AudioChannel(stream_index, codecContext,baseTime);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (codecParameters-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            <span class="comment">//获取视频帧 fps</span></span><br><span class="line">            <span class="comment">//平均帧率 == 时间基</span></span><br><span class="line">            AVRational frame_rate = stream-&gt;avg_frame_rate;</span><br><span class="line">            <span class="keyword">int</span> fps_value = av_q2d(frame_rate);</span><br><span class="line">            videoChannel = <span class="keyword">new</span> VideoChannel(stream_index, codecContext, baseTime, fps_value);</span><br><span class="line">            videoChannel-&gt;setRenderCallback(renderCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//end for</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第十一步 如果流中没有音视频数据</span></span><br><span class="line">    LOGD(<span class="string">"第十一步 如果流中没有音视频数据"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!audioChannel &amp;&amp; !videoChannel) &#123;</span><br><span class="line">        pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_NOMEDIA);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第十二步 要么有音频 要么有视频 要么音视频都有</span></span><br><span class="line">    LOGD(<span class="string">"第十二步 要么有音频 要么有视频 要么音视频都有"</span>);</span><br><span class="line">    <span class="comment">// 准备完毕，通知Android上层开始播放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pCallback) &#123;</span><br><span class="line">        pCallback-&gt;onPrepared(THREAD_CHILD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的注释我标注的很全面，这里我们直接跳到第十步，我们知道可以通过如下 <code>codecParameters-&gt;codec_type</code> 函数来进行判断数据属于什么类型，进行进行单独操作。</p>
<h3 id="获取待解码数据-如-H264、AAC"><a href="#获取待解码数据-如-H264、AAC" class="headerlink" title="获取待解码数据(如:H264、AAC)"></a>获取待解码数据(如:H264、AAC)</h3><p>在解封装完成之后我们把待解码的数据放入队列中，如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读包 、未解码、音频/视频 包 放入队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">YKPlayer::start_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环 读音视频包</span></span><br><span class="line">    <span class="keyword">while</span> (isPlaying) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">            av_usleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGD(<span class="string">"start_"</span>);</span><br><span class="line">        <span class="comment">//内存泄漏点 1，解决方法 : 控制队列大小</span></span><br><span class="line">        <span class="keyword">if</span> (videoChannel &amp;&amp; videoChannel-&gt;videoPackages.queueSize() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">//休眠 等待队列中的数据被消费</span></span><br><span class="line">            av_usleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内存泄漏点 2 ，解决方案 控制队列大小</span></span><br><span class="line">        <span class="keyword">if</span> (audioChannel &amp;&amp; audioChannel-&gt;audioPackages.queueSize() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">//休眠 等待队列中的数据被消费</span></span><br><span class="line">            av_usleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//AVPacket 可能是音频 可能是视频，没有解码的数据包</span></span><br><span class="line">        AVPacket *packet = av_packet_alloc();</span><br><span class="line">        <span class="comment">//这一行执行完毕， packet 就有音视频数据了</span></span><br><span class="line">        <span class="keyword">int</span> ret = av_read_frame(formatContext, packet);</span><br><span class="line">        <span class="comment">/*       if (ret != 0) &#123;</span></span><br><span class="line"><span class="comment">                   return;</span></span><br><span class="line"><span class="comment">               &#125;*/</span></span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="keyword">if</span> (videoChannel &amp;&amp; videoChannel-&gt;stream_index == packet-&gt;stream_index) &#123;<span class="comment">//视频包</span></span><br><span class="line">                <span class="comment">//未解码的 视频数据包 加入队列</span></span><br><span class="line">                videoChannel-&gt;videoPackages.push(packet);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioChannel &amp;&amp; audioChannel-&gt;stream_index == packet-&gt;stream_index) &#123;<span class="comment">//语音包</span></span><br><span class="line">                <span class="comment">//将语音包加入到队列中，以供解码使用</span></span><br><span class="line">                audioChannel-&gt;audioPackages.push(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == AVERROR_EOF) &#123; <span class="comment">//代表读取完毕了</span></span><br><span class="line">            <span class="comment">//TODO----</span></span><br><span class="line">            LOGD(<span class="string">"拆包完成 %s"</span>, <span class="string">"读取完成了"</span>)</span><br><span class="line">            isPlaying = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">stop</span>();</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGD(<span class="string">"拆包 %s"</span>, <span class="string">"读取失败"</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//读取失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">    <span class="comment">//最后释放的工作</span></span><br><span class="line">    isPlaying = <span class="number">0</span>;</span><br><span class="line">    isStop = <span class="literal">false</span>;</span><br><span class="line">    videoChannel-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    audioChannel-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面源码我们知道，通过 FFmpeg API <code>av_packet_alloc();</code> 拿到待解码的指针类型 <code>AVPacket</code>  然后放入对应的音视频队列中，等待解码。</p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><p>上一步我们知道，解封装完成之后把对应的数据放入了待解码的队列中，下一步我们就从队列中拿到数据进行解码，如下图所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoChannel::video_decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVPacket *packet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (isPlaying) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">            <span class="comment">//线程休眠 10s</span></span><br><span class="line">            av_usleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//控制队列大小，避免生产快，消费满的情况</span></span><br><span class="line">        <span class="keyword">if</span> (isPlaying &amp;&amp; videoFrames.queueSize() &gt; <span class="number">100</span>) &#123;</span><br><span class="line"><span class="comment">//            LOGE("视频队列中的 size :%d", videoFrames.queueSize());</span></span><br><span class="line">            <span class="comment">//线程休眠等待队列中的数据被消费</span></span><br><span class="line">            av_usleep(<span class="number">10</span> * <span class="number">1000</span>);<span class="comment">//10s</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = videoPackages.pop(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果停止播放，跳出循环，出了循环，就要释放</span></span><br><span class="line">        <span class="keyword">if</span> (!isPlaying) &#123;</span><br><span class="line">            LOGD(<span class="string">"isPlaying %d"</span>, isPlaying);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始取待解码的视频数据包</span></span><br><span class="line">        ret = avcodec_send_packet(pContext, packet);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            LOGD(<span class="string">"ret %d"</span>, ret);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//失败了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放 packet</span></span><br><span class="line">        releaseAVPacket(&amp;packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//AVFrame 拿到解码后的原始数据包</span></span><br><span class="line">        AVFrame *frame = av_frame_alloc();</span><br><span class="line">        ret = avcodec_receive_frame(pContext, frame);</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR(EAGAIN)) &#123;</span><br><span class="line">            <span class="comment">//从新取</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            LOGD(<span class="string">"ret %d"</span>, ret);</span><br><span class="line">            releaseAVFrame(&amp;frame);<span class="comment">//内存释放</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解码后的视频数据 YUV,加入队列中</span></span><br><span class="line">        videoFrames.push(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出循环，释放</span></span><br><span class="line">    <span class="keyword">if</span> (packet)</span><br><span class="line">        releaseAVPacket(&amp;packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码我们得到，主要把待解码的数据放入 <code>avcodec_send_packet</code> 中，然后通过 <code>avcodec_receive_frame</code> 函数来进行接收，最后解码完成的 YUV 数据又放入原始数据队列中，进行转换格式</p>
<h4 id="YUV-转-RGBA"><a href="#YUV-转-RGBA" class="headerlink" title="YUV 转 RGBA"></a>YUV 转 RGBA</h4><p>在 Android 中并不能直接播放 YUV, 我们需要把它转换成 RGB 的格式然后在调用本地 nativeWindow 或者 OpenGL ES 来进行渲染，下面就直接调用 FFmpeg  API 来进行转换，代码如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoChannel::video_player</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 原始视频数据 YUV ---&gt; rgba</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat,</span></span><br><span class="line"><span class="comment">                                  int dstW, int dstH, enum AVPixelFormat dstFormat,</span></span><br><span class="line"><span class="comment">                                  int flags, SwsFilter *srcFilter,</span></span><br><span class="line"><span class="comment">                                  SwsFilter *dstFilter, const double *param)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SwsContext *swsContext = sws_getContext(pContext-&gt;<span class="built_in">width</span>, pContext-&gt;<span class="built_in">height</span>,</span><br><span class="line">                                            pContext-&gt;pix_fmt,</span><br><span class="line">                                            pContext-&gt;<span class="built_in">width</span>, pContext-&gt;<span class="built_in">height</span>, AV_PIX_FMT_RGBA,</span><br><span class="line">                                            SWS_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//2. 给 dst_data 申请内存</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *dst_data[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> dst_linesize[<span class="number">4</span>];</span><br><span class="line">    AVFrame *frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pointers[4]：保存图像通道的地址。如果是RGB，则前三个指针分别指向R,G,B的内存地址。第四个指针保留不用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *   linesizes[4]：保存图像每个通道的内存对齐的步长，即一行的对齐内存的宽度，此值大小等于图像宽度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *   w: 要申请内存的图像宽度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *   h:  要申请内存的图像高度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *   pix_fmt: 要申请内存的图像的像素格式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *   align: 用于内存对齐的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *   返回值：所申请的内存空间的总大小。如果是负值，表示申请失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ret = av_image_alloc(dst_data, dst_linesize, pContext-&gt;<span class="built_in">width</span>, pContext-&gt;<span class="built_in">height</span>,</span><br><span class="line">                             AV_PIX_FMT_RGBA, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not allocate source image\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. YUV -&gt; rgba 格式转换 一帧一帧的转换</span></span><br><span class="line">    <span class="keyword">while</span> (isPlaying) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">            <span class="comment">//线程休眠 10s</span></span><br><span class="line">            av_usleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = videoFrames.pop(frame);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果停止播放，跳出循环，需要释放</span></span><br><span class="line">        <span class="keyword">if</span> (!isPlaying) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//真正转换的函数,dst_data 是 rgba 格式的数据</span></span><br><span class="line">        sws_scale(swsContext, frame-&gt;data, frame-&gt;linesize, <span class="number">0</span>, pContext-&gt;<span class="built_in">height</span>, dst_data,</span><br><span class="line">                  dst_linesize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始渲染，显示屏幕上</span></span><br><span class="line">        <span class="comment">//渲染一帧图像(宽、高、数据)</span></span><br><span class="line">        renderCallback(dst_data[<span class="number">0</span>], pContext-&gt;<span class="built_in">width</span>, pContext-&gt;<span class="built_in">height</span>, dst_linesize[<span class="number">0</span>]);</span><br><span class="line">        releaseAVFrame(&amp;frame);<span class="comment">//渲染完了，frame 释放。</span></span><br><span class="line">    &#125;</span><br><span class="line">    releaseAVFrame(&amp;frame);<span class="comment">//渲染完了，frame 释放。</span></span><br><span class="line">    <span class="comment">//停止播放 flag</span></span><br><span class="line">    isPlaying = <span class="number">0</span>;</span><br><span class="line">    av_freep(&amp;dst_data[<span class="number">0</span>]);</span><br><span class="line">    sws_freeContext(swsContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就是直接通过 <code>sws_scale</code> 该函数来进行 YUV -&gt; RGBA 转换。</p>
<h4 id="渲染-RGBA"><a href="#渲染-RGBA" class="headerlink" title="渲染 RGBA"></a>渲染 RGBA</h4><p>转换完之后，我们直接调用 ANativeWindow 来进行渲染，代码如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置播放 surface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_devyk_player_1common_PlayerManager_setSurfaceNative(JNIEnv *env, jclass type,</span><br><span class="line">                                                             jobject surface) &#123;</span><br><span class="line">    LOGD(<span class="string">"Java_com_devyk_player_1common_PlayerManager_setSurfaceNative"</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (nativeWindow) &#123;</span><br><span class="line">        ANativeWindow_release(nativeWindow);</span><br><span class="line">        nativeWindow = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新的窗口用于视频显示窗口</span></span><br><span class="line">    nativeWindow = ANativeWindow_fromSurface(env, surface);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 专门渲染的函数</span></span><br><span class="line"><span class="comment"> * @param src_data  解码后的视频 rgba 数据</span></span><br><span class="line"><span class="comment"> * @param width  视频宽</span></span><br><span class="line"><span class="comment"> * @param height 视频高</span></span><br><span class="line"><span class="comment"> * @param src_size 行数 size 相关信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderFrame</span><span class="params">(<span class="keyword">uint8_t</span> *src_data, <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> src_size)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nativeWindow) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口属性</span></span><br><span class="line">    ANativeWindow_setBuffersGeometry(nativeWindow, <span class="built_in">width</span>, <span class="built_in">height</span>, WINDOW_FORMAT_RGBA_8888);</span><br><span class="line"></span><br><span class="line">    ANativeWindow_Buffer window_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ANativeWindow_lock(nativeWindow, &amp;window_buffer, <span class="number">0</span>)) &#123;</span><br><span class="line">        ANativeWindow_release(nativeWindow);</span><br><span class="line">        nativeWindow = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填数据到 buffer,其实就是修改数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *dst_data = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span> *&gt;(window_buffer.bits);</span><br><span class="line">    <span class="keyword">int</span> lineSize = window_buffer.stride * <span class="number">4</span>;<span class="comment">//RGBA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就是逐行 copy 了。</span></span><br><span class="line">    <span class="comment">//一行 copy</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; window_buffer.<span class="built_in">height</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dst_data + i * lineSize, src_data + i * src_size, lineSize);</span><br><span class="line">    &#125;</span><br><span class="line">    ANativeWindow_unlockAndPost(nativeWindow);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视频渲染就完成了。</p>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><h4 id="解码-1"><a href="#解码-1" class="headerlink" title="解码"></a>解码</h4><p>音频的流程跟视频一样，拿到解封装之后的 AAC 数据开始进行解码，代码如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioChannel::audio_decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//待解码的 packet</span></span><br><span class="line">    AVPacket *avPacket = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//只要正在播放，就循环取数据</span></span><br><span class="line">    <span class="keyword">while</span> (isPlaying) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">            <span class="comment">//线程休眠 10s</span></span><br><span class="line">            av_usleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里有一个 bug，如果生产快，消费慢，就会造成队列数据过多容易造成 OOM,</span></span><br><span class="line">        <span class="comment">//解决办法：控制队列大小</span></span><br><span class="line">        <span class="keyword">if</span> (isPlaying &amp;&amp; audioFrames.queueSize() &gt; <span class="number">100</span>) &#123;</span><br><span class="line"><span class="comment">//            LOGE("音频队列中的 size :%d", audioFrames.queueSize());</span></span><br><span class="line">            <span class="comment">//线程休眠 10s</span></span><br><span class="line">            av_usleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以正常取出</span></span><br><span class="line">        <span class="keyword">int</span> ret = audioPackages.pop(avPacket);</span><br><span class="line">        <span class="comment">//条件判断是否可以继续</span></span><br><span class="line">        <span class="keyword">if</span> (!ret) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isPlaying) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待解码的数据发送到解码器中</span></span><br><span class="line">        ret = avcodec_send_packet(pContext,</span><br><span class="line">                                  avPacket);<span class="comment">//@return 0 on success, otherwise negative error code:</span></span><br><span class="line">        <span class="keyword">if</span> (ret)<span class="keyword">break</span>;<span class="comment">//给解码器发送失败了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送成功，释放 packet</span></span><br><span class="line">        releaseAVPacket(&amp;avPacket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到解码后的原始数据包</span></span><br><span class="line">        AVFrame *avFrame = av_frame_alloc();</span><br><span class="line">        <span class="comment">//将原始数据发送到 avFrame 内存中去</span></span><br><span class="line">        ret = avcodec_receive_frame(pContext, avFrame);<span class="comment">//0:success, a frame was returned</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR(EAGAIN)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//获取失败，继续下次任务</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;<span class="comment">//说明失败了</span></span><br><span class="line">            releaseAVFrame(&amp;avFrame);<span class="comment">//释放申请的内存</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将获取到的原始数据放入队列中，也就是解码后的原始数据</span></span><br><span class="line">        audioFrames.push(avFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放packet</span></span><br><span class="line">    <span class="keyword">if</span> (avPacket)</span><br><span class="line">        releaseAVPacket(&amp;avPacket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>音视频的逻辑都是一样的就不在多说了。</p>
<h4 id="渲染-PCM"><a href="#渲染-PCM" class="headerlink" title="渲染 PCM"></a>渲染 PCM</h4><p>渲染 PCM 可以使用 Java 层的 AudioTrack ,也可以使用 NDK 的 OpenSL ES 来渲染，我这里为了性能和更好的对接，直接都在 C++ 中实现了，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频播放  //直接使用 OpenLS ES 渲染 PCM 数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioChannel::audio_player</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 1. 创建引擎并获取引擎接口</span></span><br><span class="line">    <span class="comment">// 1.1创建引擎对象：SLObjectItf engineObject</span></span><br><span class="line">    SLresult result = slCreateEngine(&amp;engineObject, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 初始化引擎</span></span><br><span class="line">    result = (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (SL_BOOLEAN_FALSE != result) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3 获取引擎接口 SLEngineItf engineInterface</span></span><br><span class="line">    result = (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineInterface);</span><br><span class="line">    <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 2. 设置混音器</span></span><br><span class="line">    <span class="comment">// 2.1 创建混音器：SLObjectItf outputMixObject</span></span><br><span class="line">    result = (*engineInterface)-&gt;CreateOutputMix(engineInterface, &amp;outputMixObject, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 初始化 混音器</span></span><br><span class="line">    result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (SL_BOOLEAN_FALSE != result) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  不启用混响可以不用获取混音器接口</span></span><br><span class="line">    <span class="comment">//  获得混音器接口</span></span><br><span class="line">    <span class="comment">//  result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB,</span></span><br><span class="line">    <span class="comment">//                                         &amp;outputMixEnvironmentalReverb);</span></span><br><span class="line">    <span class="comment">//  if (SL_RESULT_SUCCESS == result) &#123;</span></span><br><span class="line">    <span class="comment">//  设置混响 ： 默认。</span></span><br><span class="line">    <span class="comment">//  SL_I3DL2_ENVIRONMENT_PRESET_ROOM: 室内</span></span><br><span class="line">    <span class="comment">//  SL_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM : 礼堂 等</span></span><br><span class="line">    <span class="comment">//  const SLEnvironmentalReverbSettings settings = SL_I3DL2_ENVIRONMENT_PRESET_DEFAULT;</span></span><br><span class="line">    <span class="comment">//  (*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties(</span></span><br><span class="line">    <span class="comment">//       outputMixEnvironmentalReverb, &amp;settings);</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 3. 创建播放器</span></span><br><span class="line">    <span class="comment">// 3.1 配置输入声音信息</span></span><br><span class="line">    <span class="comment">// 创建buffer缓冲类型的队列 2个队列</span></span><br><span class="line">    SLDataLocator_AndroidSimpleBufferQueue loc_bufq = &#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">                                                       <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// pcm数据格式</span></span><br><span class="line">    <span class="comment">// SL_DATAFORMAT_PCM：数据格式为pcm格式</span></span><br><span class="line">    <span class="comment">// 2：双声道</span></span><br><span class="line">    <span class="comment">// SL_SAMPLINGRATE_44_1：采样率为44100（44.1赫兹 应用最广的，兼容性最好的）</span></span><br><span class="line">    <span class="comment">// SL_PCMSAMPLEFORMAT_FIXED_16：采样格式为16bit （16位）(2个字节)</span></span><br><span class="line">    <span class="comment">// SL_PCMSAMPLEFORMAT_FIXED_16：数据大小为16bit （16位）（2个字节）</span></span><br><span class="line">    <span class="comment">// SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT：左右声道（双声道）  （双声道 立体声的效果）</span></span><br><span class="line">    <span class="comment">// SL_BYTEORDER_LITTLEENDIAN：小端模式</span></span><br><span class="line">    SLDataFormat_PCM format_pcm = &#123;SL_DATAFORMAT_PCM, <span class="number">2</span>, SL_SAMPLINGRATE_44_1,</span><br><span class="line">                                   SL_PCMSAMPLEFORMAT_FIXED_16,</span><br><span class="line">                                   SL_PCMSAMPLEFORMAT_FIXED_16,</span><br><span class="line">                                   SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT,</span><br><span class="line">                                   SL_BYTEORDER_LITTLEENDIAN&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据源 将上述配置信息放到这个数据源中</span></span><br><span class="line">    SLDataSource audioSrc = &#123;&amp;loc_bufq, &amp;format_pcm&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 配置音轨（输出）</span></span><br><span class="line">    <span class="comment">// 设置混音器</span></span><br><span class="line">    SLDataLocator_OutputMix loc_outmix = &#123;SL_DATALOCATOR_OUTPUTMIX, outputMixObject&#125;;</span><br><span class="line">    SLDataSink audioSnk = &#123;&amp;loc_outmix, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要的接口 操作队列的接口</span></span><br><span class="line">    <span class="keyword">const</span> SLInterfaceID ids[<span class="number">1</span>] = &#123;SL_IID_BUFFERQUEUE&#125;;</span><br><span class="line">    <span class="keyword">const</span> SLboolean req[<span class="number">1</span>] = &#123;SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.3 创建播放器</span></span><br><span class="line">    result = (*engineInterface)-&gt;CreateAudioPlayer(engineInterface, &amp;bqPlayerObject, &amp;audioSrc,</span><br><span class="line">                                                   &amp;audioSnk, <span class="number">1</span>, ids, req);</span><br><span class="line">    <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  3.4 初始化播放器：SLObjectItf bqPlayerObject</span></span><br><span class="line">    result = (*bqPlayerObject)-&gt;Realize(bqPlayerObject, SL_BOOLEAN_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  3.5 获取播放器接口：SLPlayItf bqPlayerPlay</span></span><br><span class="line">    result = (*bqPlayerObject)-&gt;GetInterface(bqPlayerObject, SL_IID_PLAY, &amp;bqPlayerPlay);</span><br><span class="line">    <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 4. 设置播放器回调函数</span></span><br><span class="line">    <span class="comment">// 4.1 获取播放器队列接口：SLAndroidSimpleBufferQueueItf bqPlayerBufferQueue</span></span><br><span class="line">    (*bqPlayerObject)-&gt;GetInterface(bqPlayerObject, SL_IID_BUFFERQUEUE, &amp;bqPlayerBufferQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2 设置回调 void bqPlayerCallback(SLAndroidSimpleBufferQueueItf bq, void *context)</span></span><br><span class="line">    (*bqPlayerBufferQueue)-&gt;RegisterCallback(bqPlayerBufferQueue, bqPlayerCallback, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 5. 设置播放状态</span></span><br><span class="line">    (*bqPlayerPlay)-&gt;SetPlayState(bqPlayerPlay, SL_PLAYSTATE_PLAYING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 6. 手动激活回调函数</span></span><br><span class="line">    bqPlayerCallback(bqPlayerBufferQueue, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置渲染数据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 PCM</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AudioChannel::getPCM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义 PCM 数据大小</span></span><br><span class="line">    <span class="keyword">int</span> pcm_data_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始数据包装类</span></span><br><span class="line">    AVFrame *pcmFrame = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环取出</span></span><br><span class="line">    <span class="keyword">while</span> (isPlaying) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">            <span class="comment">//线程休眠 10s</span></span><br><span class="line">            av_usleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = audioFrames.pop(pcmFrame);</span><br><span class="line">        <span class="keyword">if</span> (!isPlaying)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ret)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PCM 处理逻辑</span></span><br><span class="line">        pcmFrame-&gt;data;</span><br><span class="line">        <span class="comment">// 音频播放器的数据格式是我们在下面定义的（16位 双声道 ....）</span></span><br><span class="line">        <span class="comment">// 而原始数据（是待播放的音频PCM数据）</span></span><br><span class="line">        <span class="comment">// 所以，上面的两句话，无法统一，一个是(自己定义的16位 双声道 ..) 一个是原始数据，为了解决上面的问题，就需要重采样。</span></span><br><span class="line">        <span class="comment">// 开始重采样</span></span><br><span class="line">        <span class="keyword">int</span> dst_nb_samples = av_rescale_rnd(swr_get_delay(swr_ctx, pcmFrame-&gt;sample_rate) +</span><br><span class="line">                                            pcmFrame-&gt;nb_samples, out_sample_rate,</span><br><span class="line">                                            pcmFrame-&gt;sample_rate, AV_ROUND_UP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重采样</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * @param out_buffers            输出缓冲区，当PCM数据为Packed包装格式时，只有out[0]会填充有数据。</span></span><br><span class="line"><span class="comment">        * @param dst_nb_samples         每个通道可存储输出PCM数据的sample数量。</span></span><br><span class="line"><span class="comment">        * @param pcmFrame-&gt;data         输入缓冲区，当PCM数据为Packed包装格式时，只有in[0]需要填充有数据。</span></span><br><span class="line"><span class="comment">        * @param pcmFrame-&gt;nb_samples   输入PCM数据中每个通道可用的sample数量。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * @return  返回每个通道输出的sample数量，发生错误的时候返回负数。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ret = swr_convert(swr_ctx, &amp;out_buffers, dst_nb_samples, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pcmFrame-&gt;data,</span><br><span class="line">                          pcmFrame-&gt;nb_samples);<span class="comment">//返回每个通道输出的sample数量，发生错误的时候返回负数。</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error while converting\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pcm_data_size = ret * out_sample_size * out_channels;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于音视频同步</span></span><br><span class="line">        audio_time = pcmFrame-&gt;best_effort_timestamp * av_q2d(<span class="keyword">this</span>-&gt;base_time);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//渲染完成释放资源</span></span><br><span class="line">    releaseAVFrame(&amp;pcmFrame);</span><br><span class="line">    <span class="keyword">return</span> pcm_data_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建播放音频的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bqPlayerCallback</span><span class="params">(SLAndroidSimpleBufferQueueItf bq, <span class="keyword">void</span> *context)</span> </span>&#123;</span><br><span class="line">    AudioChannel *audioChannel = <span class="keyword">static_cast</span>&lt;AudioChannel *&gt;(context);</span><br><span class="line">    <span class="comment">//获取 PCM 音频裸流</span></span><br><span class="line">    <span class="keyword">int</span> pcmSize = audioChannel-&gt;getPCM();</span><br><span class="line">    <span class="keyword">if</span> (!pcmSize)<span class="keyword">return</span>;</span><br><span class="line">    (*bq)-&gt;Enqueue(bq, audioChannel-&gt;out_buffers, pcmSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码编写到这里，音视频也都正常渲染了，但是这里还有一个问题，随着播放的时间越久那么就会产生音视频各渲染各的，没有达到同步或者一直播放，这样的体验是非常不好的，所以下一小节我们来解决这个问题。</p>
<h3 id="音视频同步"><a href="#音视频同步" class="headerlink" title="音视频同步"></a>音视频同步</h3><p>音视频同步市面上有 3 种解决方案: 音频向视频同步，视频向音频同步，音视频统一向外部时钟同步。下面就分别来介绍这三种对齐方式是如何实现的，以及各自的优缺点。</p>
<ul>
<li><ol>
<li><p>音频向视频同步</p>
<p>先来看一下这种同步方式是如何实现的，音频向视频同步，顾名思义，就是视频会维持一定的刷新频率，或者根据渲染视频帧的时长来决定当前视频帧的渲染时长，或者说视频的每一帧肯定可以全部渲染出来，当我们向 AudioChannel 模块填充音频数据的时候，会与当前渲染的视频帧的时间戳进行比较，这个差值如果不在阀值得范围内，就需要做对齐操作；如果其在阀值范围内，那么就可以直接将本帧音频帧填充到 AudioChannel 模块，进而让用户听到该声音。那如果不在阀值范围内，又该如何进行对齐操作呢？这就需要我们去调整音频帧了，也就是说如果要填充的音频帧的时间戳比当前渲染的视频帧的时间戳小，那就需要进行跳帧操作（可以通过加快速度播放，也可以是丢弃一部分音频帧）；如果音频帧的时间戳比当前渲染的视频帧的时间戳大，那么就需要等待，具体实现可以向 AudioChannel 模块填充空数据进行播放，也可以是将音频的速度放慢播放给用户听，而此时视频帧是继续一帧一帧进行渲染的，一旦视频的时间戳赶上了音频的时间戳，就可以将本帧的音频帧的数据填充到 AudioChannel 模块了，这就是音频向视频同步的实现。</p>
<p><strong>优点:</strong>  视频可以将每一帧都播放给用户看，画面看上去是最流畅的。</p>
<p><strong>缺点:</strong>  音频会加速或者丢帧，如果丢帧系数小，那么用户感知可能不太强，如果系数大，那么用户感知就会非常的强烈了，发生丢帧或者插入空数据的时候，用户的耳朵是可以明显感觉到的。</p>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>视频向音频同步</p>
<p>再来看一下视频向音频同步的方式是如何实现的，这与上面提到的方式恰好相反，由于不论是哪一个平台播放音频的引擎，都可以保证播放音频的时间长度与实际这段音频所代表的时间长度是一致的，所以我们可以依赖于音频的顺序播放为我们提供的时间戳，当客户端代码请求发送视频帧的时候，会先计算出当前视频队列头部的视频帧元素的时间戳与当前音频播放帧的时间戳的差值。如果在阀值范围内，就可以渲染这一帧视频帧；如果不在阀值范围内，则要进行对齐操作。具体的对齐操作方法就是: 如果当前队列头部的视频帧的时间戳小于当前播放音频帧的时间戳，那么就进行跳帧操作；如果大于当前播放音频帧的时间戳，那么就等待(睡眠、重复渲染、不渲染)的操作。</p>
<p><strong>优点</strong> :  音频可以连续的渲染。</p>
<p><strong>缺点</strong> :  视频画面会有跳帧的操作，但是对于视频画面的丢帧和跳帧用户的眼睛是不太容易分辨得出来的。</p>
</li>
</ol>
</li>
<li><ol start="3">
<li><p>音视频统一向外部时钟同步</p>
<p>这种策略其实更像是上述两种方式对齐的合体，其实现就是在外部单独维护一轨外部时钟，我们要保证该外部时钟的更新是按照时间的增加而慢慢增加的，当我们获取音频数据和视频帧的时候，都需要与这个外部时钟进行对齐，如果没有超过阀值，那么就会直接返回本帧音频帧或者视频帧，如果超过阀值就要进行对齐操作，具体的对齐操作是: 使用上述两种方式里面的对齐操作，将其分别应用于音频的对齐和视频的对齐。</p>
<p><strong>优点:</strong>  可以最大限度的保证音视频都可以不发生跳帧的行为。</p>
<p><strong>缺点:</strong>  外部时钟不好控制，极有可能引发音频和视频都跳帧的行为。</p>
</li>
</ol>
<p><strong>同步总结:</strong></p>
<p>根据人眼睛和耳朵的生理构造因素，得出了一个结论，那就是人的耳朵比人的眼睛要敏感的多，那就是说，如果音频有跳帧的行为或者填空数据的行为，那么我们的耳朵是非常容易察觉得到的；而视频如果有跳帧或者重复渲染的行为，我们的眼睛其实不容易分别出来。根据这个理论，所以我们这里也将采用 <strong>视频向音频对齐</strong> 的方式。</p>
<p>根据得出的结论，我们需要在音频、视频渲染之前修改几处地方，如下所示:</p>
<ol>
<li><p>通过 ffmpeg api 拿到音频时间戳</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 在 BaseChannel 里面定义变量,供子类使用</span></span><br><span class="line"><span class="comment">//###############下面是音视频同步需要用到的</span></span><br><span class="line">    <span class="comment">//FFmpeg 时间基: 内部时间</span></span><br><span class="line">    AVRational base_time;</span><br><span class="line">    <span class="keyword">double</span> audio_time;</span><br><span class="line">    <span class="keyword">double</span> video_time;</span><br><span class="line"><span class="comment">//###############下面是音视频同步需要用到的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 得到音频时间戳 pcmFrame 解码之后的原始数据帧</span></span><br><span class="line">audio_time = pcmFrame-&gt;best_effort_timestamp * av_q2d(<span class="keyword">this</span>-&gt;base_time);</span><br></pre></td></tr></table></figure>
</li>
<li><p>视频向音频时间戳对齐(大于小于音频时间戳的处理方式)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视频向音频时间戳对齐---》控制视频播放速度</span></span><br><span class="line"><span class="comment">//在视频渲染之前，根据 fps 来控制视频帧</span></span><br><span class="line"><span class="comment">//frame-&gt;repeat_pict = 当解码时，这张图片需要要延迟多久显示</span></span><br><span class="line"><span class="keyword">double</span> extra_delay = frame-&gt;repeat_pict;</span><br><span class="line"><span class="comment">//根据 fps 得到延迟时间</span></span><br><span class="line"><span class="keyword">double</span> base_delay = <span class="number">1.0</span> / <span class="keyword">this</span>-&gt;fpsValue;</span><br><span class="line"><span class="comment">//得到当前帧的延迟时间</span></span><br><span class="line"><span class="keyword">double</span> result_delay = extra_delay + base_delay;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//拿到视频播放的时间基</span></span><br><span class="line">video_time = frame-&gt;best_effort_timestamp * av_q2d(<span class="keyword">this</span>-&gt;base_time);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//拿到音频播放的时间基</span></span><br><span class="line"><span class="keyword">double_t</span> audioTime = <span class="keyword">this</span>-&gt;audio_time;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//计算音频和视频的差值</span></span><br><span class="line"><span class="keyword">double</span> av_time_diff = video_time - audioTime;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//说明:</span></span><br><span class="line"><span class="comment">//video_time &gt; audioTime 说明视频快，音频慢，等待音频</span></span><br><span class="line"><span class="comment">//video_time &lt; audioTime 说明视频慢，音屏快，需要追赶音频，丢弃掉冗余的视频包也就是丢帧</span></span><br><span class="line"><span class="keyword">if</span> (av_time_diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//通过睡眠的方式灵活等待</span></span><br><span class="line">    <span class="keyword">if</span> (av_time_diff &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        av_usleep((result_delay * <span class="number">2</span>) * <span class="number">1000000</span>);</span><br><span class="line">        LOGE(<span class="string">"av_time_diff &gt; 1 睡眠:%d"</span>, (result_delay * <span class="number">2</span>) * <span class="number">1000000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明相差不大</span></span><br><span class="line">        av_usleep((av_time_diff + result_delay) * <span class="number">1000000</span>);</span><br><span class="line">        LOGE(<span class="string">"av_time_diff &lt; 1 睡眠:%d"</span>, (av_time_diff + result_delay) * <span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (av_time_diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"av_time_diff &lt; 0 丢包处理：%f"</span>, av_time_diff);</span><br><span class="line">        <span class="comment">//视频丢包处理</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;videoFrames.deleteVideoFrame();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//完美</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>加上这段代码之后，咱们音视频就算是差不多同步了，不敢保证 100%。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>音视频播放器已经实现完毕，咱们从<code>解封装-&gt;解码-&gt;音视频同步-&gt;音视频渲染</code>按照流程讲解并编写了实例代码,相信你已经对播放器的流程和架构设计都已经有了一定的认识，等公司有需求的时候也可以自己设计一款播放器并开发出来了。</p>
<p><a href="https://github.com/yangkun19921001/ndk_study/tree/master/myplayer">完整代码已上传 GitHub </a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:13:00.000Z" title="2020-06-04T10:13:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">1 小时 读完 (大约 6893 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/">音视频学习 (八) 视频渲染</a></h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214005005.png" alt=""></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>上一篇文章我们学习了音频的基础知识和音频的渲染之后，该篇我们学习视频的知识，与上一篇学习方式一样，基础 + demo ，主打渲染，采集跟编码我们后面学习播放器和录屏在来研究。</p>
<h2 id="视频的基础知识"><a href="#视频的基础知识" class="headerlink" title="视频的基础知识"></a>视频的基础知识</h2><h3 id="图像的物理现象"><a href="#图像的物理现象" class="headerlink" title="图像的物理现象"></a>图像的物理现象</h3><p>做过 Camera 采集或者做过帧动画其实应该知道，视频是由一幅幅图像或者说一帧帧 YUV 数据组成，所以要学习视频还得从图像开始学习。</p>
<p>我们回顾一下，应该是初中的时候做过一个三棱镜实验，内容是如何利用三棱镜将太阳光分解成彩色的光带？第一个做这个实验者是 <strong>牛顿</strong> ，各色光因其所形成的折射角不同而彼此分离，就像彩虹一样，所以白光能够分解成多种色彩的光。后来人们通过实验证明，红绿蓝三种色光无法被分解，故称为三原色光，等量的三原色光相加会变为白光，即白光中含有等量的红光(R),绿光(G),蓝光(B)。</p>
<p>在日常生活中，由于光的反射，我们才能看到各类物体的轮廓和颜色。但是如果将这个理论应用到手机中，那么该结论还成立吗？答案是否定的，因为在黑暗中我们也可以看到手机屏幕中的内容，实际上人眼能看到手机屏幕上的内容的原理如下。</p>
<p>假设一部手机屏幕的分辨率是 1920 * 1080 说明水平方向有 1080 个像素点，垂直方向有 1920 个像素点，所以整个屏幕就有 1920 * 1080 个像素点(这也是分辨率的含义)。每个像素点都由三个子像素点组成，如下图所示，这些密密麻麻的子像素点在图像放大或者在显微镜下可以看得一清二楚。当要显示某篇文字或者某幅图像时，就会把这幅图像的每一个像素点的 RGB 通道分别对应的屏幕位置上的子像素点绘制到屏幕上，从而显示整个图像。</p>
<p>所以在黑暗的环境下也能看到手机屏幕上的内容，是因为手机屏幕是自发光的，而不是通过光的反射才被人们看到的。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214003820.png" alt=""></p>
<h3 id="图像的数值表示"><a href="#图像的数值表示" class="headerlink" title="图像的数值表示"></a>图像的数值表示</h3><h4 id="RGB-表示方式"><a href="#RGB-表示方式" class="headerlink" title="RGB 表示方式"></a>RGB 表示方式</h4><p>通过上一小节我们清楚的知道任何一个图像都是由 RGB 组成，那么一个像素点的 RGB 该如何表示呢？音频里面的每一个采样 (sample) 均使用 16 bit 来表示，那么像素里面的子像素又该如何表示呢？通常的表示方式有以下几种。</p>
<ul>
<li>浮点表示: 取值范围在 0.0 ~ 1.0 之间，比如在 OpenGL ES 中对每一个子像素点的表示使用的就是这种方式。</li>
<li>整数表示: 取值范围为 0 ~ 255 或者 00 ~ FF , 8 个 bit 表示一个子像素点，32 个 bit 表示一个像素，这就是类似某些平台上表示图像格式的 RGBA_8888 数据格式。比如 Android 平台上的 RGB_565 的表示方法为 16 个 bit 模式表示一个像素， R 用 5 个 bit , G 用 6 个 bit, B 用 5 个 bit 来表示。</li>
</ul>
<p>对于一幅图像，一般使用整数表示方法进行描述，比如计算一张 1920 * 1080 的 RGB_8888 的图像大小，可采用如下计算方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1920 * 1080 * 4 &#x2F; 1024 &#x2F; 1024 ≈ 7.910 MB</span><br></pre></td></tr></table></figure>

<p>这也是 Bitmap 在内存中所占用的大小，所以每一张图像的裸数据都是很大的。对于图像的裸数据来说，直接来网络中进行传输也是不大可能的，所以就有了图像的压缩格式，比如我之前开源过一个基于 <a href="https://github.com/yangkun19921001/LIBJPEG_SAMPLE">JPEG 压缩</a> :JPEG 是静态图像压缩标准，由 ISO 制定。 JPEG 图像压缩算法在提供良好的压缩性能的同时，具有较好的重建质量。这种算法被广泛应用于图像处理领域，当然它也是一种有损压缩。在很多网站如淘宝上使用的都是这种压缩之后的图像，但是，这种压缩不能直接应用于视频压缩，因为对于视频来讲，还有一个时域上的因素需要考虑，也就是说不仅仅要考虑帧内编码，还要考虑帧间编码。视频采用的是更加成熟的算法，关于视频压缩算法的相关内容我们会在后面进行介绍。</p>
<h4 id="YUV-表示方式"><a href="#YUV-表示方式" class="headerlink" title="YUV 表示方式"></a>YUV 表示方式</h4><p>对于视频帧的裸数据表示，其实更多的是 YUV 数据格式的表示， YUV 主要应用于优化彩色视频信号的传输，使其向后兼容老式黑白电视。在 RGB 视频信号传输相比，它最大的优点在于只需要占用极少的频宽(RGB 要求三个独立的视频信号同时传输)。其中 Y 表示明亮度，而 “U”,”V” 表示的则是色度值，它们的作用是描述影像的色彩及饱和度，用于指定像素的颜色。“亮度” 是透过 RGB 输入信号来建立的，方法时将 RGB 信号的特定部分叠加到一起。“色度” 则定义了颜色的两个方面 - 色调与饱和度，分别用 Cr 和 Cb 来表示。其中，Cr 反应了 RGB 输入信号红色部分与 RGB 信号亮度值之间的差异，而 Cb 反映的则是 RGB 输入信号蓝色部分与 RGB 信号亮度值之间的差异。</p>
<p>之所以采用 YUV 色彩空间，是因为它的亮度信号 Y 和色度信号 U、V 是分离的。如果只有 Y 信号分量而没有 U 、V 分量，那么这样表示的图像就是黑白灰图像。彩色电视采用 YUV 空间正是为了用亮度信号 Y 解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号，最常用的表示形式是 Y、U、V 都使用 8 字节来表示，所以取值范围是 0 ~ 255 。 在广播电视系统中不传输很低和很高的数值，实际上是为了防止信号变动造成过载， Y 的取值范围都是 16 ~ 235 ，UV 的取值范围都是 16 ~ 240。</p>
<p>YUV 最常用的采样格式是 4:2:0 ， 4:2:0 并不意味着只有 Y 、Cb 而没有 Cr 分量。它指的是对每行扫描线来说，只有一种色度分量是以 2：1 的抽样率来存储的。相邻的扫描行存储着不同的色度分量，也就是说，如果某一行是 4：2：0，那么下一行就是 4：0：2，在下一行是 4：2：0，以此类推。对于每个色度分量来说，水平方向和竖直方向的抽象率都是 2：1，所以可以说色度的抽样率是 4：1。对非压缩的 8 bit 量化的视频来说，8*4 的一张图片需要占用 48 byte 内存。</p>
<p>相较于 RGB ，我们可以计算一帧为 1920 * 1080 的视频帧，用 YUV420P 的格式来表示，其数据量的大小如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1920 * 1080 * 1 + 1920 * 1080 * 0.5 ) &#x2F; 1024 &#x2F;1024 ≈ 2.966MB</span><br></pre></td></tr></table></figure>

<p>如果 fps（1 s 的视频帧数量）是 25 ，按照 5 分钟的一个短视频来计算，那么这个短视频用 YUV420P 的数据格式来表示的话，其数据量的大小就是 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.966MB * 25fps * 5min * 60s &#x2F; 1024 ≈ 21GB</span><br></pre></td></tr></table></figure>

<p>可以看到仅仅 5 分钟的视频数据量就能达到 21 G, 像抖音，快手这样短视频领域的代表这样的话还不卡死，那么如何对短视频进行存储以及流媒体播放呢？答案肯定是需要进行视频编码，后面会介绍视频编码的内容。</p>
<p>如果对 YUV  采样或者存储不明白的可以看这篇文章:<a href="https://zhuanlan.zhihu.com/p/68532444">音视频基础知识—像素格式YUV</a></p>
<h4 id="YUV-和-RGB-的转化"><a href="#YUV-和-RGB-的转化" class="headerlink" title="YUV 和 RGB 的转化"></a>YUV 和 RGB 的转化</h4><p>前面已经讲过，凡是渲染到屏幕上的文字、图片、或者其它，都需要转为 RGB 的表示形式，那么 YUV 的表示形式和 RGB 的表示形式之间是如何进行转换的呢？可以参考该篇文章<a href="http://blog.shenyuanluo.com/ColorConverter.html">YUV &lt;——&gt; RGB 转换算法</a>, 相互转换 C++ 代码可以参考<a href="https://github.com/shenyuanluo/SYKit/tree/master/SYKit/SYConverter">地址</a></p>
<h3 id="视频的编码方式"><a href="#视频的编码方式" class="headerlink" title="视频的编码方式"></a>视频的编码方式</h3><h4 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h4><p>还记得上一篇文章我们学习的音频编码方式吗？音频的编码主要是去除冗余信息，从而实现数据量的压缩。那么对于视频压缩，又该从哪几个方面来对数据进行压缩呢？其实与之前提到的音频编码类似，视频压缩也是通过去除冗余信息来进行压缩的。相较于音频数据，视频数据有极强的相关性，也就是说有大量的冗余信息，包括空间上的冗余信息和时间上的冗余信息，具体包括以下几个部分。</p>
<ul>
<li>运动补偿: 运动补偿是通过先前的局部图像来预测，，补偿当前的局部图像，它是减少帧序列冗余信息的有效方法。</li>
<li>运动表示: 不同区域的图像需要使用不同的运动矢量来描述运动信息。</li>
<li>运动估计: 运动估计是从视频序列中抽取运动信息的一整套技术。</li>
</ul>
<p>使用帧内编码技术可以去除空间上的冗余信息。</p>
<p>大家还记得之前提到的图像编码<a href="https://github.com/libjpeg-turbo/libjpeg-turbo"> JPEG </a> 吗？对于视频， ISO 同样也制定了标准: Motion JPEG 即 MPEG ，MPEG 算法是适用于动态视频的压缩算法，它除了对单幅图像进行编码外，还利用图像序列中的相关原则去除冗余，这样可以大大提高视频的压缩比，截至目前，MPEG 的版本一直在不断更新中，主要包括这样几个版本: Mpeg1(用于 VCD)、Mpeg2(用于 DVD)、Mpeg4 AVC(现在流媒体使用最多的就是它了)。</p>
<p>想比较 ISO 指定的 MPEG 的视频压缩标准，ITU-T 指定的 H.261、H.262、H.263、H.264 一系列视频编码标准是一套单独的体系。其中，H.264 集中了以往标准的所有优点，并吸取了以往标准的经验，采样的是简洁设计，这使得它比 Mpeg4 更容易推广。现在使用最多的就是 H.264 标准, H.264 创造了多参考帧、多块类型、整数变换、帧内预测等新的压缩技术，使用了更精准的分像素运动矢量(1/4、1/8) 和新一代的环路滤波器，这使得压缩性能得到大大提高，系统也变得更加完善。</p>
<h4 id="编码概念"><a href="#编码概念" class="headerlink" title="编码概念"></a>编码概念</h4><p>视频编码中，每帧都代表着一幅静止的图像。而在进行实际压缩时，会采取各种算法以减少数据的容量，其中 IPB 帧就是最常见的一种。</p>
<h5 id="IPB-帧"><a href="#IPB-帧" class="headerlink" title="IPB 帧"></a>IPB 帧</h5><ul>
<li>I 帧:  表示关键帧，你可以理解为这一帧画面的完整保留，解码时只需要本帧数据就可以完成(包含完整画面)。</li>
<li>P 帧: 表示的是当前 P 帧与上一帧( I 帧或者 P帧)的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别生成最终画面。(也就是差别帧， P 帧没有完整画面数据，只有与前一帧的画面差别的数据。)</li>
<li>B 帧: 表示双向差别帧，也就是 B 帧记录的是当前帧与前后帧(前一个 I 帧或 P 帧和后面的 P 帧)的差别(具体比较复杂，有 4 种情况)， 换言之，要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面数据与本帧数据的叠加取得最终的画面。B 帧压缩率高，但是解码时 CPU 会比较吃力。 </li>
</ul>
<h5 id="IDR-帧与-I-帧的理解"><a href="#IDR-帧与-I-帧的理解" class="headerlink" title="IDR 帧与 I 帧的理解"></a>IDR 帧与 I 帧的理解</h5><p>在 H264 的概念中有一个帧称为 IDR 帧，那么 IDR 帧与 I 帧的区别是什么呢 ？ 首先要看下 IDR 的英文全称 instantaneous decoding refresh picture , 因为 H264 采用了多帧预测，所以 I 帧之后的 P 帧有可能会参考 I 帧之前的帧，这就使得在随机访问的时候不能以找到 I 帧作为参考条件，因为即使找到 I 帧，I 帧之后的帧还是有可能解析不出来，而 IDR 帧就是一种特殊的 I 帧，即这一帧之后的所有参考帧只会参考到这个 IDR 帧，而不会再参考前面的帧。在解码器中，一旦收到第一个 IDR 帧，就会立即清理参考帧缓冲区，并将 IDR 帧作为被参考的帧。</p>
<h5 id="PTS-与-DTS"><a href="#PTS-与-DTS" class="headerlink" title="PTS 与 DTS"></a>PTS 与 DTS</h5><p>DTS 主要用视频的解码，全称为(Decoding Time Stamp), PTS 主要用于解码阶段进行视频的同步和输出， 全称为 (Presentation Time Stamp) 。在没有 B 帧的情况下， DTS 和 PTS 的输出顺序是一样的。因为 B 帧打乱了解码和显示的顺序，所以一旦存在 B 帧， PTS 与 DTS 势必就会不同。在大多数编解码标准(H.264 或者 HEVC) 中，编码顺序和输入顺序并不一致，于是才会需要 PTS 和 DTS 这两种不同的时间戳。</p>
<h5 id="GOP-的概念"><a href="#GOP-的概念" class="headerlink" title="GOP 的概念"></a>GOP 的概念</h5><p>两个 I 帧之间形成的一组图片，就是 GOP (Group Of Picture) 的概念。通常在为编码器设置参数的时候，必须要设置 gop_size 的值，其代表的是两个 I 帧之间的帧数目。一个 GOP 中容量最大的帧就是 I 帧，所以相对来讲，gop_size 设置得越大，整个画面的质量就会越好，但是在解码端必须从接收到的第一个 I 帧开始才可以正确的解码出原始图像，否则会无法正确解码，在提高视频质量的技巧中，还有个技巧是多使用 B 帧，一般来说，I 的压缩率是 7 （与 JPG 差不多），P 是 20 ，B 可以达到 50 ，可见使用 B 帧能节省大量空间，节省出来的空间可以用来更多地保存 I 帧，这样就能在相同的码率下提供更好的画质，所以我们要根据不同的业务场景，适当地设置 gop_size 的大小，以得到更高质量的视频。</p>
<p>结合下图，希望可以帮组大家更好的理解 DTS 和 PTS 的概念。</p>
<p>!<img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200224235100.png" alt=""></p>
<h2 id="视频渲染"><a href="#视频渲染" class="headerlink" title="视频渲染"></a>视频渲染</h2><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h3><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200213232202.gif" alt=""></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://www.khronos.org/opengl/">OpenGL</a> (Open Graphics Lib) 定义了一个跨编程语言、跨平台编程的专业图形程序接口。可用于二维或三维图像的处理与渲染，它是一个功能强大、调用方便的底层图形库。对于嵌入式的设备，其提供了 <a href="https://developer.android.com/guide/topics/graphics/opengl?hl=zh-cN">OpenGL ES</a>(OpenGL for Embedded System) 版本，该版本是针对手机、Pad 等嵌入式设备而设计的，是 OpenGL 的一个子集。到目前为止，OpenGL ES 已经经历过很多版本的迭代与更新，到目前为止运用最广泛的还是 <a href="https://www.khronos.org/opengles/">OpenGL ES</a> 2.0 版本。我们接下来所实现的 Demo 就是基于 OpenGL ES 2.0 接口进行编程并实现图像的渲染。</p>
<p>由于 OpenGL ES 是基于跨平台的设计，所以在每个平台上都要有它的具体实现，既要提供 OpenGL ES 的上下文环境以及窗口的管理。在 OpenGL 的设计中，OpenGL 是不负责管理窗口的。那么在 Android 平台上其实是使用 EGL 提供本地平台对 OpenGL ES 的实现。 </p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>要在 Android 平台下使用 OpenGL ES , 第一种方式是直接使用 GLSurfaceView  ，通过这种方式使用 OpenGL ES 比较简单，因为不需要开发者搭建 OpenGL ES 的上下文环境，以及创建 OpenGL ES 的显示设备。但是凡事都有两面，有好处也有坏处，使用 GLSurfaceView 不够灵活，很多真正的 OpenGL ES 的核心用法(比如共享上下文来达到多线程使用 EGL 的 API 来搭建的，并且是基于 C++ 的环境搭建的。因为如果仅仅在 Java 层编写 ，那么对于普通的应用也许可行，但是对于要进行解码或者使用第三方库的场景(比如人脸识别)，则需要到 C++ 层来实施。处于效率和性能的考虑，这里的架构将直接使用 Native 层的 EGL 搭建一个 OpenGL ES 的开发环境。要想在 Native 层使用 EGL ,那么就必须在 CmakeLists.txt 中添加 EGL 库(可以参考如下提供的 CMakeLists 文件配置)，并在使用该库的 C++ 文件中引入对应的头文件，需要引如的头文件地址如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 在开发中如果要使用 EGL 需要在 CMakeLists.txt 中添加 EGL 库，并指定头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 EGL 需要添加的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;EGL/egl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;EGL/eglext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用 OpenGL ES 2.0  也需要在 CMakeLists.txt 中添加 GLESv2 库，并指定头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 OpenGL ES 2.0 需要添加的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLES2/gl2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLES2/gl2ext.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>CMakeLists 文件配置:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#音频渲染</span></span><br><span class="line"><span class="keyword">set</span>(OpenSL <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/opensl)</span><br><span class="line"><span class="comment">#视频渲染</span></span><br><span class="line"><span class="keyword">set</span>(OpenGL <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/gles)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了</span></span><br><span class="line"><span class="keyword">file</span>(GLOB ALL_CPP <span class="variable">$&#123;OpenSL&#125;</span>/*.cpp <span class="variable">$&#123;OpenGL&#125;</span>/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加自己编写 cpp 源文件生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(audiovideo SHARED <span class="variable">$&#123;ALL_CPP&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#找系统中 NDK log库</span></span><br><span class="line"><span class="keyword">find_library</span>(log_lib</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后才开始链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">				<span class="comment">#最后生成的 so 库名称</span></span><br><span class="line">        audiovideo</span><br><span class="line">        <span class="comment">#音频渲染</span></span><br><span class="line">        OpenSLES</span><br><span class="line"></span><br><span class="line">        <span class="comment"># OpenGL 与 NativeWindow 连接本地窗口的中间者</span></span><br><span class="line">        EGL</span><br><span class="line">        <span class="comment">#视频渲染</span></span><br><span class="line">        GLESv2</span><br><span class="line">        <span class="comment">#添加本地库</span></span><br><span class="line">        android</span><br><span class="line"></span><br><span class="line">        <span class="variable">$&#123;log_lib&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>至此，对于 OpenGL 的开发需要用到的头文件以及库文件就引入完毕了，下面再来看看如何使用 EGL 搭建出 OpenGL 的上下文环境以及渲染视频数据。</p>
<ul>
<li><ol>
<li><p>使用 EGL 首先必须创建，建立本地窗口系统和 OpenGL ES 的连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取原始窗口</span></span><br><span class="line">nativeWindow = ANativeWindow_fromSurface(env, surface);</span><br><span class="line"><span class="comment">//获取Display</span></span><br><span class="line"><span class="built_in">display</span> = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">display</span> == EGL_NO_DISPLAY) &#123;</span><br><span class="line">        LOGD(<span class="string">"egl display failed"</span>);</span><br><span class="line">        showMessage(env, <span class="string">"egl display failed"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>初始化 EGL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化egl，后两个参数为主次版本号</span></span><br><span class="line">    <span class="keyword">if</span> (EGL_TRUE != eglInitialize(<span class="built_in">display</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        LOGD(<span class="string">"eglInitialize failed"</span>);</span><br><span class="line">        showMessage(env, <span class="string">"eglInitialize failed"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li><p>确定可用的渲染表面（ Surface ）的配置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//surface 配置，可以理解为窗口</span></span><br><span class="line">EGLConfig eglConfig;</span><br><span class="line">EGLint configNum;</span><br><span class="line">EGLint configSpec[] = &#123;</span><br><span class="line">        EGL_RED_SIZE, <span class="number">8</span>,</span><br><span class="line">        EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">        EGL_BLUE_SIZE, <span class="number">8</span>,</span><br><span class="line">        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,</span><br><span class="line">        EGL_NONE</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> (EGL_TRUE != eglChooseConfig(<span class="built_in">display</span>, configSpec, &amp;eglConfig, <span class="number">1</span>, &amp;configNum)) &#123;</span><br><span class="line">    LOGD(<span class="string">"eglChooseConfig failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"eglChooseConfig failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="4">
<li><p>创建渲染表面 surface（4/5步骤可互换）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建surface(egl和NativeWindow进行关联。最后一个参数为属性信息，0表示默认版本)</span></span><br><span class="line">    winSurface = eglCreateWindowSurface(<span class="built_in">display</span>, eglConfig, nativeWindow, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (winSurface == EGL_NO_SURFACE) &#123;</span><br><span class="line">        LOGD(<span class="string">"eglCreateWindowSurface failed"</span>);</span><br><span class="line">        showMessage(env, <span class="string">"eglCreateWindowSurface failed"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="5">
<li><p>创建渲染上下文 Context</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4 创建关联上下文</span></span><br><span class="line"><span class="keyword">const</span> EGLint ctxAttr[] = &#123;</span><br><span class="line">        EGL_CONTEXT_CLIENT_VERSION, <span class="number">2</span>, EGL_NONE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//EGL_NO_CONTEXT表示不需要多个设备共享上下文</span></span><br><span class="line">context = eglCreateContext(<span class="built_in">display</span>, eglConfig, EGL_NO_CONTEXT, ctxAttr);</span><br><span class="line"><span class="keyword">if</span> (context == EGL_NO_CONTEXT) &#123;</span><br><span class="line">    LOGD(<span class="string">"eglCreateContext failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"eglCreateContext failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="6">
<li><p>指定某个 EGLContext 为当前上下文, 关联起来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将egl和opengl关联</span></span><br><span class="line"><span class="comment">//两个surface一个读一个写。第二个一般用来离线渲染</span></span><br><span class="line"><span class="keyword">if</span> (EGL_TRUE != eglMakeCurrent(<span class="built_in">display</span>, winSurface, winSurface, context)) &#123;</span><br><span class="line">    LOGD(<span class="string">"eglMakeCurrent failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"eglMakeCurrent failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="7">
<li><p>使用 OpenGL 相关的 API 进行绘制操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">GLint vsh = initShader(vertexShader, GL_VERTEX_SHADER);</span><br><span class="line">GLint fsh = initShader(fragYUV420P, GL_FRAGMENT_SHADER);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//创建渲染程序</span></span><br><span class="line">GLint program = glCreateProgram();</span><br><span class="line"><span class="keyword">if</span> (program == <span class="number">0</span>) &#123;</span><br><span class="line">    LOGD(<span class="string">"glCreateProgram failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"glCreateProgram failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//向渲染程序中加入着色器</span></span><br><span class="line">glAttachShader(program, vsh);</span><br><span class="line">glAttachShader(program, fsh);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//链接程序</span></span><br><span class="line">glLinkProgram(program);</span><br><span class="line">GLint status = <span class="number">0</span>;</span><br><span class="line">glGetProgramiv(program, GL_LINK_STATUS, &amp;status);</span><br><span class="line"><span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">    LOGD(<span class="string">"glLinkProgram failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"glLinkProgram failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LOGD(<span class="string">"glLinkProgram success"</span>);</span><br><span class="line"><span class="comment">//激活渲染程序</span></span><br><span class="line">glUseProgram(program);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//加入三维顶点数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> ver[] = &#123;</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line">GLuint apos = <span class="keyword">static_cast</span>&lt;GLuint&gt;(glGetAttribLocation(program, <span class="string">"aPosition"</span>));</span><br><span class="line">glEnableVertexAttribArray(apos);</span><br><span class="line">glVertexAttribPointer(apos, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, ver);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//加入纹理坐标数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> fragment[] = &#123;</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">GLuint aTex = <span class="keyword">static_cast</span>&lt;GLuint&gt;(glGetAttribLocation(program, <span class="string">"aTextCoord"</span>));</span><br><span class="line">glEnableVertexAttribArray(aTex);</span><br><span class="line">glVertexAttribPointer(aTex, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, fragment);</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">//纹理初始化</span></span><br><span class="line"><span class="comment">//设置纹理层对应的对应采样器？</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  //获取一致变量的存储位置</span></span><br><span class="line"><span class="comment">GLint textureUniformY = glGetUniformLocation(program, "SamplerY");</span></span><br><span class="line"><span class="comment">GLint textureUniformU = glGetUniformLocation(program, "SamplerU");</span></span><br><span class="line"><span class="comment">GLint textureUniformV = glGetUniformLocation(program, "SamplerV");</span></span><br><span class="line"><span class="comment">//对几个纹理采样器变量进行设置</span></span><br><span class="line"><span class="comment">glUniform1i(textureUniformY, 0);</span></span><br><span class="line"><span class="comment">glUniform1i(textureUniformU, 1);</span></span><br><span class="line"><span class="comment">glUniform1i(textureUniformV, 2);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//对sampler变量，使用函数glUniform1i和glUniform1iv进行设置</span></span><br><span class="line">glUniform1i(glGetUniformLocation(program, <span class="string">"yTexture"</span>), <span class="number">0</span>);</span><br><span class="line">glUniform1i(glGetUniformLocation(program, <span class="string">"uTexture"</span>), <span class="number">1</span>);</span><br><span class="line">glUniform1i(glGetUniformLocation(program, <span class="string">"vTexture"</span>), <span class="number">2</span>);</span><br><span class="line"><span class="comment">//纹理ID</span></span><br><span class="line">GLuint texts[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//创建若干个纹理对象，并且得到纹理ID</span></span><br><span class="line">glGenTextures(<span class="number">3</span>, texts);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//绑定纹理。后面的的设置和加载全部作用于当前绑定的纹理对象</span></span><br><span class="line"><span class="comment">//GL_TEXTURE0、GL_TEXTURE1、GL_TEXTURE2 的就是纹理单元，GL_TEXTURE_1D、GL_TEXTURE_2D、CUBE_MAP为纹理目标</span></span><br><span class="line"><span class="comment">//通过 glBindTexture 函数将纹理目标和纹理绑定后，对纹理目标所进行的操作都反映到对纹理上</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texts[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//缩小的过滤器</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//放大的过滤器</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//设置纹理的格式和大小</span></span><br><span class="line"><span class="comment">// 加载纹理到 OpenGL，读入 buffer 定义的位图数据，并把它复制到当前绑定的纹理对象</span></span><br><span class="line"><span class="comment">// 当前绑定的纹理对象就会被附加上纹理图像。</span></span><br><span class="line"><span class="comment">//width,height表示每几个像素公用一个yuv元素？比如width / 2表示横向每两个像素使用一个元素？</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D,</span><br><span class="line">             <span class="number">0</span>,<span class="comment">//细节基本 默认0</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//gpu内部格式 亮度，灰度图（这里就是只取一个亮度的颜色通道的意思）</span></span><br><span class="line">             <span class="built_in">width</span>,<span class="comment">//加载的纹理宽度。最好为2的次幂(这里对y分量数据当做指定尺寸算，但显示尺寸会拉伸到全屏？)</span></span><br><span class="line">             <span class="built_in">height</span>,<span class="comment">//加载的纹理高度。最好为2的次幂</span></span><br><span class="line">             <span class="number">0</span>,<span class="comment">//纹理边框</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//数据的像素格式 亮度，灰度图</span></span><br><span class="line">             GL_UNSIGNED_BYTE,<span class="comment">//像素点存储的数据类型</span></span><br><span class="line">             <span class="literal">NULL</span> <span class="comment">//纹理的数据（先不传）</span></span><br><span class="line">);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//绑定纹理</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texts[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//缩小的过滤器</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//设置纹理的格式和大小</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D,</span><br><span class="line">             <span class="number">0</span>,<span class="comment">//细节基本 默认0</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//gpu内部格式 亮度，灰度图（这里就是只取一个颜色通道的意思）</span></span><br><span class="line">             <span class="built_in">width</span> / <span class="number">2</span>,<span class="comment">//u数据数量为屏幕的4分之1</span></span><br><span class="line">             <span class="built_in">height</span> / <span class="number">2</span>,</span><br><span class="line">             <span class="number">0</span>,<span class="comment">//边框</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//数据的像素格式 亮度，灰度图</span></span><br><span class="line">             GL_UNSIGNED_BYTE,<span class="comment">//像素点存储的数据类型</span></span><br><span class="line">             <span class="literal">NULL</span> <span class="comment">//纹理的数据（先不传）</span></span><br><span class="line">);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//绑定纹理</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texts[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//缩小的过滤器</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//设置纹理的格式和大小</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D,</span><br><span class="line">             <span class="number">0</span>,<span class="comment">//细节基本 默认0</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//gpu内部格式 亮度，灰度图（这里就是只取一个颜色通道的意思）</span></span><br><span class="line">             <span class="built_in">width</span> / <span class="number">2</span>,</span><br><span class="line">             <span class="built_in">height</span> / <span class="number">2</span>,<span class="comment">//v数据数量为屏幕的4分之1</span></span><br><span class="line">             <span class="number">0</span>,<span class="comment">//边框</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//数据的像素格式 亮度，灰度图</span></span><br><span class="line">             GL_UNSIGNED_BYTE,<span class="comment">//像素点存储的数据类型</span></span><br><span class="line">             <span class="literal">NULL</span> <span class="comment">//纹理的数据（先不传）</span></span><br><span class="line">);</span><br><span class="line">     </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buf[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">buf[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[<span class="built_in">width</span> * <span class="built_in">height</span>];<span class="comment">//y</span></span><br><span class="line">buf[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[<span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">4</span>];<span class="comment">//u</span></span><br><span class="line">buf[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[<span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">4</span>];<span class="comment">//v</span></span><br><span class="line">     </span><br><span class="line">showMessage(env, <span class="string">"onSucceed"</span>, <span class="literal">true</span>);</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">FILE *fp = fopen(data_source, <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">    LOGD(<span class="string">"oepn file %s fail"</span>, data_source);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">    <span class="comment">//解决异常退出,终止读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (!isPlay)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    fread(buf[<span class="number">0</span>], <span class="number">1</span>, <span class="built_in">width</span> * <span class="built_in">height</span>, fp);</span><br><span class="line">    fread(buf[<span class="number">1</span>], <span class="number">1</span>, <span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">4</span>, fp);</span><br><span class="line">    fread(buf[<span class="number">2</span>], <span class="number">1</span>, <span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">4</span>, fp);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//激活第一层纹理，绑定到创建的纹理</span></span><br><span class="line">    <span class="comment">//下面的width,height主要是显示尺寸？</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE0);</span><br><span class="line">    <span class="comment">//绑定y对应的纹理</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texts[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//替换纹理，比重新使用glTexImage2D性能高多</span></span><br><span class="line">    glTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>,<span class="comment">//相对原来的纹理的offset</span></span><br><span class="line">                    <span class="built_in">width</span>, <span class="built_in">height</span>,<span class="comment">//加载的纹理宽度、高度。最好为2的次幂</span></span><br><span class="line">                    GL_LUMINANCE, GL_UNSIGNED_BYTE,</span><br><span class="line">                    buf[<span class="number">0</span>]);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//激活第二层纹理，绑定到创建的纹理</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE1);</span><br><span class="line">    <span class="comment">//绑定u对应的纹理</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texts[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//替换纹理，比重新使用glTexImage2D性能高</span></span><br><span class="line">    glTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">width</span> / <span class="number">2</span>, <span class="built_in">height</span> / <span class="number">2</span>, GL_LUMINANCE,</span><br><span class="line">                    GL_UNSIGNED_BYTE,</span><br><span class="line">                    buf[<span class="number">1</span>]);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//激活第三层纹理，绑定到创建的纹理</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE2);</span><br><span class="line">    <span class="comment">//绑定v对应的纹理</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texts[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//替换纹理，比重新使用glTexImage2D性能高</span></span><br><span class="line">    glTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">width</span> / <span class="number">2</span>, <span class="built_in">height</span> / <span class="number">2</span>, GL_LUMINANCE,</span><br><span class="line">                    GL_UNSIGNED_BYTE,</span><br><span class="line">                    buf[<span class="number">2</span>]);</span><br><span class="line">     </span><br><span class="line">    glDrawArrays(GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//8. 窗口显示，交换双缓冲区</span></span><br><span class="line">    eglSwapBuffers(<span class="built_in">display</span>, winSurface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="8">
<li><p>交换 EGL 的 Surface 的内部缓冲和 EGL 创建的和平台无关的窗口 diaplay</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口显示，交换双缓冲区</span></span><br><span class="line">eglSwapBuffers(<span class="built_in">display</span>, winSurface);</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="9">
<li><p>释放资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gles_play::release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">display</span> || winSurface || context) &#123;</span><br><span class="line">        <span class="comment">//销毁显示设备</span></span><br><span class="line">        eglDestroySurface(<span class="built_in">display</span>, winSurface);</span><br><span class="line">        <span class="comment">//销毁上下文</span></span><br><span class="line">        eglDestroyContext(<span class="built_in">display</span>, context);</span><br><span class="line">        <span class="comment">//释放窗口</span></span><br><span class="line">        ANativeWindow_release(nativeWindow);</span><br><span class="line">        <span class="comment">//释放线程</span></span><br><span class="line">        eglReleaseThread();</span><br><span class="line">        <span class="comment">//停止</span></span><br><span class="line">        eglTerminate(<span class="built_in">display</span>);</span><br><span class="line">        eglMakeCurrent(<span class="built_in">display</span>, winSurface, EGL_NO_SURFACE, context);</span><br><span class="line">        context = EGL_NO_CONTEXT;</span><br><span class="line">        <span class="built_in">display</span> = EGL_NO_SURFACE;</span><br><span class="line">        winSurface = <span class="literal">nullptr</span>;</span><br><span class="line">        winSurface = <span class="number">0</span>;</span><br><span class="line">        nativeWindow = <span class="number">0</span>;</span><br><span class="line">        isPlay = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>到这里整个 OpenGL ES 渲染工作都完成了，代码已上传到 <a href="https://github.com/yangkun19921001/ndk_study/blob/master/audio_video/src/main/java/com/devyk/audiovideo/video/VideoPlayActivity.java">GitHub 仓库，需要的可以自行查看</a>,注意: 测试的时候需要把 raw/*.yuv 放入 sdcard/ 根目录中。</p>
<p><a href="https://wemp.app/posts/051d4914-5332-4472-8995-d93c1753aa4f">OpenGL ES 使用可以参考该篇博客</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章的概念比较多，难免会枯燥一些，但是了解这些概念是必须的。下一篇将带来 FFmpeg + LibRtmp 播放器开发练习，支持 rtmp 拉流、本地视频播放(该篇文章和上一篇文章都分别讲解了音频视频基础和渲染就是为了播放器开发做准备)，可以先看一下效果(如下图)。是不是有那么一点小小的期待 😜 ，预计在 2 月下旬发布文章，在等一等。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200118212209.gif" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:12:00.000Z" title="2020-06-04T10:12:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">33 分钟 读完 (大约 4945 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E9%9F%B3%E9%A2%91%E6%B8%B2%E6%9F%93/">音视频学习 (七) 音频渲染</a></h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200209170913.jpeg" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在讲解音频渲染之前，需要对音频的基础知识有所了解，所以该篇分为基础概念和AudioTrack 以及 OpenSL ES Demo 实例讲解，这样有助于更好的理解 Android 中音频渲染。</p>
<p>音频的基础概念涉及的知识点比较多，该篇文章的上半部分会详细的介绍，后续文章基本上都会涉及音频的开发，有了基础对于后面的内容就更容易上手了。</p>
<h2 id="音频的基础知识"><a href="#音频的基础知识" class="headerlink" title="音频的基础知识"></a>音频的基础知识</h2><h3 id="声音的物理性质"><a href="#声音的物理性质" class="headerlink" title="声音的物理性质"></a>声音的物理性质</h3><ul>
<li><p>声音是波</p>
<p>说到声音我相信只要听力正常的人都听见过声音，那么声音是如何产生的呢？记得初中物理课本上的描述 - 声音是由物体的振动而产生的。其实声音是一种压力波，当敲打某个物体或演奏某个乐器时，它们的振动都会引起空气有节奏的振动，使周围的空气产生疏密变化，形成疏密相间的纵波，由此就产生了声波，这种现象会一直延续到振动消失为止。</p>
</li>
<li><p>声波的三要素</p>
<p>声波的三要素是频率、振幅、和波形，频率代表音阶的高低，振幅代表响度，波形代表音色。</p>
</li>
<li><p>声音的传播介质</p>
<p>声音的传播介质很广，它可以通过空气、液体和固体进行传播；而且介质不同，传播的速度也不同，比如声音在空气中的传播速度为 340m/s , 在蒸馏水中的传播速度为 1497 m/s , 而在铁棒中的传播速度则可以高达 5200 m/s ；不过，声音在真空中时无法传播的。</p>
</li>
<li><p>回声</p>
<p>当我们在高山或者空旷地带高声大喊的时候，经常会听到回声，之所以会有回声是因为声音在传播过程中遇到障碍物会反弹回来，再次被我们听到。</p>
<p>但是，若两种声音传到我们的耳朵里的时差小于 80 毫秒，我们就无法区分开这两种声音了，其实在日常生活中，人耳也在收集回声，只不过由于嘈杂的外接环境以及回声的分贝比较低，所以我们的耳朵分辨不出这样的声音，或者说是大脑能接收到但分辨不出。</p>
</li>
<li><p>共鸣</p>
<p>自然界中有光能，水能，生活中有机械能，电能，其实声音也可以产生能量，例如两个频率相同的物体，敲打其中一个物体时另一个物体也会振动发生。这种现象称为共鸣，共鸣证明了声音传播可以带动另一个物体振动，也就是说，声音的传播过程也是一种能量的传播过程。</p>
</li>
</ul>
<h3 id="数字音频"><a href="#数字音频" class="headerlink" title="数字音频"></a>数字音频</h3><p>上一小节我们主要介绍了声音的物理现象以及声音中常见的概念，也会后续的讲解统一了术语，本节主要介绍数字音频概念。</p>
<p>为了将模拟信号数字化，本节将分为 3 个概念对数字音频进行讲解，分别是<strong>采样、量化和编码</strong>。首先要对模拟信号进行采样，所谓采样就是在时间轴上对信号进行数字化。根据奈奎斯特定理（也称采样定理），按比声音最高频率高 2 倍以上的频率对声音进行采样，对于高质量的音频信号，其频率范围在 20Hz ~ 20kHz ，所以采样频率一般为 44.1kHz ,这样就保证采样声音达到 20kHz 也能被数字化，从而使得经过数字化处理之后，人耳听到的声音质量不会被降低。而所谓的 44.1 kHz 就是代表 1 s 会采样 44100 次。</p>
<p>那么，具体的每个采样又该如何表示呢？这就涉及到将要讲解的第二个概念: 量化。量化是指在幅度轴上对信号进行数字化，比如用 16 bit 的二进制信号来表示声音的一个采样，而 16 bit 所表示的范围是 [-32768 , 32767] , 共有 65536 个可能取值，因此最终模拟的音频信号在幅度上也分为了 65536 层。</p>
<p>既然每一个分量都是一个采样，那么这么多的采样该如何进行存储呢？这就涉及将要讲解的第三个概念: 编码。所谓编码，就是按照一定的格式记录采样和量化后的数字数据，比如顺序存储或压缩存储等等。</p>
<p>这里涉及了很多中格式，通常所说的音频的裸数据就是 PCM (Pulse Code Modulation) 数据。描述一段 PCM 数据一般需要以下几个概念：量化格式(sampleFormat)、采样率（sampleRate）、声道数 (channel) 。以 CD 的音质为例：量化格式为 16 bit （2 byte）,采样率 44100 ，声道数为 2 ，这些信息就描述了 CD 的音质。而对于声音的格式，还有一个概念用来描述它的大小，称为数据比特率，即 1s 时间内的比特数目，它用于衡量音频数据单位时间内的容量大小。而对于 CD 音质的数据，比特率为多少呢？ 计算如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44100 * 16 * 2 &#x3D; 1378.125 kbps</span><br></pre></td></tr></table></figure>

<p>那么在一分钟里，这类 CD 音质的数据需要占据多大的存储空间呢？计算如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1378.125 * 60 &#x2F; 8 &#x2F; 1024 &#x3D; 10.09 MB</span><br></pre></td></tr></table></figure>

<p>当然，如果 sampleFormat 更加精确 (比如用 4 个字节来描述一个采样)，或者 sampleRate 更加密集 (比如 48kHz 的采样率)， 那么所占的存储空间就会更大，同时能够描述的声音细节就会越精确。存储的这段二进制数据即表示将模拟信号转为数字信号了，以后就可以对这段二进制数据进行存储，播放，复制，或者进行其它操作。 </p>
<h3 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h3><p>上面提到了 CD 音质的数据采样格式，曾计算出每分钟需要的存储空间约为 10.09 MB ,如果仅仅是将其存储在光盘或者硬盘中，可能是可以接受的，但是若要在网络中实时在线传输的话，那么这个数据量可能就太大了，所以必须对其进行压缩编码。压缩编码的基本指标之一就是压缩比，压缩比通常小于 1 。压缩算法包括有损压缩和无损压缩。无所压缩是指解压后的数据可以完全复原。在常用的压缩格式中，用的较多的是有损压缩，有损压缩是指解压后的数据不能完全恢复，会丢失一部分信息，压缩比越小，丢失的信息就比越多，信号还原后的失真就会越大。根据不同的应用场景 (包括存储设备、传输网络环境、播放设备等)，可以选用不同的压缩编码算法，如 PCM 、WAV、AAC 、MP3 、Ogg 等。</p>
<ul>
<li><p>WAV 编码</p>
<p>WAV 编码就是在 PCM 数据格式的前面加了 44 个字节，分别用来存储 PCM 的采样率、声道数、数据格式等信息。</p>
<p><strong>特点:</strong> 音质好，大量软件支持。</p>
<p><strong>场景:</strong> 多媒体开发的中间文件、保存音乐和音效素材。</p>
</li>
<li><p>MP3 编码</p>
<p>MP3 具有不错的压缩比，使用 LAME 编码 （MP3 编码格式的一种实现）的中高码率的 MP3 文件，听感上非常接近源 WAV 文件，当然在不同的应用场景下，应该调整合适的参数以达到最好的效果。</p>
<p><strong>特点:</strong> 音质在 128 Kbit/s 以上表现还不错，压缩比比较高，大量软件和硬件都支持，兼容性好。</p>
<p><strong>场景:</strong> 高比特率下对兼容性有要求的音乐欣赏。</p>
</li>
<li><p>AAC 编码</p>
<p>AAC 是新一代的音频有损压缩技术，它通过一些附加的编码技术(比如 PS 、SBR) 等，衍生出了 LC-AAC 、HE-AAC 、HE-AAC v2 三种主要的编码格式。LC-AAC 是比较传统的 AAC ,相对而言，其主要应用于中高码率场景的编码 (&gt;=80Kbit/s) ; HE-AAC 相当于 AAC + SBR  主要应用于中低码率的编码 （&lt;= 80Kbit/s）; 而新推出的 HE-AAC v2 相当于 AAC + SBR + PS 主要用于低码率场景的编码 (&lt;= 48Kbit/s) 。事实上大部分编码器都设置为 &lt;= 48Kbit/s 自动启用 PS 技术，而 &gt; 48Kbit/s 则不加 PS ，相当于普通的 HE-AAC。</p>
<p><strong>特点:</strong> 在小于 128Kbit/s 的码率下表现优异，并且多用于视频中的音频编码。</p>
<p><strong>场景:</strong> 128 Kbit/s 以下的音频编码，多用于视频中音频轨的编码。</p>
</li>
<li><p>Ogg 编码</p>
<p>Ogg 是一种非常有潜力的编码，在各种码率下都有比较优秀的表现，尤其是在中低码率场景下。Ogg 除了音质好之外，还是完全免费的，这为 Ogg 获得更多的支持打好了基础，Ogg 有着非常出色的算法，可以用更小的码率达到更好的音质，128 Kbit/s 的 Ogg 比 192kbit/s 甚至更高码率的 MP3 还要出色。但是目前因为还没有媒体服务软件的支持，因此基于 Ogg 的数字广播还无法实现。Ogg 目前受支持的情况还不够好，无论是软件上的还是硬件上的支持，都无法和 MP3 相提并论。</p>
<p><strong>特点:</strong> 可以用比 MP3 更小的码率实现比 MP3 更好的音质，高中低码率下均有良好的表现，兼容性不够好，流媒体特性不支持。</p>
<p><strong>场景:</strong> 语言聊天的音频消息场景。</p>
</li>
</ul>
<h2 id="Android-平台下的音频渲染"><a href="#Android-平台下的音频渲染" class="headerlink" title="Android 平台下的音频渲染"></a>Android 平台下的音频渲染</h2><p>音频基础概念上面讲完了，下面我们实现 Android 下的音频渲染，为实现音视频播放器打下一个基础，音视频采集视频录制的时候在讲解。</p>
<p>[PCM 文件 - 链接:<a href="https://pan.baidu.com/s/1ISS7bHMrFAentLB6o4kiBA">https://pan.baidu.com/s/1ISS7bHMrFAentLB6o4kiBA</a>  密码:5z1n](链接:<a href="https://pan.baidu.com/s/1ISS7bHMrFAentLB6o4kiBA">https://pan.baidu.com/s/1ISS7bHMrFAentLB6o4kiBA</a>  密码:5z1n)</p>
<h3 id="AudioTrack-的使用"><a href="#AudioTrack-的使用" class="headerlink" title="AudioTrack 的使用"></a>AudioTrack 的使用</h3><p>由于 AudioTrack 是 Android  SDK 层提供的最底层的 音频播放 API,因此只允许输入裸数据 PCM 。和 MediaPlayer 相比，对于一个压缩的音频文件(比如 MP3 、AAC 等文件)，它只需要自行实现解码操作和缓冲区控制。因为这里只涉及 AudioTrack 的音频渲染端，编解码我们后面在讲解，所以本小节只介绍如何使用 AudioTrack 渲染音频 PCM 裸数据。</p>
<ol>
<li><p>配置 AudioTrack</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AudioTrack</span><span class="params">(<span class="keyword">int</span> streamType, <span class="keyword">int</span> sampleRateInHz, <span class="keyword">int</span> channelConfig, <span class="keyword">int</span> audioFormat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> bufferSizeInBytes, <span class="keyword">int</span> mode)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>streamType</strong>：Android 手机提供了多重音频管理策略，当系统又多个进程需要播放音频的时候，管理策略会决定最终的呈现效果，该参数的可选值将以常量的形式定义在类 AudioManager 中，主要包括以下内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**电话铃声 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STREAM_VOICE_CALL = AudioSystem.STREAM_VOICE_CALL;</span><br><span class="line"><span class="comment">/** 系统铃声 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STREAM_SYSTEM = AudioSystem.STREAM_SYSTEM;</span><br><span class="line"><span class="comment">/** 铃声*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STREAM_RING = AudioSystem.STREAM_RING;</span><br><span class="line"><span class="comment">/** 音乐声 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STREAM_MUSIC = AudioSystem.STREAM_MUSIC;</span><br><span class="line"><span class="comment">/** 警告声 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STREAM_ALARM = AudioSystem.STREAM_ALARM;</span><br><span class="line"><span class="comment">/** 通知声 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STREAM_NOTIFICATION = AudioSystem.STREAM_NOTIFICATION;</span><br></pre></td></tr></table></figure>

<p><strong>sampleRateInHz</strong>：采样率，即播放的音频每秒钟会有没少次采样，可选用的采样频率列表为: 8000 , 16000 , 22050 , 24000 ,32000 , 44100 , 48000 等，大家可以根据自己的应用场景进行合理的选择。</p>
<p><strong>channelConfig:</strong> 声道数的配置，可选值以常量的形式配置在类 AudioFormat 中，常用的是 CHANNEL_IN_MONO (单声道)、CHANNEL_IN_STEREO (双声道) ，因为现在大多数手机的麦克风都是伪立体声采集，为了性能考虑，建议使用单声道进行采集。</p>
<p><strong>audioFormat:</strong> 该参数是用来配置 “数据位宽” 的，即采样格式，可选值以常量的形式定义在类 AudioFormat 中，分别为 ENCODING_PCM_16BIT (兼容所有手机)、ENCODING_PCM_8BIT ，</p>
<p><strong>bufferSizeInBytes:</strong> 配置内部的音频缓冲区的大小， AudioTrack 类提供了一个帮助开发者确定的 bufferSizeInBytes 的函数，其原型具体如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinBufferSize</span><span class="params">(<span class="keyword">int</span> sampleRateInHz, <span class="keyword">int</span> channelConfig, <span class="keyword">int</span> audioFormat)</span></span></span><br></pre></td></tr></table></figure>

<p>在实际开发中，强烈建议由该函数计算出需要传入的缓冲区大小，而不是手动计算。</p>
<p><strong>mode:</strong> AudioTrack 提供了两种播放模式，可选的值以常量的形式定义在类 AudioTrack 中，一个是 MODE_STATIC , 需要一次性将所有的数据都写入播放缓冲区中，简单高效，通常用于播放铃声、系统提醒的音频片段；另一个是 MODE_STREAM ，需要按照一定的时间间隔不断地写入音频数据，理论上它可以应用于任何音频播放的场景。</p>
</li>
<li><p>Play</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前播放实例是否初始化成功，如果处于初始化成功的状态并且未播放的状态，那么就调用 play</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != mAudioTrack &amp;&amp; mAudioTrack.getState() != AudioTrack.STATE_UNINITIALIZED &amp;&amp; mAudioTrack.getPlayState() != PLAYSTATE_PLAYING)</span><br><span class="line">   mAudioTrack.play();</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"==release==="</span>);</span><br><span class="line">    mStatus = Status.STATUS_NO_READY;</span><br><span class="line">    <span class="keyword">if</span> (mAudioTrack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAudioTrack.release();</span><br><span class="line">        mAudioTrack = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体实例请移步 <a href="https://github.com/yangkun19921001/ndk_study/blob/master/audioplay/src/main/java/com/devyk/audioplay/AudioTracker.java[]">AudioPlay 项目的 AudioTracker 部分</a>，需要把项目中 raw 目录下的 pcm 文件放入 sdcard 跟目录中。</p>
</li>
</ol>
<h3 id="OpenSL-ES-的使用"><a href="#OpenSL-ES-的使用" class="headerlink" title="OpenSL ES 的使用"></a>OpenSL ES 的使用</h3><p><a href="https://developer.android.google.cn/ndk/guides/audio/opensl-for-android">OpenSL ES 官方文档</a></p>
<p>OpenSL ES 全称(Open Sound Library for Embedded System) ,即嵌入式音频加速标准。OpenSL ES 是无授权费、跨平台、针对嵌入式系统精心优化的硬件音频加速 API ，它能为嵌入式移动多媒体设备上的本地应用程序开发者提供了标准化、高性能、低响应时间的音频功能实现方法，同时还实现了软/硬音频性能的直接跨平台部署，不仅降低了执行难度，而且还促进了高级音频市场的发展。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200209133557.png" alt=""></p>
<p>上图描述了 OpenSL ES 的架构，在 Android 中，High Level Audio Libs 是音频 Java 层 API 输入输出，属于高级 API , 相对来说，OpenSL ES 则是比价低层级的 API, 属于 C 语言 API 。在开发中，一般会直接使用高级 API , 除非遇到性能瓶颈，如语音实时聊天、3D Audio 、某些 Effects 等，开发者可以直接通过 C/C++ 开发基于 OpenSL ES 音频的应用。</p>
<p>在使用 OpenSL ES 的 API 之前，需要引入 OpenSL ES 的头文件，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是标准的OpenSL ES库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SLES/OpenSLES.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这里是针对安卓的扩展，如果要垮平台则需要注意</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SLES/OpenSLES_Android.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建引擎并获取引擎接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 音频的播放，就涉及到了，OpenLSES</span></span><br><span class="line">        <span class="comment">// TODO 第一大步：创建引擎并获取引擎接口</span></span><br><span class="line">        <span class="comment">// 1.1创建引擎对象：SLObjectItf engineObject</span></span><br><span class="line">        SLresult result = slCreateEngine(&amp;engineObj, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 初始化引擎</span></span><br><span class="line">        result = (*engineObj) -&gt;Realize(engineObj, SL_BOOLEAN_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (SL_BOOLEAN_FALSE != result) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3 获取引擎接口 SLEngineItf engineInterface</span></span><br><span class="line">        result = (*engineObj) -&gt;GetInterface(engineObj, SL_IID_ENGINE, &amp;engine);</span><br><span class="line">        <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>设置混音器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 第二大步 设置混音器</span></span><br><span class="line">        <span class="comment">// 2.1 创建混音器：SLObjectItf outputMixObject</span></span><br><span class="line">        result = (*engine)-&gt;CreateOutputMix(engine, &amp;outputMixObj, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 初始化 混音器</span></span><br><span class="line">        result = (*outputMixObj)-&gt;Realize(outputMixObj, SL_BOOLEAN_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (SL_BOOLEAN_FALSE != result) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建播放器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 第三大步 创建播放器</span></span><br><span class="line">    <span class="comment">// 3.1 配置输入声音信息</span></span><br><span class="line">    <span class="comment">// 创建buffer缓冲类型的队列 2个队列</span></span><br><span class="line">    SLDataLocator_AndroidSimpleBufferQueue locBufq = &#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// pcm数据格式</span></span><br><span class="line">    <span class="comment">// SL_DATAFORMAT_PCM：数据格式为pcm格式</span></span><br><span class="line">    <span class="comment">// 2：双声道</span></span><br><span class="line">    <span class="comment">// SL_SAMPLINGRATE_44_1：采样率为44100（44.1赫兹 应用最广的，兼容性最好的）</span></span><br><span class="line">    <span class="comment">// SL_PCMSAMPLEFORMAT_FIXED_16：采样格式为16bit （16位）(2个字节)</span></span><br><span class="line">    <span class="comment">// SL_PCMSAMPLEFORMAT_FIXED_16：数据大小为16bit （16位）（2个字节）</span></span><br><span class="line">    <span class="comment">// SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT：左右声道（双声道）  （双声道 立体声的效果）</span></span><br><span class="line">    <span class="comment">// SL_BYTEORDER_LITTLEENDIAN：小端模式</span></span><br><span class="line">    SLDataFormat_PCM formatPcm = &#123;SL_DATAFORMAT_PCM, (SLuint32) mChannels, mSampleRate,</span><br><span class="line">                                  (SLuint32) mSampleFormat, (SLuint32) mSampleFormat,</span><br><span class="line">                                  mChannels == <span class="number">2</span> ? <span class="number">0</span> : SL_SPEAKER_FRONT_CENTER,</span><br><span class="line">                                  SL_BYTEORDER_LITTLEENDIAN&#125;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Enable Fast Audio when possible:  once we set the same rate to be the native, fast audio path</span></span><br><span class="line"><span class="comment">     * will be triggered</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mSampleRate) &#123;</span><br><span class="line">        formatPcm.samplesPerSec = mSampleRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据源 将上述配置信息放到这个数据源中</span></span><br><span class="line">    SLDataSource audioSrc = &#123;&amp;locBufq, &amp;formatPcm&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 配置音轨（输出）</span></span><br><span class="line">    <span class="comment">// 设置混音器</span></span><br><span class="line">    SLDataLocator_OutputMix locOutpuMix = &#123;SL_DATALOCATOR_OUTPUTMIX, mAudioEngine-&gt;outputMixObj&#125;;</span><br><span class="line">    SLDataSink audioSink = &#123;&amp;locOutpuMix, <span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create audio player:</span></span><br><span class="line"><span class="comment">     *     fast audio does not support when SL_IID_EFFECTSEND is required, skip it</span></span><br><span class="line"><span class="comment">     *     for fast audio case</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//  需要的接口 操作队列的接口</span></span><br><span class="line">    <span class="keyword">const</span> SLInterfaceID ids[<span class="number">3</span>] = &#123;SL_IID_BUFFERQUEUE, SL_IID_VOLUME, SL_IID_EFFECTSEND&#125;;</span><br><span class="line">    <span class="keyword">const</span> SLboolean req[<span class="number">3</span>] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.3 创建播放器</span></span><br><span class="line">    result = (*mAudioEngine-&gt;engine)-&gt;CreateAudioPlayer(mAudioEngine-&gt;engine, &amp;mPlayerObj,</span><br><span class="line">                                                        &amp;audioSrc, &amp;audioSink,</span><br><span class="line">                                                        mSampleRate ? <span class="number">2</span> : <span class="number">3</span>, ids, req);</span><br><span class="line">    <span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">        LOGE(<span class="string">"CreateAudioPlayer failed: %d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.4 初始化播放器：mPlayerObj</span></span><br><span class="line">    result = (*mPlayerObj)-&gt;Realize(mPlayerObj, SL_BOOLEAN_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">        LOGE(<span class="string">"mPlayerObj Realize failed: %d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  3.5 获取播放器接口：SLPlayItf mPlayerObj</span></span><br><span class="line">    result = (*mPlayerObj)-&gt;GetInterface(mPlayerObj, SL_IID_PLAY, &amp;mPlayer);</span><br><span class="line">    <span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">        LOGE(<span class="string">"mPlayerObj GetInterface failed: %d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置播放回调函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 第四大步：设置播放回调函数</span></span><br><span class="line">    <span class="comment">// 4.1 获取播放器队列接口：SLAndroidSimpleBufferQueueItf mBufferQueue</span></span><br><span class="line">    result = (*mPlayerObj)-&gt;GetInterface(mPlayerObj, SL_IID_BUFFERQUEUE, &amp;mBufferQueue);</span><br><span class="line">    <span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">        LOGE(<span class="string">"mPlayerObj GetInterface failed: %d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 4.2 设置回调 void playerCallback(SLAndroidSimpleBufferQueueItf bq, void *context)</span></span><br><span class="line">    result = (*mBufferQueue)-&gt;RegisterCallback(mBufferQueue, playerCallback, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">        LOGE(<span class="string">"mPlayerObj RegisterCallback failed: %d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEffectSend = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSampleRate == <span class="number">0</span>) &#123;</span><br><span class="line">        result = (*mPlayerObj)-&gt;GetInterface(mPlayerObj, SL_IID_EFFECTSEND, &amp;mEffectSend);</span><br><span class="line">        <span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">            LOGE(<span class="string">"mPlayerObj GetInterface failed: %d"</span>, result);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = (*mPlayerObj)-&gt;GetInterface(mPlayerObj, SL_IID_VOLUME, &amp;mVolume);</span><br><span class="line">    <span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">        LOGE(<span class="string">"mPlayerObj GetInterface failed: %d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置播放器状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 第五大步：设置播放器状态为播放状态</span></span><br><span class="line">result = (*mPlayer)-&gt;SetPlayState(mPlayer, SL_PLAYSTATE_PLAYING);</span><br><span class="line"><span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"mPlayerObj SetPlayState failed: %d"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>手动激活回调函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OpenSLAudioPlay::enqueueSample</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须等待一帧音频播放完毕后才可以 Enqueue 第二帧音频</span></span><br><span class="line">    pthread_mutex_lock(&amp;mMutex);</span><br><span class="line">    <span class="keyword">if</span> (mBufSize &lt; length) &#123;</span><br><span class="line">        mBufSize = length;</span><br><span class="line">        <span class="keyword">if</span> (mBuffers[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] mBuffers[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBuffers[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] mBuffers[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        mBuffers[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[mBufSize];</span><br><span class="line">        mBuffers[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[mBufSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(mBuffers[mIndex], data, length);</span><br><span class="line">    <span class="comment">// TODO 第六步：手动激活回调函数</span></span><br><span class="line">    (*mBufferQueue)-&gt;Enqueue(mBufferQueue, mBuffers[mIndex], length);</span><br><span class="line">    mIndex = <span class="number">1</span> - mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_devyk_audioplay_AudioPlayActivity_nativeStopPcm(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    isPlaying = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (slAudioPlayer) &#123;</span><br><span class="line">        slAudioPlayer-&gt;<span class="built_in">release</span>();</span><br><span class="line">        <span class="keyword">delete</span> slAudioPlayer;</span><br><span class="line">        slAudioPlayer = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pcmFile) &#123;</span><br><span class="line">        fclose(pcmFile);</span><br><span class="line">        pcmFile = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>完整的代码请参考仓库中 <a href="https://github.com/yangkun19921001/ndk_study/blob/master/audioplay/src/main/cpp/audio_play.cpp">OpenSL ES</a>部分。注意：需要把 raw 中的 pcm 文件放入 sdcard 根目录下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该篇文章主要介绍了音频的一些基础知识和使用 AudioTrack 以及 OpenSL ES 来渲染裸流音频数据。大家可以根据我的源代码中在加深理解。</p>
<p>最后的页面效果:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200209165845.png" alt=""></p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li><a href="https://github.com/zhanxiaokai">音视频开发进阶指南-展晓凯</a></li>
<li><a href="https://www.jianshu.com/p/5513a181580f">https://www.jianshu.com/p/5513a181580f</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:11:00.000Z" title="2020-06-04T10:11:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">29 分钟 读完 (大约 4329 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AD-FFmpeg-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">音视频学习 (六) FFmpeg 交叉编译</a></h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200115141001.jpeg" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        该篇文章起就正式进入音视频学习了，在进入音视频学习之前我们必须要先学习 FFmpeg 这个库，这个库非常强大，强大到什么地步呢 ？可以说只要做音视频的没有人不了解它，包括国内外一些比较出名的播放器也用到了 FFmpeg 这个库。</p>
<h2 id="FFmpeg-定义"><a href="#FFmpeg-定义" class="headerlink" title="FFmpeg 定义"></a>FFmpeg 定义</h2><p>​        FFmpeg 既是一款音视频编解码工具，同时也是一组音视频编解码开发套件，作为编解码开发套件，他为开发者提供了丰富的音视频处理的调用接口。</p>
<p>​        FFmpeg 提供了多种媒体格式的封装和解封装，包括多种音视频编码、多种协议的流媒体、多种色彩格式转换、多种采样率转换、多种码率转换等; FFmpeg 框架提供了多种丰富的插件模块，包含封装与解封转的插件、编码与解码的插件等。</p>
<h2 id="FFmpeg-历史"><a href="#FFmpeg-历史" class="headerlink" title="FFmpeg 历史"></a>FFmpeg 历史</h2><p>​        FFmpeg 由法国天才程序员 <strong>Fabrice Bellard</strong> 在 2000 年的时开发出初版；后来发展到 2004 年， <strong>Fabrice Bellard</strong> 找到了接手人，这个人至今还在维护 FFmpeg 的 Michael Niedermayer 。Michael Niedermayer 对 FFmpeg 的贡献非常大，其将滤镜子系统 libavfilter 加入 FFmpeg 项目中，使得 FFmpeg 的多媒体处理更加多样、更加方便。在 FFmpeg 发布了 0.5 版本之后，很长一段时间没有进行新版本的发布，直到后来 FFmpeg 采用了 Git 作为版本控制服务器以后才开始继续进行代码更新、版本发布，当然也是时隔多年之后了；2011 年 3 月，在 FFmpeg 项目中有一些提交者对 FFmpeg的项目管理方式并不满意，因而重新创建了一个新的项目，命名为 Libav, 该项目尽管至今并没有 FFmpeg 发展这么迅速，但是提交权限相对 FFmpeg 更加开放；2015 年 8 月，Michael Niedermayer 主动辞去 FFmpeg 项目负责人的职务。Michael Niedermayter 从 Libav 中移植了大量的代码和功能到 FFmpeg 中，Michael Niedermayter 辞职的主要目的是希望两个项目最终能够一起发展，若能够合并则更好。时至今日，在大多数的 Linux 发行版本系统中已经使用 FFmpeg 来进行多媒体处理。</p>
<p>FFmpeg 可以通过以下方式自由获取源代码，具体方式如下:</p>
<ul>
<li><a href="https://www.ffmpeg.org/">官方网站</a></li>
<li><a href="http://git.videolan.org/?p=ffmpeg.git">http://git.videolan.org/?p=ffmpeg.git</a></li>
<li><a href="https://github.com/FFmpeg/FFmpeg">GitHub</a></li>
</ul>
<h2 id="FFmpeg-模块介绍"><a href="#FFmpeg-模块介绍" class="headerlink" title="FFmpeg 模块介绍"></a>FFmpeg 模块介绍</h2><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200114221739.png" alt=""></p>
<p>​        FFmpeg 框架的基本组成包含 libavcodec 、libavformat、libavfilter、libavdevice 、libavutil 等模块。</p>
<p>下面针对这些模块做一个大概的介绍。</p>
<ul>
<li><p><strong>libavcodec:</strong> </p>
<p>编解码库，封装了 Codec 层，但是有一些 codec 是具备自己的 License 的，FFmpeg 不会默认添加像 libx264、FDK-AAC、Lame 等库，但是 FFmpeg 像一个平台，可以将其他的第三方codec以插件的方式添加进来，为开发者提供统一接口</p>
</li>
<li><p><strong>libavformat:</strong></p>
<p>文件格式和协议库，封装了 Protocol 层和 Demuxer、Muxer 层，使得协议和格式对于开发者来说是透明的</p>
</li>
<li><p><strong>libavfilter:</strong></p>
<p>音视频滤镜库，该模块包含了音频特效和视频特效的处理，在使用 FFmpeg 的 API 进行编解码的过程中，可以使用该模块高效的为音视频数据做特效处理</p>
</li>
<li><p><strong>libavdevice:</strong></p>
<p>输入输出设备库，比如需要编译出播放声音或者视频的工具 ffplay，就需要确保该模块是打开的，同事也需要 libsdl 的预先编译，该设备模块播放声音和视频都又是使用libsdl 库</p>
</li>
<li><p><strong>libavutil:</strong> </p>
<p>核心工具库，最基础模块之一，其他模块都会依赖该库做一些基本的音视频处理操作</p>
</li>
<li><p><strong>libswresample:</strong></p>
<p>用于音频重采样，可以对数字音频进行声道数、数据格式、采样率等多种基本信息的转换</p>
</li>
<li><p><strong>libswscale</strong></p>
<p>该模块用于图像格式转换，可以将 YUV 的数据转换为 RGB 的数据</p>
</li>
<li><p><strong>libpostproc</strong></p>
<p>该模块用于进行后期处理，当我们使用filter的时候，需要打开这个模块，filter会用到这个模块的一些基础函数</p>
<p>比较老的 ffmpeg 还会编译出 avresamle 模块，也是用于对音频原始出具进行重采样的，但是已经被废弃，推荐使用 libswresample 替代</p>
<p>另外，库里还可以包含对 H.264/MPEG-4 AVC 视频编码的 X264 库，是最常用的有损视频编码器，支持 CBR、VBR 模式，可以在编码的过程中直接改变码率的设置，在直播的场景中非常适用！可以做码率自适应的功能。</p>
</li>
</ul>
<h2 id="下载-FFmpeg"><a href="#下载-FFmpeg" class="headerlink" title="下载 FFmpeg"></a>下载 FFmpeg</h2><p><a href="https://www.ffmpeg.org/download.html">FFmpeg 官网</a> 直接下载源码方式</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200114232135.png" alt=""></p>
<p>在 linux 环境中，命令下载:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 命令下载</span><br><span class="line">wget https:&#x2F;&#x2F;ffmpeg.org&#x2F;releases&#x2F;ffmpeg-4.2.2.tar.bz2</span><br><span class="line">&#x2F;&#x2F;2. 安装解压缩工具</span><br><span class="line">yum -y install bzip2</span><br><span class="line">&#x2F;&#x2F;3. 解压 FFmpeg </span><br><span class="line">tar -jxvf ffmpeg-4.2.2.tar.bz2</span><br></pre></td></tr></table></figure>

<h2 id="编译-FFmpeg"><a href="#编译-FFmpeg" class="headerlink" title="编译 FFmpeg"></a>编译 FFmpeg</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><ul>
<li>ffmpeg-4.2.2</li>
<li>Centos 7</li>
<li>android-ndk-r17c-linux-x86_64.zip</li>
</ul>
<h3 id="configure-脚本介绍"><a href="#configure-脚本介绍" class="headerlink" title="configure 脚本介绍"></a>configure 脚本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">帮组选项</span></span><br><span class="line">Help options:</span><br><span class="line">  --help                   print this message</span><br><span class="line">  --quiet                  Suppress showing informative output</span><br><span class="line">  --list-decoders          show all available decoders</span><br><span class="line">  --list-encoders          show all available encoders</span><br><span class="line">  --list-hwaccels          show all available hardware accelerators</span><br><span class="line">  --list-demuxers          show all available demuxers</span><br><span class="line">  --list-muxers            show all available muxers</span><br><span class="line">  --list-parsers           show all available parsers</span><br><span class="line">  --list-protocols         show all available protocols</span><br><span class="line">  --list-bsfs              show all available bitstream filters</span><br><span class="line">  --list-indevs            show all available input devices</span><br><span class="line">  --list-outdevs           show all available output devices</span><br><span class="line">  --list-filters           show all available filters</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">标准选项</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--<span class="built_in">disable</span>  代表关闭状态 ；--<span class="built_in">enable</span>   代表开启状态</span></span><br><span class="line">Standard options:</span><br><span class="line">  --logfile=FILE           log tests and output to FILE [ffbuild/config.log]</span><br><span class="line">  --disable-logging        do not log configure debug information</span><br><span class="line">  --fatal-warnings         fail if any configure warning is generated</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash">我们最终编译好的动态静态库位置，必须设置</span></span><br><span class="line">  --prefix=PREFIX          install in PREFIX [$prefix_default]</span><br><span class="line">  </span><br><span class="line">  --bindir=DIR             install binaries in DIR [PREFIX/bin]</span><br><span class="line">  --datadir=DIR            install data files in DIR [PREFIX/share/ffmpeg]</span><br><span class="line">  --docdir=DIR             install documentation in DIR [PREFIX/share/doc/ffmpeg]</span><br><span class="line">  --libdir=DIR             install libs in DIR [PREFIX/lib]</span><br><span class="line">  --shlibdir=DIR           install shared libs in DIR [LIBDIR]</span><br><span class="line">  --incdir=DIR             install includes in DIR [PREFIX/include]</span><br><span class="line">  --mandir=DIR             install man page in DIR [PREFIX/share/man]</span><br><span class="line">  --pkgconfigdir=DIR       install pkg-config files in DIR [LIBDIR/pkgconfig]</span><br><span class="line">  --enable-rpath           use rpath to allow installing libraries in paths</span><br><span class="line">                           not part of the dynamic linker search path</span><br><span class="line">                           use rpath when linking programs (USE WITH CARE)</span><br><span class="line">  --install-name-dir=DIR   Darwin directory name for installed targets</span><br><span class="line"></span><br><span class="line">Licensing options:</span><br><span class="line">  --enable-gpl             allow use of GPL code, the resulting libs</span><br><span class="line">                           and binaries will be under GPL [no]</span><br><span class="line">  --enable-version3        upgrade (L)GPL to version 3 [no]</span><br><span class="line">  --enable-nonfree         allow use of nonfree code, the resulting libs</span><br><span class="line">                           and binaries will be unredistributable [no]</span><br><span class="line"></span><br><span class="line">Configuration options:</span><br><span class="line"><span class="meta">#</span><span class="bash">开启静态库</span></span><br><span class="line">  --disable-static         do not build static libraries [no]</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭动态库</span></span><br><span class="line">  --enable-shared          build shared libraries [no</span><br><span class="line"><span class="meta">#</span><span class="bash">可以优化库的大小</span></span><br><span class="line">  --enable-small           optimize for size instead of speed</span><br><span class="line">  --disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary)</span><br><span class="line">  --enable-gray            enable full grayscale support (slower color)</span><br><span class="line">  --disable-swscale-alpha  disable alpha channel support in swscale</span><br><span class="line">  --disable-all            disable building components, libraries and programs</span><br><span class="line">  --disable-autodetect     disable automatically detected external libraries [no]</span><br><span class="line"></span><br><span class="line">Program options:</span><br><span class="line"><span class="meta">#</span><span class="bash">我们不需要使用程序，不需要在Windows中执行，某.exe程序，我们只需要在代码中使用  [此命令操作的是下面三项]</span></span><br><span class="line">  --disable-programs       do not build command line programs</span><br><span class="line"><span class="meta">  #</span><span class="bash">使用FFmpeg命令</span></span><br><span class="line">  --disable-ffmpeg         disable ffmpeg build</span><br><span class="line"><span class="meta">  #</span><span class="bash">播放器</span></span><br><span class="line">  --disable-ffplay         disable ffplay build</span><br><span class="line">  --disable-ffprobe        disable ffprobe build</span><br><span class="line"></span><br><span class="line">Documentation options:</span><br><span class="line">  --disable-doc            do not build documentation</span><br><span class="line">  --disable-htmlpages      do not build HTML documentation pages</span><br><span class="line">  --disable-manpages       do not build man documentation pages</span><br><span class="line">  --disable-podpages       do not build POD documentation pages</span><br><span class="line">  --disable-txtpages       do not build text documentation pages</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">模块选项</span></span><br><span class="line">Component options:</span><br><span class="line"><span class="meta">#</span><span class="bash">可以操控我们的摄像头-（Android中是不支持））</span></span><br><span class="line">  --disable-avdevice       disable libavdevice build</span><br><span class="line"><span class="meta">#</span><span class="bash">audio video codec(编码 和 解码)</span></span><br><span class="line">  --disable-avcodec        disable libavcodec build</span><br><span class="line"><span class="meta">#</span><span class="bash">音视频格式生成和解析相关</span></span><br><span class="line">  --disable-avformat       disable libavformat build</span><br><span class="line"><span class="meta">#</span><span class="bash">音频重采样（如果想把单声道，变成双声道）</span></span><br><span class="line">  --disable-swresample     disable libswresample build</span><br><span class="line"><span class="meta">#</span><span class="bash">对视频显示相关（对视频的缩放，放大 缩小）</span></span><br><span class="line">  --disable-swscale        disable libswscale build</span><br><span class="line"><span class="meta">#</span><span class="bash">后期处理，很少用，可以关闭掉</span></span><br><span class="line">  --disable-postproc       disable libpostproc build</span><br><span class="line"><span class="meta">#</span><span class="bash">给视频加水印，加字幕，特殊效果</span></span><br><span class="line">  --disable-avfilter       disable libavfilter build</span><br><span class="line">  --enable-avresample      enable libavresample build (deprecated) [no]</span><br><span class="line">  --disable-pthreads       disable pthreads [autodetect]</span><br><span class="line">  --disable-w32threads     disable Win32 threads [autodetect]</span><br><span class="line">  --disable-os2threads     disable OS/2 threads [autodetect]</span><br><span class="line">  --disable-network        disable network support [no]</span><br><span class="line">  --disable-dct            disable DCT code</span><br><span class="line">  --disable-dwt            disable DWT code</span><br><span class="line">  --disable-error-resilience disable error resilience code</span><br><span class="line">  --disable-lsp            disable LSP code</span><br><span class="line">  --disable-lzo            disable LZO decoder code</span><br><span class="line">  --disable-mdct           disable MDCT code</span><br><span class="line">  --disable-rdft           disable RDFT code</span><br><span class="line">  --disable-fft            disable FFT code</span><br><span class="line">  --disable-faan           disable floating point AAN (I)DCT code</span><br><span class="line">  --disable-pixelutils     disable pixel utils in libavutil</span><br><span class="line"></span><br><span class="line">Individual component options:</span><br><span class="line">  --disable-everything     disable all components listed below</span><br><span class="line">  --disable-encoder=NAME   disable encoder NAME</span><br><span class="line">  --enable-encoder=NAME    enable encoder NAME</span><br><span class="line"><span class="meta">#</span><span class="bash">编码可以去关闭掉</span></span><br><span class="line">  --disable-encoders       disable all encoders</span><br><span class="line">  --disable-decoder=NAME   disable decoder NAME</span><br><span class="line">  --enable-decoder=NAME    enable decoder NAME</span><br><span class="line">  --disable-decoders       disable all decoders</span><br><span class="line">  --disable-hwaccel=NAME   disable hwaccel NAME</span><br><span class="line">  --enable-hwaccel=NAME    enable hwaccel NAME</span><br><span class="line">  --disable-hwaccels       disable all hwaccels</span><br><span class="line">  --disable-muxer=NAME     disable muxer NAME</span><br><span class="line">  --enable-muxer=NAME      enable muxer NAME</span><br><span class="line"><span class="meta">  #</span><span class="bash">混合封装（音视频等于 一段音频 一段视频 合并在一起 就是.mp4，不想这样就可以关闭）</span></span><br><span class="line">  --disable-muxers         disable all muxers</span><br><span class="line">  --disable-demuxer=NAME   disable demuxer NAME</span><br><span class="line">  --enable-demuxer=NAME    enable demuxer NAME</span><br><span class="line">  --disable-demuxers       disable all demuxers</span><br><span class="line">  --enable-parser=NAME     enable parser NAME</span><br><span class="line">  --disable-parser=NAME    disable parser NAME</span><br><span class="line">  --disable-parsers        disable all parsers</span><br><span class="line">  --enable-bsf=NAME        enable bitstream filter NAME</span><br><span class="line">  --disable-bsf=NAME       disable bitstream filter NAME</span><br><span class="line">  --disable-bsfs           disable all bitstream filters</span><br><span class="line">  --enable-protocol=NAME   enable protocol NAME</span><br><span class="line">  --disable-protocol=NAME  disable protocol NAME</span><br><span class="line">  --disable-protocols      disable all protocols</span><br><span class="line">  --enable-indev=NAME      enable input device NAME</span><br><span class="line">  --disable-indev=NAME     disable input device NAME</span><br><span class="line">  --disable-indevs         disable input devices</span><br><span class="line">  --enable-outdev=NAME     enable output device NAME</span><br><span class="line">  --disable-outdev=NAME    disable output device NAME</span><br><span class="line">  --disable-outdevs        disable output devices</span><br><span class="line">  --disable-devices        disable all devices</span><br><span class="line">  --enable-filter=NAME     enable filter NAME</span><br><span class="line">  --disable-filter=NAME    disable filter NAME</span><br><span class="line">  --disable-filters        disable all filters</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="编写-32-64-位-FFmpeg4-2-2-shell-脚本"><a href="#编写-32-64-位-FFmpeg4-2-2-shell-脚本" class="headerlink" title="编写 32/64 位 FFmpeg4.2.2 shell 脚本"></a>编写 32/64 位 FFmpeg4.2.2 shell 脚本</h3><h4 id="ndk20b-ffmpeg4-2-2-clang-编译脚本"><a href="#ndk20b-ffmpeg4-2-2-clang-编译脚本" class="headerlink" title="ndk20b+ffmpeg4.2.2 clang 编译脚本"></a>ndk20b+ffmpeg4.2.2 clang 编译脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译硬件解码版本 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 注意：该编译环境目前只在 NDK20b + ffmpeg4.2.2 测试过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 注意：该编译环境目前只在 NDK20b + ffmpeg4.2.2 测试过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">你自己的NDK路径.</span></span><br><span class="line">export NDK=/root/android/ndk/android-ndk-r20b</span><br><span class="line">TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function build_android</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo "开始编译 $CPU"</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-neon  \</span><br><span class="line">--enable-hwaccels  \</span><br><span class="line">--enable-gpl   \</span><br><span class="line">--enable-postproc \</span><br><span class="line">--enable-shared \</span><br><span class="line">--disable-debug \</span><br><span class="line">--enable-small \</span><br><span class="line">--enable-jni \</span><br><span class="line">--enable-mediacodec \</span><br><span class="line">--enable-decoder=h264_mediacodec \</span><br><span class="line">--disable-static \</span><br><span class="line">--disable-doc \</span><br><span class="line">--enable-ffmpeg \</span><br><span class="line">--disable-ffplay \</span><br><span class="line">--disable-ffprobe \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-doc \</span><br><span class="line">--disable-symver \</span><br><span class="line">--cross-prefix=$CROSS_PREFIX \</span><br><span class="line">--target-os=android \</span><br><span class="line">--arch=$ARCH \</span><br><span class="line">--cpu=$CPU \</span><br><span class="line">--cc=$CC \</span><br><span class="line">--cxx=$CXX \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--sysroot=$SYSROOT \</span><br><span class="line">--extra-cflags="-Os -fpic $OPTIMIZE_CFLAGS" \</span><br><span class="line">--extra-ldflags="$ADDI_LDFLAGS"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">echo "编译成功 $CPU"</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">armv8<span class="_">-a</span></span></span><br><span class="line">ARCH=arm64</span><br><span class="line">CPU=armv8-a</span><br><span class="line">API=21</span><br><span class="line">CC=$TOOLCHAIN/bin/aarch64-linux-android$API-clang</span><br><span class="line">CXX=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++</span><br><span class="line">SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot</span><br><span class="line">CROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-</span><br><span class="line">PREFIX=$(pwd)/android/$CPU</span><br><span class="line">OPTIMIZE_CFLAGS="-march=$CPU"</span><br><span class="line"></span><br><span class="line">build_android</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">armv7<span class="_">-a</span></span></span><br><span class="line">ARCH=arm</span><br><span class="line">CPU=armv7-a</span><br><span class="line">API=16</span><br><span class="line">CC=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang</span><br><span class="line">CXX=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang++</span><br><span class="line">SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot</span><br><span class="line">CROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-androideabi-</span><br><span class="line">PREFIX=$(pwd)/android/$CPU</span><br><span class="line">OPTIMIZE_CFLAGS="-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU "</span><br><span class="line"></span><br><span class="line">build_android</span><br></pre></td></tr></table></figure>



<h4 id="ndk17c-ffmpeg4-2-2-gcc编译脚本"><a href="#ndk17c-ffmpeg4-2-2-gcc编译脚本" class="headerlink" title="ndk17c + ffmpeg4.2.2 gcc编译脚本"></a><strong>ndk17c + ffmpeg4.2.2 gcc编译脚本</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译软件解码版本 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 注意：该编译环境目前只在 NDK17c + ffmpeg4.2.2 测试过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br><span class="line">echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 注意：该编译环境目前只在 NDK17c + ffmpeg4.2.2 测试过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">NDK_ROOT 变量指向 ndk 目录</span></span><br><span class="line">NDK_ROOT=$NDK_HOME</span><br><span class="line"><span class="meta">#</span><span class="bash">指定android api版本</span></span><br><span class="line">ANDROID_API=21</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">开始编译 在下面调用传入参数即可</span></span><br><span class="line">function build_ffmpeg</span><br><span class="line">&#123;</span><br><span class="line">echo "开始编译 $PREFIX_CPU"</span><br><span class="line">echo "开始编译 $PREFIX"</span><br><span class="line">echo "开始编译 $TOOLCHAIN"</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--disable-doc \</span><br><span class="line">--disable-yasm \</span><br><span class="line">--disable-asm \</span><br><span class="line">--disable-symver \</span><br><span class="line">--enable-gpl \</span><br><span class="line">--disable-ffplay \</span><br><span class="line">--disable-ffmpeg \</span><br><span class="line">--disable-ffprobe \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$CROSS_PREFIX \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-$ARCH \</span><br><span class="line">--extra-cflags="$CFLAGES" \</span><br><span class="line">--arch=$ARCH \</span><br><span class="line">--target-os=android</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">上面运行脚本生成makefile之后，使用make执行脚本</span></span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">echo "$PREFIX_CPU 编译完成"</span><br><span class="line">echo "$PREFIX_CPU 编译完成"</span><br><span class="line">echo "$PREFIX_CPU 编译完成"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">armeabi-v7a</span></span><br><span class="line">PREFIX=./result/armeabi-v7a</span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><span class="line">ARCH=arm</span><br><span class="line">CROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-androideabi-</span><br><span class="line">CFLAGES="-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS  -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC"</span><br><span class="line"></span><br><span class="line">build_ffmpeg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">arm64-v8a</span></span><br><span class="line">PREFIX=./result/arm64-v8a</span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64</span><br><span class="line">ARCH=arm64</span><br><span class="line">CROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-</span><br><span class="line">CFLAGES="-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS  -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC"</span><br><span class="line"></span><br><span class="line">build_ffmpeg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">直接跳转到编译完成的路径</span></span><br><span class="line">cd /result</span><br></pre></td></tr></table></figure>



<p><strong>编译遇见的坑:</strong></p>
<ol>
<li><p>arm-linux-androideabi-gcc is unable to create an executable file</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200115101836.png" alt=""></p>
<p>原因 1：<br>FFmpeg 4.2.2 版本默认使用了 clang 进行编译</p>
<p>解决：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1. 修改 configure 文件</span><br><span class="line">vim configure</span><br><span class="line">//2. 把 默认的 clang 修改为 gcc</span><br><span class="line">if test "$target_os" = android; then</span><br><span class="line"><span class="meta">   #</span><span class="bash"> cc_default=<span class="string">"clang"</span></span></span><br><span class="line">		 cc_default="gcc"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>原因 2：</p>
<p>检查路径是否正确</p>
</li>
<li><p>nasm/yasm not found or too old. Use –disable-x86asm for a crippled build.</p>
<p>分析：yasm 是汇编编译器，ffmpeg 为了提高效率使用了汇编指令，如 MMX 和 SSE等。</p>
<p>所以系统中未安装yasm时，就会报上面错误。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">解决错误：安装yasm编译器。安装方法如下：</span><br><span class="line"></span><br><span class="line">1）下载：[yasm的下载链接]</span><br><span class="line">wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz</span><br><span class="line"></span><br><span class="line">2）解压：把下载下来的压缩包进行解压</span><br><span class="line">tar -zxvf yasm-1.3.0.tar.gz</span><br><span class="line"></span><br><span class="line">3）切换路径： </span><br><span class="line">cd yasm-1.3.0</span><br><span class="line"></span><br><span class="line">4）执行配置： </span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">5）编译：</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">6）安装：</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决 “ lib64 libc so 6 version `GLIBC_2 18’ not found (required by lib…</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://ftp.gnu.org/gnu/glibc/glibc-2.18.tar.gz</span><br><span class="line">tar zxf glibc-2.18.tar.gz </span><br><span class="line">cd glibc-2.18/</span><br><span class="line">mkdir build</span><br><span class="line">cd build/</span><br><span class="line">../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin</span><br><span class="line"></span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">安装完成后，查看是否成功</span><br><span class="line">ll /lib64/libc*</span><br><span class="line"></span><br><span class="line">然后可以继续查看 glibc 支持的版本</span><br><span class="line">strings /lib64/libc.so.6 | grep GLIBC</span><br><span class="line"></span><br><span class="line">//------------------------------------------------------------</span><br><span class="line">//下面可以不用参考，这个是我在升级 glibc 的时候把 libc-2.17.so 给误删除了，导致基本上瘫痪了，可以使用以下命令恢复</span><br><span class="line">//ll cp 等命令失效请用以下进行软连接   </span><br><span class="line">LD_PRELOAD=/lib64/libc-2.17.so ln -s /lib64/libc-2.17.so /lib64/libc.so.6</span><br><span class="line">//如果不小心定义了错误环境变量可以通过以下命令删除</span><br><span class="line">unset LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>config.mak 文件没有生成</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200115101946.png" alt=""></p>
<p>解决：<br>执行<code>./configure --disable-x86asm</code> 生成 config.mak 文件</p>
<p><a href="https://www.laoyuyu.me/2019/05/23/android/clang_compile_ffmpeg/">更多坑错误请点击此处查看</a></p>
<p>错误解决完之后，按下回车键，如果出现如下输出，就开始在编译了:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200115101504.jpg" alt=""></p>
<p>大概等 10 分钟左右就会编译完成，如下所示就代表编译静态库成功了:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200115120011.gif" alt=""></p>
</li>
</ol>
<p>如果想编译动态库，仅仅修改下参数就行了，如下所示:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启动态库</span></span><br><span class="line">--enable-shared \</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭静态库</span></span><br><span class="line">--disable-static \</span><br></pre></td></tr></table></figure>

<p>压缩:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf ffmpeg_android.tar.gz android</span><br></pre></td></tr></table></figure>

<p>利用 <strong>FileZill 工具</strong> 从服务器端把编译好的静态文件导出到电脑本地，导出完之后我们就在 AS 中测试编译的 .a 文件是否有误。</p>
<h2 id="Android-集成交叉编译之后的-FFmpeg-静态库"><a href="#Android-集成交叉编译之后的-FFmpeg-静态库" class="headerlink" title="Android 集成交叉编译之后的 FFmpeg 静态库"></a>Android 集成交叉编译之后的 FFmpeg 静态库</h2><ol>
<li><p>创建一个 C/C++ 项目的 Android 工程，并把编译好的静态库导入项目中，如下结构:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200115134201.png" alt=""></p>
</li>
<li><p>编写 JNI 代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有坑，会报错，必须混合编译</span></span><br><span class="line"><span class="comment">//#include &lt;libavutil/avutil.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拿到 ffmpeg 当前版本</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getFFmpegVer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> av_version_info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_devyk_ffmpeg_MainActivity_getFFmpegVersion(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(getFFmpegVer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 CMakeLists.txt 脚本</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定 Cmake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到包含所有的cpp文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB allCpp *.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印当前 cmakeLists 的路径</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">"当前cmakel路径: $&#123;CMAKE_SOURCE_DIR&#125; \n cpu架构：$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        ffmpeg_lib</span><br><span class="line"></span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        <span class="variable">$&#123;allCpp&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(</span><br><span class="line">        log-lib</span><br><span class="line"></span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入FFmpeg的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入FFmpeg的库文件，设置内部的方式引入，指定库的目录是 -L  指定具体的库-l</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        ffmpeg_lib</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 具体的库文件，链接到总库</span></span><br><span class="line">        <span class="comment"># 这样写会报错，有坑</span></span><br><span class="line">        <span class="comment"># avcodec avfilter avformat avutil swresample swscale</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先把有依赖的库，先依赖进来</span></span><br><span class="line">        avformat avcodec avfilter avutil swresample swscale</span><br><span class="line"></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>app/build.gradle 配置</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">29</span></span><br><span class="line">    buildToolsVersion <span class="string">"29.0.2"</span></span><br><span class="line">  	...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">      ...</span><br><span class="line">        externalNativeBuild()&#123;</span><br><span class="line">            cmake&#123;</span><br><span class="line">                abiFilters <span class="string">"armeabi-v7a"</span> <span class="comment">//指定编译为 armeabi-v7a</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    externalNativeBuild()&#123;</span><br><span class="line">        cmake&#123;</span><br><span class="line">          <span class="comment">//指定构建 C++ 代码脚本</span></span><br><span class="line">            path <span class="string">'src/main/cpp/CMakeLists.txt'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>MainActivity 测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"ffmpeg_lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        TextView ffmpegVer = findViewById(R.id.ffmpeg_ver);</span><br><span class="line">        ffmpegVer.setText(<span class="string">"当前 FFmpeg 版本为:"</span> + getFFmpegVersion());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回当前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> String <span class="title">getFFmpegVersion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果:</p>
</li>
</ol>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200115133808.png" alt=""></p>
<p>到这里 FFmpeg 编译及导入 AS 使用已经全部介绍完了，动态库编译及使用需要自己动手去实践了，使用方式都大同小异。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在编译 FFmpeg 的时候会出现很多坑，基本上每个版本的 shell 脚本编写都不一样，所以如果对 Shell 不太了解的，建议先去复习一下。</p>
<p>该篇文章下来咱们用到了交叉编译、 Shell 脚本、 JNI 、Cmake 的知识，如果对这些基础还不了解的一定要先去把基础学好。也可以看我之前系列基础文章。</p>
<p><a href="https://github.com/yangkun19921001/ndk_study/tree/master/ffmpeg">文章中的代码</a></p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li><a href="https://www.ffmpeg.org/download.html">FFmpeg</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:09:00.000Z" title="2020-06-04T10:09:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">42 分钟 读完 (大约 6245 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%BA%94-shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/">音视频学习 (五) shell 脚本入门</a></h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200113140837.jpg" alt=""></p>
<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习 Shell 脚本也是为了后面编译第三方库打下一个基础，编译第三方库几乎都需要用到 shell 语法，如果你不懂那么就不会编译出自己想要的版本，只会 copy 网络上别人写好的这其实是没有任何学习的意义。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<h2 id="Shell-入门学习"><a href="#Shell-入门学习" class="headerlink" title="Shell 入门学习"></a>Shell 入门学习</h2><p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好。</p>
<h3 id="第一个-shell-脚本"><a href="#第一个-shell-脚本" class="headerlink" title="第一个 shell 脚本"></a>第一个 shell 脚本</h3><p>我们还是以输出一个 “Hello Word !” 为例子正式进行学习，脚本代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello World !"</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112211254.gif" alt=""></p>
<p><strong>#!</strong> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p>
<p>echo 命令用于向窗口输出文本。</p>
<p>注意: 如果执行提示没有权限还需要命令输入 <code>chmod +x test.sh</code> 开放可执行权限。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>定义变量时，变量名不加美元符号 ($) ,如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_name="DevYK"</span><br></pre></td></tr></table></figure>

<p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">一定要切记<span class="keyword">for</span> file <span class="keyword">in</span> $后边的那个引号不是单引号，而是tab键上边的那个键，或者说是1左边的那个键。否则的话不起作用。</span></span><br><span class="line">for file in $`ls /root/android`</span><br><span class="line">do</span><br><span class="line">echo $file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>输出效果:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112214354.gif" alt=""></p>
<p><strong>使用变量:</strong></p>
<p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_name="DevYK"</span><br><span class="line">echo $my_name</span><br><span class="line"><span class="meta">#</span><span class="bash">变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界</span></span><br><span class="line">echo $&#123;my_name&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DevYK</span><br><span class="line">DevYK</span><br></pre></td></tr></table></figure>



<p><strong>只读变量:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">4. 只读变量</span></span><br><span class="line">my_blog_url="https://www.devyk.top/"</span><br><span class="line">readonly my_blog_url</span><br><span class="line">my_blog_url="www.baidu.com"</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112215148.png" alt=""></p>
<p><strong>删除变量:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">变量被删除后不能再次使用。<span class="built_in">unset</span> 命令不能删除只读变量。</span></span><br><span class="line">your_name="小明"</span><br><span class="line">unset your_name</span><br><span class="line">echo $your_name</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112215800.gif" alt=""></p>
<p>可以看到定义了删除变量之后，后面是没有任何输出</p>
<p><strong>变量类型:</strong></p>
<p>运行shell时，会同时存在三种变量：</p>
<ul>
<li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量。</li>
<li><strong>2) 环境变量</strong> 所有的程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候 shell 脚本也可以定义环境变量。</li>
<li><strong>3) shell变量</strong> shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">单引号</span></span><br><span class="line">str='this is a book'</span><br></pre></td></tr></table></figure>

<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">双引号</span></span><br><span class="line">your_title=“玄幻小说”</span><br><span class="line">str="嗨, 请问这是一本什么类型的小说？ \"$your_title\" \n"</span><br><span class="line">echo -e $str</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">嗨, 请问这是一本什么类型的小说？ "“玄幻小说”"</span><br></pre></td></tr></table></figure>

<p>双引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<p><strong>拼接字符串:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">your_name="DevYK_1"</span><br><span class="line"><span class="meta">#</span><span class="bash">使用双引号拼接</span></span><br><span class="line">str1="2 我是 “$your_name” !"</span><br><span class="line">str2="2 我是 $&#123;your_name&#125; !"</span><br><span class="line">echo $str1 $str2</span><br><span class="line"><span class="meta">#</span><span class="bash">使用单引号拼接</span></span><br><span class="line">str3='1 我是 “$your_name” !'</span><br><span class="line">str4='1 我是 $&#123;your_name&#125; !'</span><br><span class="line">echo $str3 $str4</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 我是 “DevYK_1” ! 2 我是 DevYK_1 !</span><br><span class="line">1 我是 DevYK_1 ! 1 我是 $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure>

<p><strong>获取字符串长度:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str_length='123456'</span><br><span class="line">echo $&#123;#str_length&#125;</span><br></pre></td></tr></table></figure>

<p>输出: 6</p>
<p><strong>提取字符串:</strong></p>
<p>以下实例从字符串第 <strong>2</strong> 个字符开始截取 <strong>4</strong> 个字符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;str_length:1:4&#125;</span><br></pre></td></tr></table></figure>

<p>输出: 2345</p>
<p><strong>查找字符串:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `expr index "$str_length" 3` //是反斜杠 tab 上 1 键左</span><br></pre></td></tr></table></figure>

<p>输出：3</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>
<p>例子:</p>
<p>以下实例我们向脚本传递三个参数，并分别输出，其中 <strong>$0</strong> 为执行的文件名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo "Shell 传递参数实例！";</span><br><span class="line">echo "执行的文件名：$0";</span><br><span class="line">echo "第一个参数为：$1";</span><br><span class="line">echo "第二个参数为：$2";</span><br><span class="line">echo "第三个参数为：$3";</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112223631.gif" alt=""></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小。</p>
<p>与大部分编程语言类似，数组元素的下标由 0 开始。</p>
<p>Shell 数组用括号来表示，元素用 “空格” 符号分割开，语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br><span class="line"></span><br><span class="line">echo "第一个元素为: $&#123;my_array[0]&#125;"</span><br><span class="line">echo "第二个元素为: $&#123;my_array[1]&#125;"</span><br><span class="line">echo "第三个元素为: $&#123;my_array[2]&#125;"</span><br><span class="line">echo "第四个元素为: $&#123;my_array[3]&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用@ 或 * 可以获取数组中的所有元素，例如：</span></span><br><span class="line">echo "数组的元素为: $&#123;my_array[*]&#125;"</span><br><span class="line">echo "数组的元素为: $&#123;my_array[@]&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取数组长度的方法与获取字符串长度的方法相同</span></span><br><span class="line">echo "数组元素个数为: $&#123;#my_array[*]&#125;"</span><br><span class="line">echo "数组元素个数为: $&#123;#my_array[@]&#125;"</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一个元素为: A</span><br><span class="line">第二个元素为: B</span><br><span class="line">第三个元素为: C</span><br><span class="line">第四个元素为: D</span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组元素个数为: 4</span><br><span class="line">数组元素个数为: 4</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Shell 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<p><strong>注意:</strong></p>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被 <strong><code></code></strong> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
</ul>
<p><strong>算符运算符:</strong></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法</td>
<td align="left"><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法</td>
<td align="left"><code>expr $a - $b</code> 结果为 -10。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left"><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">除法</td>
<td align="left"><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left"><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td align="left">=</td>
<td align="left">赋值</td>
<td align="left">a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td align="left">==</td>
<td align="left">相等。用于比较两个数字，相同则返回 true。</td>
<td align="left">[ $a == $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不相等。用于比较两个数字，不相同则返回 true。</td>
<td align="left">[ $a != $b ] 返回 true。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a==$b]</strong> 是错误的，必须写成 <strong>[ $a == $b ]</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo "a + b : $val"</span><br><span class="line"></span><br><span class="line">val=`expr $a - $b`</span><br><span class="line">echo "a - b : $val"</span><br><span class="line"></span><br><span class="line">val=`expr $a \* $b`</span><br><span class="line">echo "a * b : $val"</span><br><span class="line"></span><br><span class="line">val=`expr $b / $a`</span><br><span class="line">echo "b / a : $val"</span><br><span class="line"></span><br><span class="line">val=`expr $b % $a`</span><br><span class="line">echo "b % a : $val"</span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo "a 等于 b"</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo "a 不等于 b"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a + b : 30</span><br><span class="line">a - b : -10</span><br><span class="line">a * b : 200</span><br><span class="line">b / a : 2</span><br><span class="line">b % a : 0</span><br><span class="line">a 不等于 b</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong></p>
<ul>
<li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li>
<li>if…then…fi 是条件语句，后续将会讲解。</li>
<li>在 MAC 中 shell 的 expr 语法是：<strong>$((表达式))</strong>，此处表达式中的 “*” 不需要转义符号 “&quot; 。</li>
</ul>
</blockquote>
<p><strong>关系运算符:</strong></p>
<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-eq</td>
<td align="left">检测两个数是否相等，相等返回 true。</td>
<td align="left">[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-ne</td>
<td align="left">检测两个数是否不相等，不相等返回 true。</td>
<td align="left">[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-gt</td>
<td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-lt</td>
<td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-ge</td>
<td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-le</td>
<td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a -eq $b : a 等于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a -eq $b: a 不等于 b"</span><br><span class="line">fi</span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a -ne $b: a 不等于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a -ne $b : a 等于 b"</span><br><span class="line">fi</span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a -gt $b: a 大于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a -gt $b: a 不大于 b"</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a -lt $b: a 小于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a -lt $b: a 不小于 b"</span><br><span class="line">fi</span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a -ge $b: a 大于或等于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a -ge $b: a 小于 b"</span><br><span class="line">fi</span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a -le $b: a 小于或等于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a -le $b: a 大于 b"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 -eq 20: a 不等于 b</span><br><span class="line">10 -ne 20: a 不等于 b</span><br><span class="line">10 -gt 20: a 不大于 b</span><br><span class="line">10 -lt 20: a 小于 b</span><br><span class="line">10 -ge 20: a 小于 b</span><br><span class="line">10 -le 20: a 小于或等于 b</span><br></pre></td></tr></table></figure>

<p><strong>布尔运算符:</strong></p>
<p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">!</td>
<td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td align="left">[ ! false ] 返回 true。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">或运算，有一个表达式为 true 则返回 true。</td>
<td align="left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td align="left">-a</td>
<td align="left">与运算，两个表达式都为 true 才返回 true。</td>
<td align="left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a != $b : a 不等于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a == $b: a 等于 b"</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 100 -a $b -gt 15 ]</span><br><span class="line">then</span><br><span class="line">   echo "$a 小于 100 且 $b 大于 15 : 返回 true"</span><br><span class="line">else</span><br><span class="line">   echo "$a 小于 100 且 $b 大于 15 : 返回 false"</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 100 -o $b -gt 100 ]</span><br><span class="line">then</span><br><span class="line">   echo "$a 小于 100 或 $b 大于 100 : 返回 true"</span><br><span class="line">else</span><br><span class="line">   echo "$a 小于 100 或 $b 大于 100 : 返回 false"</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt 5 -o $b -gt 100 ]</span><br><span class="line">then</span><br><span class="line">   echo "$a 小于 5 或 $b 大于 100 : 返回 true"</span><br><span class="line">else</span><br><span class="line">   echo "$a 小于 5 或 $b 大于 100 : 返回 false"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 != 20 : a 不等于 b</span><br><span class="line">10 小于 100 且 20 大于 15 : 返回 true</span><br><span class="line">10 小于 100 或 20 大于 100 : 返回 true</span><br><span class="line">10 小于 5 或 20 大于 100 : 返回 false</span><br></pre></td></tr></table></figure>

<p><strong>逻辑运算符:</strong></p>
<p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑的 AND</td>
<td align="left">[[ $Misplaced &amp;a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">逻辑的 OR</td>
<td align="left">[[ $a -lt 100</td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo "返回 true"</span><br><span class="line">else</span><br><span class="line">   echo "返回 false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 || $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo "返回 true"</span><br><span class="line">else</span><br><span class="line">   echo "返回 false"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回 false</span><br><span class="line">返回 true</span><br></pre></td></tr></table></figure>

<p><strong>字符串运算符</strong></p>
<p>下表列出了常用的字符串运算符，假定变量 a 为 “123”，变量 b 为 “456”：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">检测两个字符串是否相等，相等返回 true。</td>
<td align="left">[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检测两个字符串是否相等，不相等返回 true。</td>
<td align="left">[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-z</td>
<td align="left">检测字符串长度是否为0，为0返回 true。</td>
<td align="left">[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">检测字符串长度是否为0，不为0返回 true。</td>
<td align="left">[ -n “$a” ] 返回 true。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">检测字符串是否为空，不为空返回 true。</td>
<td align="left">[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">str1="123"</span><br><span class="line">str2="456"</span><br><span class="line"></span><br><span class="line">if [ $str1 = $str2 ]</span><br><span class="line">then</span><br><span class="line">   echo "$str1 = $str2 : str1 等于 str2"</span><br><span class="line">else</span><br><span class="line">   echo "$str1 = $str2: str1 不等于 str2"</span><br><span class="line">fi</span><br><span class="line">if [ $str1 != $str2 ]</span><br><span class="line">then</span><br><span class="line">   echo "$str1 != $str2 : str1 不等于 str2"</span><br><span class="line">else</span><br><span class="line">   echo "$str1 != $str2: str1 等于 str2"</span><br><span class="line">fi</span><br><span class="line">if [ -z $str1 ]</span><br><span class="line">then</span><br><span class="line">   echo "-z $str1 : 字符串长度为 0"</span><br><span class="line">else</span><br><span class="line">   echo "-z $str1 : 字符串长度不为 0"</span><br><span class="line">fi</span><br><span class="line">if [ -n "$str1" ]</span><br><span class="line">then</span><br><span class="line">   echo "-n $str1 : 字符串长度不为 0"</span><br><span class="line">else</span><br><span class="line">   echo "-n $str1 : 字符串长度为 0"</span><br><span class="line">fi</span><br><span class="line">if [ $str1 ]</span><br><span class="line">then</span><br><span class="line">   echo "$str1 : 字符串不为空"</span><br><span class="line">else</span><br><span class="line">   echo "$str1 : 字符串为空"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">123 = 456: str1 不等于 str2</span><br><span class="line">123 != 456 : str1 不等于 str2</span><br><span class="line">-z 123 : 字符串长度不为 0</span><br><span class="line">-n 123 : 字符串长度不为 0</span><br><span class="line">123 : 字符串不为空</span><br></pre></td></tr></table></figure>

<p><strong>文件测试运算符:</strong></p>
<p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-b file</td>
<td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td>
<td align="left">[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-c file</td>
<td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td align="left">[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-d file</td>
<td align="left">检测文件是否是目录，如果是，则返回 true。</td>
<td align="left">[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-f file</td>
<td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td align="left">[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-g file</td>
<td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td align="left">[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-k file</td>
<td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td align="left">[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-p file</td>
<td align="left">检测文件是否是有名管道，如果是，则返回 true。</td>
<td align="left">[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-u file</td>
<td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td align="left">[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-r file</td>
<td align="left">检测文件是否可读，如果是，则返回 true。</td>
<td align="left">[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-w file</td>
<td align="left">检测文件是否可写，如果是，则返回 true。</td>
<td align="left">[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-x file</td>
<td align="left">检测文件是否可执行，如果是，则返回 true。</td>
<td align="left">[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-s file</td>
<td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td align="left">[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-e file</td>
<td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td align="left">[ -e $file ] 返回 true。</td>
</tr>
</tbody></table>
<p>其他检查符：</p>
<ul>
<li><strong>-S</strong>: 判断某文件是否 socket。</li>
<li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li>
</ul>
<p>变量 file 表示文件 <strong>/root/android/shell/test.sh</strong>，它具有 <strong>rwx</strong> 权限。下面的代码，将检测该文件的各种属性：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">file="/root/android/shell/test.sh"</span><br><span class="line">if [ -r $file ]</span><br><span class="line">then</span><br><span class="line">   echo "文件可读"</span><br><span class="line">else</span><br><span class="line">   echo "文件不可读"</span><br><span class="line">fi</span><br><span class="line">if [ -w $file ]</span><br><span class="line">then</span><br><span class="line">   echo "文件可写"</span><br><span class="line">else</span><br><span class="line">   echo "文件不可写"</span><br><span class="line">fi</span><br><span class="line">if [ -x $file ]</span><br><span class="line">then</span><br><span class="line">   echo "文件可执行"</span><br><span class="line">else</span><br><span class="line">   echo "文件不可执行"</span><br><span class="line">fi</span><br><span class="line">if [ -f $file ]</span><br><span class="line">then</span><br><span class="line">   echo "文件为普通文件"</span><br><span class="line">else</span><br><span class="line">   echo "文件为特殊文件"</span><br><span class="line">fi</span><br><span class="line">if [ -d $file ]</span><br><span class="line">then</span><br><span class="line">   echo "文件是个目录"</span><br><span class="line">else</span><br><span class="line">   echo "文件不是个目录"</span><br><span class="line">fi</span><br><span class="line">if [ -s $file ]</span><br><span class="line">then</span><br><span class="line">   echo "文件不为空"</span><br><span class="line">else</span><br><span class="line">   echo "文件为空"</span><br><span class="line">fi</span><br><span class="line">if [ -e $file ]</span><br><span class="line">then</span><br><span class="line">   echo "文件存在"</span><br><span class="line">else</span><br><span class="line">   echo "文件不存在"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件可读</span><br><span class="line">文件可写</span><br><span class="line">文件可执行</span><br><span class="line">文件为普通文件</span><br><span class="line">文件不是个目录</span><br><span class="line">文件不为空</span><br><span class="line">文件存在</span><br></pre></td></tr></table></figure>

<h3 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h3><p>Shell 的 echo 指令用于字符串的输出。命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo string</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示普通字符串</span></span><br><span class="line">echo "This is a book"</span><br><span class="line"><span class="meta">#</span><span class="bash">也可以省略双引号</span></span><br><span class="line">echo This is a book</span><br><span class="line"><span class="meta">#</span><span class="bash">显示转义字符</span></span><br><span class="line">echo"\"This is a book"\"</span><br><span class="line"><span class="meta">#</span><span class="bash">显示变量</span></span><br><span class="line">your_name_2="DevYK_2"</span><br><span class="line">echo "变量的名称是:$your_name_2"</span><br><span class="line"><span class="meta">#</span><span class="bash">显示换行 -e 开始转义</span></span><br><span class="line">echo -e "换行 \n"</span><br><span class="line">echo  "是否换行了"</span><br><span class="line"><span class="meta">#</span><span class="bash">显示不换行</span></span><br><span class="line">echo -e "不换行 \c"</span><br><span class="line">echo  "是否换行了"</span><br><span class="line"><span class="meta">#</span><span class="bash">显示命令执行结果</span></span><br><span class="line">echo `date`</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This is a book</span><br><span class="line">This is a book</span><br><span class="line">"This is a book"</span><br><span class="line">变量的名称是:DevYK_2</span><br><span class="line">换行 </span><br><span class="line"></span><br><span class="line">是否换行了</span><br><span class="line">不换行 是否换行了</span><br><span class="line">Mon Jan 13 12:12:32 CST 2020</span><br></pre></td></tr></table></figure>

<h3 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf 命令"></a>printf 命令</h3><p>上一章节我们学习了 Shell 的 echo 命令，本章节我们来学习 Shell 的另一个输出命令 printf。</p>
<p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p>
<p>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p>
<p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。</p>
<p>printf 命令的语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf  format-string  [arguments...]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><strong>format-string:</strong> 为格式控制字符串</li>
<li><strong>arguments:</strong> 为参数列表。</li>
</ul>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf "%-10s %-8s %-4s\n"   姓名 性别 体重kg  </span><br><span class="line">printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234 </span><br><span class="line">printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543 </span><br><span class="line">printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br></pre></td></tr></table></figure>

<p>%s %c %d %f都是格式替代符</p>
<p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<h3 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h3><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<p><strong>数值测试:</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-eq</td>
<td align="left">等于则为真</td>
</tr>
<tr>
<td align="left">-ne</td>
<td align="left">不等于则为真</td>
</tr>
<tr>
<td align="left">-gt</td>
<td align="left">大于则为真</td>
</tr>
<tr>
<td align="left">-ge</td>
<td align="left">大于等于则为真</td>
</tr>
<tr>
<td align="left">-lt</td>
<td align="left">小于则为真</td>
</tr>
<tr>
<td align="left">-le</td>
<td align="left">小于等于则为真</td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo '两个数相等！'</span><br><span class="line">else</span><br><span class="line">    echo '两个数不相等！'</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个数相等！</span><br></pre></td></tr></table></figure>

<p><strong>字符串测试:</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">等于则为真</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不相等则为真</td>
</tr>
<tr>
<td align="left">-z 字符串</td>
<td align="left">字符串的长度为零则为真</td>
</tr>
<tr>
<td align="left">-n 字符串</td>
<td align="left">字符串的长度不为零则为真</td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name_="DEVYK"</span><br><span class="line">name2_="DevYK"</span><br><span class="line">if test $name_ = $name2_</span><br><span class="line">then</span><br><span class="line">    echo '两个字符串相等!'</span><br><span class="line">else</span><br><span class="line">    echo '两个字符串不相等!'</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个字符串不相等!</span><br></pre></td></tr></table></figure>

<p><strong>文件测试:</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-e 文件名</td>
<td align="left">如果文件存在则为真</td>
</tr>
<tr>
<td align="left">-r 文件名</td>
<td align="left">如果文件存在且可读则为真</td>
</tr>
<tr>
<td align="left">-w 文件名</td>
<td align="left">如果文件存在且可写则为真</td>
</tr>
<tr>
<td align="left">-x 文件名</td>
<td align="left">如果文件存在且可执行则为真</td>
</tr>
<tr>
<td align="left">-s 文件名</td>
<td align="left">如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td align="left">-d 文件名</td>
<td align="left">如果文件存在且为目录则为真</td>
</tr>
<tr>
<td align="left">-f 文件名</td>
<td align="left">如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td align="left">-c 文件名</td>
<td align="left">如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td align="left">-b 文件名</td>
<td align="left">如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if test -e ./test.sh</span><br><span class="line">then</span><br><span class="line">    echo '文件已存在!'</span><br><span class="line">else</span><br><span class="line">    echo '文件不存在!'</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件已存在!</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>和 Java 语言不一样，sh 的流程控制不可为空，如(以下为Java流程控制写法)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == <span class="number">2</span>)&#123;</span><br><span class="line">  add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//不做任何处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p>
<p><strong>if 语句语法格式:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>写成一行（适用于终端命令提示符）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi</span><br></pre></td></tr></table></figure>

<p><strong>for 循环:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3</span><br><span class="line">do</span><br><span class="line">	echo "the value is $loop"</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">the value is 1</span><br><span class="line">the value is 2</span><br><span class="line">the value is 3</span><br></pre></td></tr></table></figure>

<p><strong>while 语句</strong></p>
<p>while 循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>以下是一个基本的 while 循环，测试条件是：如果 int 小于等于 5，那么条件返回真。int 从 0 开始，每次循环处理时，int 加 1 。运行上述脚本，返回数字 1 到 5 ，然后终止。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let "int++"</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>无限循环</strong></p>
<p>无限循环语法格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( ; ; ))</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>linux shell 可以用户定义函数，然后在 shell 脚本中可以随便调用。</p>
<p>shell 中函数的定义格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>1、可以带 function fun() 定义，也可以直接 fun() 定义,不带任何参数。</li>
<li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return 后跟数值 n(0-255)</li>
</ul>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo "这个函数会对输入的两个数字进行相加运算..."</span><br><span class="line">    echo "输入第一个数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    echo "输入第二个数字: "</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo "两个数字分别为 $aNum 和 $anotherNum !"</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo "输入的两个数字之和为 $? !"</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">12</span><br><span class="line">输入第二个数字: </span><br><span class="line">22</span><br><span class="line">两个数字分别为 12 和 22 !</span><br><span class="line">输入的两个数字之和为 34 !</span><br></pre></td></tr></table></figure>

<p>函数返回值在调用该函数后通过 $? 来获得。</p>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<p><strong>函数参数:</strong></p>
<p>在 Shell 中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "第十个参数为 $10 !"</span><br><span class="line">    echo "第十个参数为 $&#123;10&#125; !"</span><br><span class="line">    echo "第十一个参数为 $&#123;11&#125; !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 22 11</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 22 !</span><br><span class="line">第十一个参数为 11 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 22 11 !</span><br></pre></td></tr></table></figure>

<p>注意，$10 不能获取第十个参数，获取第十个参数需要​${10}。当n&gt;=10时，需要使用${n}来获取参数。</p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th align="left">参数处理</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$#</td>
<td align="left">传递到脚本或函数的参数个数</td>
</tr>
<tr>
<td align="left">$*</td>
<td align="left">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td align="left">$$</td>
<td align="left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="left">$!</td>
<td align="left">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td align="left">$@</td>
<td align="left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td align="left">$-</td>
<td align="left">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td align="left">$?</td>
<td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Shell 入门知识就介绍这么多，后续编译第三方库编写 Shell 脚本有陌生的在进行介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.runoob.com/linux/linux-shell-basic-operators.html">Shell 教程</a></li>
<li><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T09:55:00.000Z" title="2020-06-04T09:55:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">41 分钟 读完 (大约 6149 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%85%A5%E9%97%A8/">音视频学习 (四) 交叉编译入门</a></h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112161740.jpeg" alt=""></p>
<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该篇文章主要介绍 Android 端利用 NDK 工具库来对 C/C++ 进行交叉编译，并通过 makefile 和 cmake 来构建 Android 项目。</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>了解 c/c++ 编译器的基本使用，能够在后续移植第三方框架进行交叉编译时，清楚的了解应该传递什么参数。</p>
<p><strong>1. clang</strong></p>
<p>clang 是一个<code>C、C++、Object-C</code>的轻量级编译器。基于<code>LLVM</code>（ LLVM是以C++编写而成的构架编译器的框架系统，可以说是一个用于开发编译器相关的库）,对比 gcc，它具有编译速度更快、编译产出更小等优点，但是某些软件在使用 clang 编译时候因为源码中内容的问题会出现错误。</p>
<p><strong>2. gcc</strong></p>
<p>GNU C 编译器。原本只能处理 C 语言，但是它很快扩展，变得可处理 C++。( GNU目标是创建一套完全自由的操作系统)。</p>
<p><strong>3. g++</strong></p>
<p>GNU c++ 编译器，后缀为 .c 的源文件，gcc 把它当作是 C 程序，而 g++ 当作是 C++ 程序；后缀为 .cpp 的，两者都会认为是 c++ 程序，g++ 会自动链接 c++ 标准库 stl ，gcc 不会，gcc 不会定义 __cplusplus 宏，而 g++ 会。</p>
<h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>一个 C/C++ 文件要经过预处理(preprocessing)、编译(compilation)、汇编(assembly)、和链接(linking)才能变成可执行文件。</p>
<p>我们先在 linux 系统上创建一个 test.c 文件，编写一个最简单的 c 程序，代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" 执行成功 ! \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">19921001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>预处理阶段</p>
<p>预处理阶段主要处理 include 和 define 等。它把 #include 包含进来的 .h 文件插入到 #include 所在的位置，把源程序中使用到的用 #define 定义的宏用实际的字符串代替。</p>
<p>我们可以通过以下命令来对 c/c++ 文件预处理，命令如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i //-E 的作用是让 gcc 在预处理结束后停止编译</span><br></pre></td></tr></table></figure>

<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200110202030.png" alt=""></p>
<p>可以看到输入该命令之后就会生成一个 test.i 文件。</p>
</li>
<li><p>编译阶段</p>
<p>在这个阶段中，gcc 首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作。</p>
<p>我们可以通过如下命令来处理 test.i 文件，编译成汇编文件，命令如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s<span class="comment">//-S 的作用是编译结束生成汇编文件。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111145043.png" alt=""></p>
</li>
<li><p>汇编阶段</p>
<p>汇编阶段把 .S 文件翻译成二进制机器指令文件 .o ，这个阶段接收.c ,.i ,.s 的文件都没有问题。</p>
<p>下面我们通过以下命令生成二进制机器指令文件 .o 文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>

<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111145443.png" alt=""></p>
</li>
<li><p>链接阶段</p>
<p>链接阶段，链接的是函数库。可以通过以下命令实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -C test.o -o test</span><br><span class="line">	./test</span><br></pre></td></tr></table></figure>

<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111145916.png" alt="">最后我们通过实际操作，对编译有了一定的了解，当然你也可以直接通过如下命令一步到位:</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure>

<p>到这里我们成功的在 linux 平台生成了可执行文件，试想一下我们可以将这个可执行文件拷贝到安卓手机上执行吗？我们也不猜想了，实际测试下就行，我们把 test 可执行文件 push 到手机  /data/local/tmp 里面, 如下所示:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111155247.png" alt=""></p>
<p>可以看到 test 在手机 /data/local/tmp 的路径下是有可读可写可执行的权限，但是最后执行不成功，这是为什么呢? 其实 <strong>主要原因是两个平台的 CPU 指令集不一样，根本就无法识别指令</strong>。那么怎么解决这个问题呢? 下面就要用到今天一个比较重要的知识点了， <strong>利用 Android NDK 工具包来对 C/C++ 代码进行交叉编译</strong> 。</p>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>简单地来说，交叉编译就是程序的编译环境和实际运行环境不一致，即在一个平台上生成另一个平台上的可执行代码。</p>
<p>在音视频开发中了解交叉编译是很有必要的，因为无论在哪一种移动平台下开发，第三方库都是需要进行交叉编译的。下面我们就以之前的例子来讲解如何在 linux 环境下交叉编译出移动平台上的可执行代码。</p>
<h3 id="了解-NDK"><a href="#了解-NDK" class="headerlink" title="了解 NDK"></a>了解 NDK</h3><p>Android 原生开发包 (NDK) 可用于 Android 平台上的 C++ 开发，NDK 不仅仅是一个单一功能的工具，还是一个包含了 API 、交叉编译器、调试器、构建工具等得综合工具集。</p>
<p>下面大致列举了一下经常会用到的组件。</p>
<ul>
<li>ARM 交叉编译器</li>
<li>构建工具</li>
<li>Java 原生接口头文件</li>
<li>C 库</li>
<li>Math 库</li>
<li>最小的 C++ 库</li>
<li>ZLib 压缩库</li>
<li>POSIX 线程</li>
<li>Android 日志库</li>
<li>Android 原生应用 API</li>
<li>OpenGL ES 库</li>
<li>OpenSL ES 库</li>
</ul>
<p>下面来看一下 Android 所提供的 NDK 跟目录下的结构。</p>
<ul>
<li>ndk-build: 该 Shell 脚本是 Android NDK 构建系统的起始点，一般在项目中仅仅执行这一个命令就可以编译出对应的动态链接库了。</li>
<li>ndk-gdb: 该 Shell 脚本允许用 GUN 调试器调试 Native 代码，并且可以配置到 AS 中，可以做到像调试 Java 代码一样调试 Native 代码。</li>
<li>ndk-stack: 该 Shell 脚本可以帮组分析 Native 代码崩溃时的堆栈信息。</li>
<li>build: 该目录包含 NDK 构建系统的所有模块。</li>
<li>platforms: 该目录包含支持不同 Android 目标版本的头文件和库文件， NDK 构建系统会根据具体的配置来引用指定平台下的头文件和库文件。</li>
<li>toolchains: 该目录包含目前 NDK 所支持的不同平台下的交叉编译器 - ARM 、X86、MIPS ，目前比较常用的是 ARM 。构建系统会根据具体的配置选择不同的交叉编译器。</li>
</ul>
<p>下面我们就来为交叉编译的环境变量配置</p>
<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><ul>
<li><p>ndk 在 Linux 上的环境变量配置:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. vim /etc/profile</span></span><br><span class="line">#NDK环境变量</span><br><span class="line"><span class="keyword">export</span> NDK_HOME=/root/android/ndk/android-ndk-r17c</span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$NDK_HOME</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 保存</span></span><br><span class="line">source  /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 测试</span></span><br><span class="line">ndk-build -v</span><br></pre></td></tr></table></figure>

<p>如果出现如下字样，就证明配置成功了。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111173932.png" alt=""></p>
</li>
<li><p>交叉编译在 Linux 上的环境变量配置(做一个参考，采坑之后的环境配置):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NDK_GCC_x86=<span class="string">"/root/android/ndk/android-ndk-r17c/toolchains/x86-4.9/prebuilt/linux-x86_64/bin/i686-linux-android-gcc"</span></span><br><span class="line"><span class="keyword">export</span> NDK_GCC_x64=<span class="string">"/root/android/ndk/android-ndk-r17c/toolchains/x86_64-4.9/prebuilt/linux-x86_64/bin/x86_64-linux-android-gcc"</span></span><br><span class="line"><span class="keyword">export</span> NDK_GCC_arm=<span class="string">"/root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc"</span></span><br><span class="line"><span class="keyword">export</span> NDK_GCC_arm_64=<span class="string">"/root/android/ndk/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-gcc"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> NDK_CFIG_x86=<span class="string">"--sysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-x86 -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/i686-linux-android"</span></span><br><span class="line"><span class="keyword">export</span> NDK_CFIG_x64=<span class="string">"--sysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-x86_64 -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/x86_64-linux-android"</span></span><br><span class="line"><span class="keyword">export</span> NDK_CFIG_arm=<span class="string">"--sysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-arm -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/arm-linux-androideabi"</span></span><br><span class="line"><span class="keyword">export</span> NDK_CFIG_arm_64=<span class="string">"--isysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-arm64 -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/aarch64-linux-android"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> NDK_AR_x86=<span class="string">"/root/android/ndk/android-ndk-r17c/toolchains/x86-4.9/prebuilt/linux-x86_64/bin/i686-linux-android-ar"</span></span><br><span class="line"><span class="keyword">export</span> NDK_AR_x64=<span class="string">"/root/android/ndk/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-ar"</span></span><br><span class="line"><span class="keyword">export</span> NDK_AR_arm=<span class="string">"/root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-ar"</span></span><br><span class="line"><span class="keyword">export</span> NDK_AR_arm_64=<span class="string">"/root/android/ndk/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-ar"</span></span><br></pre></td></tr></table></figure>

<p>你可以根据自己的 ndk 路径对应我的环境变量来进行配置。下面我们就用 ndk gcc 来对 test.c 进行交叉编译，步骤如下:</p>
<ol>
<li><p>首先找到 /root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111183926.png" alt=""></p>
<p>执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc -o test test.c</span><br></pre></td></tr></table></figure>

<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111184256.png" alt=""></p>
<p>这种错误是说在我们编得时候编译器找不到我们引入的 stdio.h 头文件，那怎么告诉编译器 stdio.h 头文件在哪里呢? 下面知识点说明怎么指定这些报错的头文件</p>
<p>**</p>
</li>
<li><p>指定头文件代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;root&#x2F;android&#x2F;ndk&#x2F;android-ndk-r17c&#x2F;toolchains&#x2F;arm-linux-androideabi-4.9&#x2F;prebuilt&#x2F;linux-x86_64&#x2F;bin&#x2F;arm-linux-androideabi-gcc --sysroot&#x3D;&#x2F;root&#x2F;android&#x2F;ndk&#x2F;android-ndk-r17c&#x2F;platforms&#x2F;android-21&#x2F;arch-arm -isystem &#x2F;root&#x2F;android&#x2F;ndk&#x2F;android-ndk-r17c&#x2F;sysroot&#x2F;usr&#x2F;include -pie -o test test.c</span><br></pre></td></tr></table></figure>

<p>上面出现了几个命令符号，不了解了可以看一下如下解释:</p>
<p><strong>–sysroot=?:</strong> 使用 ？作为这一次编译的头文件与库文件的查找目录，查找下面的 usr/include 目录。</p>
<p><strong>-isystem ?(主要中间有一个英文空格)</strong> : 使用头文件查找目录，覆盖 –sysroot, 查找 ?/usr/include 目录下面的头文件。</p>
<p>*<em>-isystem ?(主要中间有一个英文空格): *</em> 指定头文件的查找路径。</p>
<p><strong>-I?:</strong> 头文件的查找目录，I 是大写。</p>
</li>
</ol>
</li>
</ul>
<pre><code>这样编译之后还是会报一个 asm/types.h 文件找不到，我们还要继续修改一下路径，如下

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;root&#x2F;android&#x2F;ndk&#x2F;android-ndk-r17c&#x2F;toolchains&#x2F;arm-linux-androideabi-4.9&#x2F;prebuilt&#x2F;linux-x86_64&#x2F;bin&#x2F;arm-linux-androideabi-gcc --sysroot&#x3D;&#x2F;root&#x2F;android&#x2F;ndk&#x2F;android-ndk-r17c&#x2F;platforms&#x2F;android-21&#x2F;arch-arm -isystem &#x2F;root&#x2F;android&#x2F;ndk&#x2F;android-ndk-r17c&#x2F;sysroot&#x2F;usr&#x2F;include -isystem &#x2F;root&#x2F;android&#x2F;ndk&#x2F;android-ndk-r17c&#x2F;sysroot&#x2F;usr&#x2F;include&#x2F;arm-linux-androideabi -pie -o test test.c</span><br></pre></td></tr></table></figure>

这样就能编译成一个 Android 平台可执行的文件了，这样看起来路径太多不易阅读，大家可以参考我提供的全局变量配置来进行设置，最后一行命令解决，如下:

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$NDK_GCC_arm $NDK_CFIG_arm -pie -o test test.c</span><br></pre></td></tr></table></figure>

![](https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111191038.gif)

可以看到，我们使用 Android NDK 编译出来的可执行文件已经在 Linux 平台下不可执行了。下面我们将 test 文件导入到 手机  /data/local/tmp 目录。</code></pre><ol start="3">
<li><p>将 NDK 交叉编译出来的 test 可执行文件，导入 Android 手机中并执行 test 文件。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111191810.gif" alt=""></p>
<p>根据上面的录屏，我们知道已经成功的在 Android 设备下执行了 NDK 交叉编译后的 test 文件了。</p>
<p>下面我们利用 NDK 工具交叉编译 test.c 输出静态动态库。</p>
</li>
</ol>
<h2 id="动态库-amp-静态库"><a href="#动态库-amp-静态库" class="headerlink" title="动态库 &amp; 静态库"></a>动态库 &amp; 静态库</h2><h3 id="编译静态库"><a href="#编译静态库" class="headerlink" title="编译静态库"></a>编译静态库</h3><ol>
<li><p>将 test.c 使用 NDK GCC 编译为 .o 文件 ,命令如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$NDK_GCC_arm $NDK_CFIG_arm -fpic -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<p>如果出现如下文件，证明已经成功了。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111193923.png" alt=""></p>
</li>
<li><p>使用 NDK arm-linux-androideabi-ar 工具将 test.o 文件生成 test.a 静态库，命令如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$NDK_AR_arm r test.a test.o</span><br></pre></td></tr></table></figure>

<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111194141.png" alt=""></p>
<p>之后我们把 test.a 文件导入到 AS 中，来对 .a 的使用。</p>
</li>
</ol>
<h3 id="编译动态库"><a href="#编译动态库" class="headerlink" title="编译动态库"></a>编译动态库</h3><p>在编译动态库的时候我们需要指定 -fPIC -shared 额外参数给编译器，完整命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$NDK_GCC_arm $NDK_CFIG_arm -fpic -shared test.c -o libTest.so</span><br></pre></td></tr></table></figure>

<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111194822.png" alt=""></p>
<h3 id="动态库与静态库的区别"><a href="#动态库与静态库的区别" class="headerlink" title="动态库与静态库的区别"></a>动态库与静态库的区别</h3><p>在平时工作中我们经常把一些常用的函数或者功能封装为一个个库供给别人使用，java开发我们可以封装为 ja r包提供给别人用，安卓平台后来可以打包成 aar 包，同样的，C/C++ 中我们封装的功能或者函数可以通过静态库或者动态库的方式提供给别人使用。</p>
<p>Linux 平台静态库以 .a 结尾，而动态库以 .so 结尾。</p>
<p>那静态库与动态库有什么区别呢？</p>
<p><strong>1. 静态库</strong></p>
<p>与静态库连接时，静态库中所有被使用的函数的机器码在<strong>编译</strong>的时候都被拷贝到最终的可执行文件中，并且会被添加到和它连接的每个程序中：</p>
<p><strong>优点</strong>：运行起来会快一些，不用查找其余文件的函数库了。</p>
<p><strong>缺点</strong>：导致最终生成的可执行代码量相对变多,运行时, 都会被加载到内存中. 又多消耗了内存空间。</p>
<p><strong>2. 动态库</strong></p>
<p>与动态库连接的可执行文件只包含需要的函数的引用表，而不是所有的函数代码，只有在程序<strong>执行</strong>时, 那些需要的函数代码才被拷贝到内存中。</p>
<p>优点：生成可执行文件比较小, 节省磁盘空间，一份动态库驻留在内存中被多个程序使用，也同时节约了内存。</p>
<p>缺点：由于运行时要去链接库会花费一定的时间，执行速度相对会慢一些。</p>
<p><strong>静态库是时间换空间，动态库是空间换时间，二者均有好坏。</strong></p>
<p>如果我们要修改函数库，使用动态库的程序只需要将动态库重新编译就可以了，而使用静态库的程序则需要将静态库重新编译好后，将程序再重新编译一遍。</p>
<h2 id="mk-amp-cmake"><a href="#mk-amp-cmake" class="headerlink" title="mk &amp; cmake"></a>mk &amp; cmake</h2><p>上一小节我们通过 NDK 交叉编译了 test.c 为动态静态库，那么该小节我们就基于 makefile 和 cmake 来构建一个 C/C++  的 Android 程序, 并使用 test .a /libTest.so </p>
<h3 id="mk"><a href="#mk" class="headerlink" title="mk"></a>mk</h3><p>Android.mk 是在 Android 平台上构建一个 C 或者 C ++ 语言编写的程序系统的 Makefile 文件，不同的是， Android 提供了一些列内置变量来提供更加方便的构建语法规则。Application.mk 文件实际上是对应用程序本身进行描述的文件，它描述了应用程序要针对哪些 CPU 架构打包动态 so 包、要构建的是 release 包还是 debug 包以及一些编译和链接参数等。</p>
<h4 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h4><p><strong>1. Android.mk</strong></p>
<ul>
<li><p>LOCAL_PATH :=$(call my-dir)</p>
<p>返回当前文件在系统中路径，Android.mk 文件开始时必须定义该变量。</p>
</li>
<li><p>include $(CLEAR_VARS), 表明清楚上一次构建过程的所有全局变量，因为在一个 Makefile 编译脚本中，会使用大量的全局变量，使用这行脚本表明需要清除掉所有的全局变量。</p>
</li>
<li><p>LOCAL_SRC_FILES, 要编译的 C 或者 CPP 的文件，注意这里不需要列举头文件，构建系统会自动帮组开发者依赖这些文件。</p>
</li>
<li><p>LOCAL_LDLIBS:= -L$(SYSROOT)/usr/lib -Ilog -IOpenSLES -IGLESv2 -IEGL -Iz,定编译过程所依赖的 NDK 提供的动态静态库， SYSROOT 变量代表的是 NDK_ROOT 下面的目录 $NDK 提供的动态与静态库，SYSROOT 变量代表的是 NDK_ROOT 下面目录 $NDK_ROOT/platforms/android-21/arch-arm, 而在这个目录的 usr/lib/ 目录下有很多对应的 so 的动态库以及 .a 的静态库。</p>
</li>
<li><p>LOCAL_CFLAGS , 编译 C 或者 CPP 的编译标志，在实际编译的时候会发送给编译器。比如常用的实例是加上 -DAUTO_TEST , 然后在代码中就可以利用条件判断 #ifdef AUTO_TEST 来做一些与自动化测试相关的事情。</p>
</li>
<li><p>LOCAL_LDFLAGS, 链接标志的可选列表，当对目标文件进行链接以生成输出文件的时候，将这些标志带给链接器。该指令与 LOCAL_LDLIBS 有些类似，一般情况下，该选项会用于指定第三方编译的静态库，LOCAL_LDLIBS 经常用于指定系统的库(比如 log、OpenGLES、EGL 等)。</p>
</li>
<li><p>LOCAL_MODULE, 该模块的编译的目标名，用于区分各个模块，名字必须是唯一并不包含空格的，如果编译目标是 so 库，那么该 so 库的名称就是 lib 项目名 .so。</p>
</li>
<li><p>include $(BUILD_SHARED_LIBRARY) ，其实类似的 include 还有很多，都是构建系统提供的内置变量，该变量的意义是构建动态库，其他的内置变量还包括如下几种。</p>
<ul>
<li>—BUILD_STATIC_LIBRARY: 构建静态库</li>
<li>—PREBUILT_STATIC_LIBRARY: 对已有的静态库进行包装，使其成为一个模块。</li>
<li>—PREBUILT_SHARED_LIBRARY: 对已有的静态库进行包装，使其成为一个模块。</li>
<li>—BUILD_EXECUTABLE: 构建可执行文件。</li>
</ul>
</li>
</ul>
<p><strong>2. Application.mk</strong></p>
<ul>
<li>APP_ABI := XXX ,这里的 XXX 是指不同平台，可以选填的有 x86 、mips 、armeabi、armeabi-v7a、all 等，值得一提的是，若选择 all 则会构建构建出所有平台的 so ,如果不填写该项，那么将默认构建为 armeabi 平台下的库。</li>
<li>APP_STL := gnustl_static ,NDK 构建系统提供了由 Android 系统给出的最小 C++ 运行时库 （、system/lib/libstdc++.so）的 C++ 头文件。</li>
<li>APP_CPPFLAGS :=-std=gnu++11 -fexceptions, 指定编译过程的 flag ,可以在该选项中开启 exception rtti 等特性，但是为了效率考虑，最好关闭 rtti。</li>
<li>NDK_TOOLCHAIN_VERSION = 4.8，指定交叉工具编译链里面的版本号，这里指定使用 4.8。</li>
<li>APP_PLATFORM :=android-9,指定创建的动态库的平台</li>
<li>APP_OPTIM := release,该变量是可选的，用来定义 “release” 或者 “debug” ,”release” 模式是默认的，并且会生成高度优化的二进制代码；“debug” 模式生成的是未优化的二进制代码，但是可以检测出很多的 BUG, 经常用于调试阶段，也相当于在 ndk-build 指令后边直接加上参数 NDK_DEBUG=1。</li>
</ul>
<h4 id="构建-C-C-Android-项目"><a href="#构建-C-C-Android-项目" class="headerlink" title="构建 C/C++ Android 项目"></a>构建 C/C++ Android 项目</h4><p><a href="https://github.com/yangkun19921001/ndk_study/tree/master/mk_application">项目源代码</a></p>
<p><strong>效果:</strong></p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111222928.png" alt=""></p>
<p>Makefile 的方式我们只做一个了解，因为以后我们构建 C/C++ 的 Android 项目都是用 cmake 方式来构建，所以我们重点掌握 cmake 就行。</p>
<h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><p>之前做 NDK 开发或者老的项目都是基于 Android.mk、Application.mk 来构建项目的，但从 AS 2.2 之后便开始采用 CMake 的方式来构建 C/C++ 项目，采用 CMake 相比与之前的 Android.mk、Application.mk 方便简单了许多。下面我们简单的来介绍下 cmake 基础语法吧。</p>
<h4 id="语法基础-1"><a href="#语法基础-1" class="headerlink" title="语法基础"></a>语法基础</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 指定 cmake 的最小版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 设置编译类型</span></span><br><span class="line"><span class="keyword">add_executable</span>(demo <span class="keyword">test</span>.cpp) <span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_library</span>(common STATIC <span class="keyword">test</span>.cpp) <span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(common SHARED <span class="keyword">test</span>.cpp) <span class="comment"># 生成动态库或共享库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 明确指定包含哪些源文件</span></span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="keyword">test</span>.cpp test1.cpp test2.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5. 自定义搜索规则并加载文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">"*.cpp"</span> <span class="string">"protocol/*.cpp"</span>)</span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span>) //加载当前目录下所有的 cpp 文件</span><br><span class="line"><span class="comment">## 或者</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">"*.cpp"</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_PROTOCOL_LIST <span class="string">"protocol/*.cpp"</span>)</span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span> <span class="variable">$&#123;SRC_PROTOCOL_LIST&#125;</span>)</span><br><span class="line"><span class="comment">## 或者</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)//搜索当前目录下的所有.cpp文件</span><br><span class="line"><span class="keyword">aux_source_directory</span>(protocol SRC_PROTOCOL_LIST) </span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span> <span class="variable">$&#123;SRC_PROTOCOL_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6. 查找指定库文件</span></span><br><span class="line"><span class="keyword">find_library</span>(</span><br><span class="line">              log-lib //为 log 定义一个变量名称</span><br><span class="line">              log ) //ndk 下的 log 库</span><br><span class="line"></span><br><span class="line"><span class="comment">#7. 设置包含的目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#8. 设置链接库搜索目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#9. 设置 target 需要链接的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># 目标库</span></span><br><span class="line">                       demo</span><br><span class="line"> </span><br><span class="line">                       <span class="comment"># 目标库需要链接的库</span></span><br><span class="line">                       <span class="comment"># log-lib 是上面 find_library 指定的变量名</span></span><br><span class="line">                       <span class="variable">$&#123;log-lib&#125;</span> )</span><br><span class="line">                       </span><br><span class="line"><span class="comment">#10. 指定链接动态库或者静态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo libtest.a) <span class="comment"># 链接libtest.a</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo libtest.so) <span class="comment"># 链接libtest.so</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#11. 根据全路径链接动态静态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libs/libtest.a)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libs/libtest.so)</span><br><span class="line"></span><br><span class="line"><span class="comment">#12. 指定链接多个库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libs/libtest.a</span><br><span class="line">    <span class="keyword">test</span>.a</span><br><span class="line">    boost_thread</span><br><span class="line">    pthread)</span><br></pre></td></tr></table></figure>

<h4 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h4><table>
<thead>
<tr>
<th>预定义变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PROJECT_SOURCE_DIR</strong></td>
<td>工程的根目录</td>
</tr>
<tr>
<td><strong>PROJECT_BINARY_DIR</strong></td>
<td>运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build</td>
</tr>
<tr>
<td><strong>PROJECT_NAME</strong></td>
<td>返回通过 project 命令定义的项目名称</td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_SOURCE_DIR</strong></td>
<td>当前处理的 CMakeLists.txt 所在的路径</td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_BINARY_DIR</strong></td>
<td>target 编译目录</td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_LIST_DIR</strong></td>
<td>CMakeLists.txt 的完整路径</td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_LIST_LINE</strong></td>
<td>当前所在的行</td>
</tr>
<tr>
<td><strong>CMAKE_MODULE_PATH</strong></td>
<td>定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块</td>
</tr>
<tr>
<td><strong>EXECUTABLE_OUTPUT_PATH</strong></td>
<td>重新定义目标二进制可执行文件的存放位置</td>
</tr>
<tr>
<td><strong>LIBRARY_OUTPUT_PATH</strong></td>
<td>重新定义目标链接库文件的存放位置</td>
</tr>
</tbody></table>
<h4 id="构建-C-C-Android-项目-1"><a href="#构建-C-C-Android-项目-1" class="headerlink" title="构建 C/C++ Android 项目"></a>构建 C/C++ Android 项目</h4><ol>
<li><p>以静态库构建项目</p>
<ul>
<li><p>定义 native 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        testCmake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 cmake 构建程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCmake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 cpp</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// extern int main();  这样写有坑，因为 main 方法是属于 c 的，而当前是 CPP</span><br><span class="line"></span><br><span class="line">extern <span class="string">"C"</span> &#123; //必须这样定义</span><br><span class="line">    int main();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern <span class="string">"C"</span> JNIEXPORT void JNICALL</span><br><span class="line">Java_com_devyk_cmake_1application_MainActivity_testCmake(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject /* this */) &#123;</span><br><span class="line">    std::<span class="keyword">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line"></span><br><span class="line">    __android_log_print(ANDROID_LOG_DEBUG, <span class="string">"DevYK"</span>, <span class="string">"main---&gt;:%d"</span>, main());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 CmakeLists.txt 文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印日志</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">"当前CMake的路径是：$&#123;CMAKE_SOURCE_DIR&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">"当前 CMAKE_ANDROID_ARCH_ABI 的路径是：$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量引入源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB allCpp *.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入cpp源文件</span></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        native-lib</span><br><span class="line">        SHARED</span><br><span class="line">        <span class="comment"># native-lib.cpp 替换  $&#123;allCpp&#125; 批量导入文件</span></span><br><span class="line">        <span class="variable">$&#123;allCpp&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(test_a STATIC IMPORTED)</span><br><span class="line"><span class="comment"># 开始真正的导入</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(test_a PROPERTIES IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libtest.a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只能找系统的</span></span><br><span class="line"><span class="keyword">find_library</span>(</span><br><span class="line">        log-lib</span><br><span class="line">        log)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">message</span>(<span class="string">"当前的log路径在哪里啊 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; $&#123;log-lib&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始链接指定的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        native-lib</span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span></span><br><span class="line">        test_a</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>app/build.gradle cmake 配置</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                <span class="comment">// cppFlags "" // 默认包含四大平台</span></span><br><span class="line">                abiFilters <span class="string">'armeabi-v7a'</span><span class="comment">//编译armeabi-v7a平台</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ndk &#123;</span><br><span class="line">            <span class="comment">//过滤，只使用这个版本的库,否则默认的可是4个平台</span></span><br><span class="line">            abiFilters <span class="string">'armeabi-v7a'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path <span class="string">"src/main/cpp/CMakeLists.txt"</span> <span class="comment">//指定 CMakeLists 路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112141122.png" alt=""></p>
</li>
</ul>
</li>
<li><p>以动态库构建项目</p>
<ul>
<li><p>代码加载 so 库到手机中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"Test"</span>);</span><br><span class="line">    System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p>so 库导入在 main/jniLibs 下</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112154348.png" alt=""></p>
</li>
<li><p>CmakeLists.txt 配置</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印日志</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&gt;&gt;&gt;"</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">"当前CMake的路径是：$&#123;CMAKE_SOURCE_DIR&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">"当前 CMAKE_ANDROID_ARCH_ABI 的路径是：$&#123;CMAKE_ANDROID_ARCH_ABI&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量引入源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB allCpp *.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入cpp源文件</span></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        native-lib</span><br><span class="line">        SHARED</span><br><span class="line">        <span class="comment"># native-lib.cpp</span></span><br><span class="line">        <span class="variable">$&#123;allCpp&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入静态库</span></span><br><span class="line"><span class="comment">#add_library(test_a STATIC IMPORTED)</span></span><br><span class="line"><span class="comment"># 开始真正的导入</span></span><br><span class="line"><span class="comment">#set_target_properties(test_a PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libtest.a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(test_so SHARED IMPORTED)</span><br><span class="line"><span class="comment"># 早起的cmake ANDROID_ABI == 当前CPU平台</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(test_so PROPERTIES IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../jniLibs/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libTest.so)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只能找系统的</span></span><br><span class="line"><span class="keyword">find_library</span>(</span><br><span class="line">        log-lib</span><br><span class="line">        log)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">"当前的log路径在哪里啊 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; $&#123;log-lib&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CMAKE_SOURCE_DIR == D:\NDK\CoursewareCreate\ndk_12\project\ndk12_cmake\app\src\main\cpp\CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        native-lib</span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span></span><br><span class="line">        test_so</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200112154632.png" alt=""></p>
</li>
</ul>
<p>到这里，mk 和 cmake 入门基础知识就讲完了，想要全部掌握还需要自己多动手实践一翻。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该篇文章主要讲解了如何利用 NDK 对 C 程序进行交叉编译，以及交叉编译后的动态静态库在 Android 项目中的使用，还有 makefile 和 cmake 在 Android 的使用，本篇文章也是比较基础的，对于后续使用或者编译 FFmpeg 打下基础。</p>
<p><a href="https://github.com/yangkun19921001/ndk_study">文章中所有代码已上传 GitHub 仓库</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T09:44:00.000Z" title="2020-06-04T09:44:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">42 分钟 读完 (大约 6279 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B8%89-JNI-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%8E%8C%E6%8F%A1/">音视频学习 (三) JNI 从入门到掌握</a></h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200109003933.png" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>音视频系列文章已经发布 2 篇了，C/C++ 基础咱们也已经学完了，那么该篇文章开始就真正进入 NDK 学习了，在进入 NDK 学习之前我们还要学习 JNI 基础。为了保证该系列文章输出，以后尽量一周一篇。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JNI 是 Java 程序设计语言功能功能最强的特征，它允许 Java 类的某些方法原生实现，同时让它们能够像普通 Java 方法一样被调用和使用。这些原生方法也可以使用 Java 对象，使用方法与 Java 代码调用 Java 对象的方法相同。原生方法可以创建新的 Java 对象或者使用 Java 应用程序创建的对象，这些 Java 应用程序可以检查、修改和调用这些对象的方法以执行任务。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装 AS + NDK + CMake + LLDB</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200107194733.png" alt=""></p>
<ul>
<li>AS: Android 开发工具。</li>
<li>NDK：这套工具集允许为 Android 使用 C 和 C++ 代码。</li>
<li>CMake：一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果只计划使用 ndk-build，则不需要此组件。</li>
<li>LLDB：debug 调式。</li>
</ul>
<p><strong>local.properties 配置:</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">ndk.dir</span>=<span class="string">/Users/devyk/Data/Android/SDK/ndk-bundle</span></span><br><span class="line"><span class="meta">sdk.dir</span>=<span class="string">/Users/devyk/Data/Android/SDK</span></span><br></pre></td></tr></table></figure>

<p><strong>build.gradle 配置:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path <span class="string">"src/main/cpp/CMakeLists.txt"</span></span><br><span class="line">            version <span class="string">"3.10.2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><ol>
<li><p>创建 native c++ 工程</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200107202203.png" alt=""></p>
<p>根据提示点击 next</p>
</li>
<li><p>基本代码生成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 加载 native 库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        TextView tv = findViewById(R.id.sample_text);</span><br><span class="line">        <span class="comment">/**3.调用 native c++ 函数*/</span></span><br><span class="line">        tv.setText(stringFromJNI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 定义 native 函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Native-lib.cpp 代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_devyk_ndk_1sample_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后屏幕就会出现  “Hello from C++” 字符串，一个最简单的 native 项目就创建完成了。</p>
</li>
</ol>
<h2 id="JNI-入门学习"><a href="#JNI-入门学习" class="headerlink" title="JNI 入门学习"></a>JNI 入门学习</h2><h3 id="1-数据类型和类型描述符"><a href="#1-数据类型和类型描述符" class="headerlink" title="1. 数据类型和类型描述符"></a>1. 数据类型和类型描述符</h3><p>Java 中有两种数据类型:</p>
<ul>
<li>基本数据类型: boolean 、char、byte、int、short、long、float、double。</li>
<li>引用数据类型: String、Object[]、Class、Object 及其它类。</li>
</ul>
<p><strong>1.1 基本数据类型</strong></p>
<p>基本数据类型可以直接与 C/C++ 的相应基本数据类型映射，如下表所示。JNI 用类型定义使得这种映射对开发人员透明。</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>JNI 类型</th>
<th>C/C++ 类型</th>
<th>size 位</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>jboolean</td>
<td>unsigned char</td>
<td>8</td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
<td>char</td>
<td>8</td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
<td>unsingned short</td>
<td>16</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>short</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
<td>int</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
<td>long</td>
<td>64</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>float</td>
<td>32</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>double</td>
<td>64</td>
</tr>
</tbody></table>
<p><strong>1.2 引用类型:</strong></p>
<p>与基本数据类型不同，引用类型对原生方法时不透明的，引用类型映射如下表所示。它们的内部数据结构并不直接向原生代码公开。</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>原生类型</th>
</tr>
</thead>
<tbody><tr>
<td>Java.lang.Class</td>
<td>jclass</td>
</tr>
<tr>
<td>Java.lang.Throwable</td>
<td>jthrowable</td>
</tr>
<tr>
<td>Java.lang.String</td>
<td>jstring</td>
</tr>
<tr>
<td>Other objects</td>
<td>jobjects</td>
</tr>
<tr>
<td>Java.lang.Object[]</td>
<td>jobjectArray</td>
</tr>
<tr>
<td>boolean[]</td>
<td>jbooleanArray</td>
</tr>
<tr>
<td>byte[]</td>
<td>jbyteArray</td>
</tr>
<tr>
<td>char[]</td>
<td>jcharArray</td>
</tr>
<tr>
<td>short[]</td>
<td>jshortArray</td>
</tr>
<tr>
<td>int[]</td>
<td>jintArray</td>
</tr>
<tr>
<td>long[]</td>
<td>jlongArray</td>
</tr>
<tr>
<td>float[]</td>
<td>jfloatArray</td>
</tr>
<tr>
<td>double[]</td>
<td>jdoubleArray</td>
</tr>
<tr>
<td>Other arrays</td>
<td>jarray</td>
</tr>
</tbody></table>
<p><strong>1.3 数据类型描述符</strong></p>
<p>在 JVM 虚拟机中，存储数据类型的名称时，是使用指定的描述符来存储，而不是我们习惯的 int，float 等。</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>签名 (描述符)</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>J</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>void</td>
<td>V</td>
</tr>
<tr>
<td>其它引用类型</td>
<td>L + 全类名 + ；</td>
</tr>
<tr>
<td>type[]</td>
<td>[</td>
</tr>
<tr>
<td>method type</td>
<td>(参数)返回值</td>
</tr>
</tbody></table>
<p>示例:</p>
<blockquote>
<ul>
<li>表示一个 String</li>
</ul>
<p>Java 类型 :  java.lang.String</p>
<p>JNI 描述符: Ljava/lang/String;  (L + 类全名 + ；)</p>
<ul>
<li>表示一个数组</li>
</ul>
<p>Java 类型: String[]<br>JNI 描述符:  [Ljava/lang/String;<br>Java 类型: int [] []<br>JNI 描述符: [[I</p>
<ul>
<li>表示一个方法</li>
</ul>
<p>Java 方法: long func(int n, String s, int[] arr);<br>JNI 描述符: (ILjava/lang/String;[I)J</p>
<p>Java 方法: void func();<br>JNI 描述符: ()V</p>
</blockquote>
<p>也可以使用命令 : <strong>javap -s 全路径</strong> 来获取方法签名</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200108204504.png" alt=""></p>
<h3 id="2-JNIEnv-和-JavaVm-介绍"><a href="#2-JNIEnv-和-JavaVm-介绍" class="headerlink" title="2. JNIEnv 和 JavaVm 介绍"></a>2. JNIEnv 和 JavaVm 介绍</h3><p><strong>2.1 JNIEnv :</strong></p>
<p>JNIEnv 表示 Java 调用 native 语言的环境，是一个封装了几乎全部 JNI 方法的指针。</p>
<p>JNIEnv 只在创建它的线程生效，不能跨线程传递，不同线程的 JNIEnv 彼此独立。</p>
<p>native 环境中创建的线程，如果需要访问 JNI，必须要调用 AttachCurrentThread 关联，并使用 DetachCurrentThread 解除链接。</p>
<p><strong>2.2 JavaVm :</strong></p>
<p>JavaVM 是虚拟机在 JNI 层的代表，<strong>一个进程只有一个 JavaVM</strong>，所有的线程共用一个 JavaVM。</p>
<p><strong>2.3 代码风格 (C/C++)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C: (*env)-&gt;NewStringUTF(env, “Hellow World!”);</span><br><span class="line"></span><br><span class="line">C++: env-&gt;NewStringUTF(“Hellow World!”);</span><br></pre></td></tr></table></figure>

<h3 id="3-JNI-API"><a href="#3-JNI-API" class="headerlink" title="3. JNI API"></a>3. JNI API</h3><p>参考<a href="https://docs.oracle.com/javase/10/docs/specs/jni/index.html">官方 API 文档</a> 或者 <a href="https://blog.csdn.net/afei__/article/details/81016413">JNI 方法大全及使用示例</a></p>
<h3 id="4-对数据类型的操作"><a href="#4-对数据类型的操作" class="headerlink" title="4. 对数据类型的操作"></a>4. 对数据类型的操作</h3><p><strong>JNI 处理 Java 传递过来的数据</strong></p>
<ol>
<li><p>定义 native 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 加载 native 库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 1. Java 数据传递给 native */</span></span><br><span class="line">        test1(<span class="keyword">true</span>,</span><br><span class="line">                (<span class="keyword">byte</span>) <span class="number">1</span>,</span><br><span class="line">                <span class="string">','</span>,</span><br><span class="line">                (<span class="keyword">short</span>) <span class="number">3</span>,</span><br><span class="line">                <span class="number">4</span>,</span><br><span class="line">                <span class="number">3.3f</span>,</span><br><span class="line">                <span class="number">2.2</span>d,</span><br><span class="line">                <span class="string">"DevYK"</span>,</span><br><span class="line">                <span class="number">28</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"4"</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"阳坤"</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">boolean</span>[]&#123;<span class="keyword">false</span>, <span class="keyword">true</span>&#125;</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java 将数据传递到 native 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> b,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">byte</span> b1,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> c,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">short</span> s,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> l,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">float</span> f,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> d,</span></span></span><br><span class="line"><span class="function"><span class="params">            String name,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> age,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span>[] i,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] strs,</span></span></span><br><span class="line"><span class="function"><span class="params">            Person person,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span>[] bArray</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jni 处理 Java 传递过来的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">"native-lib"</span></span></span><br><span class="line"><span class="comment">// __VA_ARGS__ 代表 ...的可变参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG,  __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span><span class="comment">//支持 C 语言代码</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_devyk_ndk_1sample_MainActivity_test1(JNIEnv *env, jobject instance,</span><br><span class="line">                                              jboolean jboolean1,</span><br><span class="line">                                              jbyte jbyte1,</span><br><span class="line">                                              jchar jchar1,</span><br><span class="line">                                              jshort jshort1,</span><br><span class="line">                                              jlong jlong1,</span><br><span class="line">                                              jfloat jfloat1,</span><br><span class="line">                                              jdouble jdouble1,</span><br><span class="line">                                              jstring name_,</span><br><span class="line">                                              jint age,</span><br><span class="line">                                              jintArray i_,</span><br><span class="line">                                              jobjectArray strs,</span><br><span class="line">                                              jobject person,</span><br><span class="line">                                              jbooleanArray bArray_</span><br><span class="line">                                             ) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 接收 Java 传递过来的 boolean 值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b_boolean = jboolean1;</span><br><span class="line">    LOGD(<span class="string">"boolean-&gt; %d"</span>, b_boolean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 接收 Java 传递过来的 boolean 值</span></span><br><span class="line">    <span class="keyword">char</span> c_byte = jbyte1;</span><br><span class="line">    LOGD(<span class="string">"jbyte-&gt; %d"</span>, c_byte);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 接收 Java 传递过来的 char 值</span></span><br><span class="line">    <span class="keyword">unsigned</span> short c_char = jchar1;</span><br><span class="line">    LOGD(<span class="string">"char-&gt; %d"</span>, c_char);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 接收 Java 传递过来的 short 值</span></span><br><span class="line">    short s_short = jshort1;</span><br><span class="line">    LOGD(<span class="string">"short-&gt; %d"</span>, s_short);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 接收 Java 传递过来的 long 值</span></span><br><span class="line">    <span class="keyword">long</span> l_long = jlong1;</span><br><span class="line">    LOGD(<span class="string">"long-&gt; %d"</span>, l_long);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 接收 Java 传递过来的 float 值</span></span><br><span class="line">    <span class="keyword">float</span> f_float = jfloat1;</span><br><span class="line">    LOGD(<span class="string">"float-&gt; %f"</span>, f_float);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 接收 Java 传递过来的 double 值</span></span><br><span class="line">    <span class="keyword">double</span> d_double = jdouble1;</span><br><span class="line">    LOGD(<span class="string">"double-&gt; %f"</span>, d_double);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8. 接收 Java 传递过来的 String 值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name_string = env-&gt;GetStringUTFChars(name_, <span class="number">0</span>);</span><br><span class="line">    LOGD(<span class="string">"string-&gt; %s"</span>, name_string);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9. 接收 Java 传递过来的 int 值</span></span><br><span class="line">    <span class="keyword">int</span> age_java = age;</span><br><span class="line">    LOGD(<span class="string">"int:%d"</span>, age_java);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//10. 打印 Java 传递过来的 int []</span></span><br><span class="line">    jint *intArray = env-&gt;GetIntArrayElements(i_, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//拿到数组长度</span></span><br><span class="line">    jsize intArraySize = env-&gt;GetArrayLength(i_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intArraySize; ++i) &#123;</span><br><span class="line">        LOGD(<span class="string">"intArray-&gt;%d："</span>, intArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放数组</span></span><br><span class="line">    env-&gt;ReleaseIntArrayElements(i_, intArray, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//11. 打印 Java 传递过来的 String[]</span></span><br><span class="line">    jsize stringArrayLength = env-&gt;GetArrayLength(strs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringArrayLength; ++i) &#123;</span><br><span class="line">        jobject jobject1 = env-&gt;GetObjectArrayElement(strs, i);</span><br><span class="line">        <span class="comment">//强转 JNI String</span></span><br><span class="line">        jstring stringArrayData = <span class="keyword">static_cast</span>&lt;jstring &gt;(jobject1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转 C  String</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *itemStr = env-&gt;GetStringUTFChars(stringArrayData, <span class="literal">NULL</span>);</span><br><span class="line">        LOGD(<span class="string">"String[%d]: %s"</span>, i, itemStr);</span><br><span class="line">        <span class="comment">//回收 String[]</span></span><br><span class="line">        env-&gt;ReleaseStringUTFChars(stringArrayData, itemStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//12. 打印 Java 传递过来的 Object 对象</span></span><br><span class="line">    <span class="comment">//12.1 获取字节码</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *person_class_str = <span class="string">"com/devyk/ndk_sample/Person"</span>;</span><br><span class="line">    <span class="comment">//12.2 转 jni jclass</span></span><br><span class="line">    jclass person_class = env-&gt;FindClass(person_class_str);</span><br><span class="line">    <span class="comment">//12.3 拿到方法签名 javap -a</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sig = <span class="string">"()Ljava/lang/String;"</span>;</span><br><span class="line">    jmethodID jmethodID1 = env-&gt;GetMethodID(person_class, <span class="string">"getName"</span>, sig);</span><br><span class="line"></span><br><span class="line">    jobject obj_string = env-&gt;CallObjectMethod(person, jmethodID1);</span><br><span class="line">    jstring perStr = <span class="keyword">static_cast</span>&lt;jstring &gt;(obj_string);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *itemStr2 = env-&gt;GetStringUTFChars(perStr, <span class="literal">NULL</span>);</span><br><span class="line">    LOGD(<span class="string">"Person: %s"</span>, itemStr2);</span><br><span class="line">    env-&gt;DeleteLocalRef(person_class); <span class="comment">// 回收</span></span><br><span class="line">    env-&gt;DeleteLocalRef(person); <span class="comment">// 回收</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//13. 打印 Java 传递过来的 booleanArray</span></span><br><span class="line">    jsize booArrayLength = env-&gt;GetArrayLength(bArray_);</span><br><span class="line">    jboolean *bArray = env-&gt;GetBooleanArrayElements(bArray_, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; booArrayLength; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> b =  bArray[i];</span><br><span class="line">        jboolean b2 =  bArray[i];</span><br><span class="line">        LOGD(<span class="string">"boolean:%d"</span>,b)</span><br><span class="line">        LOGD(<span class="string">"jboolean:%d"</span>,b2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回收</span></span><br><span class="line">    env-&gt;ReleaseBooleanArrayElements(bArray_, bArray, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; **输出:**</span><br><span class="line">&gt;</span><br><span class="line">&gt; native-lib: boolean-&gt; 1</span><br><span class="line">&gt; native-lib: jbyte-&gt; 1</span><br><span class="line">&gt; native-lib: char-&gt; 44</span><br><span class="line">&gt; native-lib: short-&gt; 3</span><br><span class="line">&gt; native-lib: long-&gt; 4</span><br><span class="line">&gt; native-lib: float-&gt; 3.300000</span><br><span class="line">&gt; native-lib: double-&gt; 2.200000</span><br><span class="line">&gt; native-lib: string-&gt; DevYK</span><br><span class="line">&gt; native-lib: int:28</span><br><span class="line">&gt; native-lib: intArray-&gt;1：</span><br><span class="line">&gt; native-lib: intArray-&gt;2：</span><br><span class="line">&gt; native-lib: intArray-&gt;3：</span><br><span class="line">&gt; native-lib: intArray-&gt;4：</span><br><span class="line">&gt; native-lib: intArray-&gt;5：</span><br><span class="line">&gt; native-lib: intArray-&gt;6：</span><br><span class="line">&gt; native-lib: intArray-&gt;7：</span><br><span class="line">&gt; native-lib: String[0]: 1</span><br><span class="line">&gt; native-lib: String[1]: 2</span><br><span class="line">&gt; native-lib: String[2]: 4</span><br><span class="line">&gt; native-lib: Person: 阳坤</span><br><span class="line">&gt; native-lib: boolean:0</span><br><span class="line">&gt; native-lib: jboolean:0</span><br><span class="line">&gt; native-lib: boolean:1</span><br><span class="line">&gt; native-lib: jboolean:1</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​        </p>
<p><strong>JNI 处理 Java 对象</strong></p>
<ol>
<li><p>定义一个 Java 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 native 接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="title">extends</span> <span class="title">AppCompatActivity</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> TAG = <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 加载 native 库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView <span class="built_in">text</span> = findViewById(R.id.sample_text);</span><br><span class="line">        <span class="comment">/**处理 Java 对象*/</span></span><br><span class="line">        <span class="keyword">String</span> str = getPerson().toString();</span><br><span class="line">        <span class="built_in">text</span>.setText(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> native Person <span class="title">getPerson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面代码我们知道，如果获取成功，手机屏幕上肯定会打印会显示数据。</p>
</li>
<li><p>JNI 的处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_devyk_ndk_1sample_MainActivity_getPerson(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 拿到 Java 类的全路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *person_java = <span class="string">"com.devyk.ndk_sample.Person"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *method = <span class="string">"&lt;init&gt;"</span>; <span class="comment">// Java构造方法的标识</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 找到需要处理的 Java 对象 class</span></span><br><span class="line">    jclass j_person_class = env-&gt;FindClass(person_java);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 拿到空参构造方法</span></span><br><span class="line">    jmethodID person_constructor = env-&gt;GetMethodID(j_person_class, method, <span class="string">"()V"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 创建对象</span></span><br><span class="line">    jobject person_obj = env-&gt;NewObject(j_person_class, person_constructor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 拿到 setName 方法的签名，并拿到对应的 setName 方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nameSig = <span class="string">"(Ljava/lang/String;)V"</span>;</span><br><span class="line">    jmethodID nameMethodId = env-&gt;GetMethodID(j_person_class, <span class="string">"setName"</span>, nameSig);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//6. 拿到 setAge 方法的签名，并拿到 setAge 方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ageSig = <span class="string">"(I)V"</span>;</span><br><span class="line">    jmethodID ageMethodId = env-&gt;GetMethodID(j_person_class, <span class="string">"setAge"</span>, ageSig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 正在调用 Java 对象函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="string">"DevYK"</span>;</span><br><span class="line">    jstring newStringName = env-&gt;NewStringUTF(name);</span><br><span class="line">    env-&gt;CallVoidMethod(person_obj, nameMethodId, newStringName);</span><br><span class="line">    env-&gt;CallVoidMethod(person_obj, ageMethodId, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sig = <span class="string">"()Ljava/lang/String;"</span>;</span><br><span class="line">    jmethodID jtoString = env-&gt;GetMethodID(j_person_class, <span class="string">"toString"</span>, sig);</span><br><span class="line">    jobject obj_string = env-&gt;CallObjectMethod(person_obj, jtoString);</span><br><span class="line">    jstring perStr = <span class="keyword">static_cast</span>&lt;jstring &gt;(obj_string);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *itemStr2 = env-&gt;GetStringUTFChars(perStr, <span class="literal">NULL</span>);</span><br><span class="line">    LOGD(<span class="string">"Person: %s"</span>, itemStr2);</span><br><span class="line">    <span class="keyword">return</span> person_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200108154952.gif" alt=""></p>
<p>可以看到 native 返回数据给 Java 了。</p>
</li>
</ol>
<h3 id="5-JNI-动态注册"><a href="#5-JNI-动态注册" class="headerlink" title="5. JNI 动态注册"></a>5. JNI 动态注册</h3><p>前面咱们学习的都是静态注册，静态注册虽然简单方便，但是也面临一个较大的问题，如果当前类定义的 native 方法名称改变或者包名改变，那么这一改也就面临在 cpp 中实现的也将改动，如果将要面临这种情况你可以试试 JNI 动态注册，如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String TAG = <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 加载 native 库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView text = findViewById(R.id.sample_text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**动态注册的 native */</span></span><br><span class="line">        dynamicRegister(<span class="string">"我是动态注册的"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">dynamicRegister</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpp：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">"native-lib"</span></span></span><br><span class="line"><span class="comment">// __VA_ARGS__ 代表 ...的可变参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG,  __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 动态注册</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对应java类的全路径名，.用/代替</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *classPathName = <span class="string">"com/devyk/ndk_sample/MainActivity"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  <span class="comment">//支持 C 语言</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="comment">//告诉虚拟机，这是jni函数</span></span><br><span class="line">native_dynamicRegister(JNIEnv *env, jobject instance, jstring name) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *j_name = env-&gt;GetStringUTFChars(name, <span class="literal">NULL</span>);</span><br><span class="line">    LOGD(<span class="string">"动态注册: %s"</span>, j_name)</span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(name, j_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 源码结构体</span></span><br><span class="line"><span class="comment"> * typedef struct &#123;</span></span><br><span class="line"><span class="comment">    const char* name;</span></span><br><span class="line"><span class="comment">    const char* signature;</span></span><br><span class="line"><span class="comment">    void*       fnPtr;</span></span><br><span class="line"><span class="comment">    &#125; JNINativeMethod;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod jniNativeMethod[] = &#123;</span><br><span class="line">        &#123;<span class="string">"dynamicRegister"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, (<span class="keyword">void</span> *) (native_dynamicRegister)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数定义在jni.h头文件中，System.loadLibrary()时会调用JNI_OnLoad()函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">JNI_OnLoad(JavaVM *javaVm, <span class="keyword">void</span> *pVoid) &#123;</span><br><span class="line">    <span class="comment">//通过虚拟机 创建爱你全新的 evn</span></span><br><span class="line">    JNIEnv *jniEnv = <span class="literal">nullptr</span>;</span><br><span class="line">    jint result = javaVm-&gt;GetEnv(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(&amp;jniEnv), JNI_VERSION_1_6);</span><br><span class="line">    <span class="keyword">if</span> (result != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR; <span class="comment">// 主动报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    jclass mainActivityClass = jniEnv-&gt;FindClass(classPathName);</span><br><span class="line">    jniEnv-&gt;RegisterNatives(mainActivityClass, jniNativeMethod,</span><br><span class="line">                            <span class="keyword">sizeof</span>(jniNativeMethod) / <span class="keyword">sizeof</span>(JNINativeMethod));<span class="comment">//动态注册的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>动态注册: 我是动态注册的</p>
</blockquote>
<h3 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h3><p>异常处理是 Java 程序设计语言的重要功能， JNI 中的异常行为与 Java 中的有所不同，在 Java 中，当抛出一个异常时，虚拟机停止执行代码块并进入调用栈反向检查能处理特定类型异常的异常处理程序代码块，这也叫捕获异常。虚拟机清除异常并将控制权交给异常处理程序。相比之下， JNI 要求开发人员在异常发生后显式地实现异常处理流。</p>
<p><strong>捕获异常:</strong></p>
<p>JNIEvn 接口提供了一组与异常相关的函数集，在运行过程中可以使用 Java 类查看这些函数，比如代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">dynamicRegister2</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testException</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"MainActivity testException NullPointerException"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 testException 方法时，dynamicRegister2 该原生方法需要显式的处理异常信息，JNI 提供了 ExceptionOccurred 函数查询虚拟机中是否有挂起的异常。在使用完之后，异常处理程序需要用 ExceptionClear 函数显式的清除异常，如下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jthrowable exc = env-&gt;ExceptionOccurred(); <span class="comment">// 检测是否发生异常</span></span><br><span class="line">   <span class="keyword">if</span> (exc) &#123;<span class="comment">//如果发生异常</span></span><br><span class="line">       env-&gt;ExceptionDescribe(); <span class="comment">// 打印异常信息</span></span><br><span class="line">       env-&gt;ExceptionClear(); <span class="comment">// 清除掉发生的异常</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>抛出异常:</strong></p>
<p>JNI 也允许原生代码抛出异常。因为异常是 Java 类，应该先用 FindClass 函数找到异常类，用 ThrowNew 函数可以使用化且抛出新的异常，如下代码所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jthrowable exc = env-&gt;ExceptionOccurred(); <span class="comment">// 检测是否发生异常</span></span><br><span class="line">   <span class="keyword">if</span> (exc) &#123;<span class="comment">//如果发生异常</span></span><br><span class="line">       jclass newExcCls = env-&gt;FindClass(<span class="string">"java/lang/IllegalArgumentException"</span>);</span><br><span class="line">       env-&gt;ThrowNew(newExcCls, <span class="string">"JNI 中发生了一个异常信息"</span>); <span class="comment">// 返回一个新的异常到 Java</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>因为原生函数的代码执行不受虚拟机的控制，因此抛出异常并不会停止原生函数的执行并把控制权交给异常处理程序。到抛出异常时，原生函数应该释放所有已分配的原生资源，例如内存及合适的返回值等。通过 JNIEvn 接口获得的引用是局部引用且一旦返回原生函数，它们自动地被虚拟机释放。</p>
<p><strong>示例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String TAG = <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 加载 native 库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        dynamicRegister2(<span class="string">"测试异常处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">dynamicRegister2</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试抛出异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testException</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"MainActivity testException NullPointerException"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>native-lib.cpp 文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">"native-lib"</span></span></span><br><span class="line"><span class="comment">// __VA_ARGS__ 代表 ...的可变参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG,  __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 动态注册</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  <span class="comment">//支持 C 语言</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="comment">//告诉虚拟机，这是jni函数</span></span><br><span class="line">native_dynamicRegister2(JNIEnv *env, jobject instance, jstring name) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *j_name = env-&gt;GetStringUTFChars(name, <span class="literal">NULL</span>);</span><br><span class="line">    LOGD(<span class="string">"动态注册: %s"</span>, j_name)</span><br><span class="line"></span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(instance);<span class="comment">//拿到当前类的class</span></span><br><span class="line">    jmethodID mid =env-&gt;GetMethodID(clazz, <span class="string">"testException"</span>, <span class="string">"()V"</span>);<span class="comment">//执行 Java 测试抛出异常的代码</span></span><br><span class="line">    env-&gt;CallVoidMethod(instance, mid); <span class="comment">// 执行会抛出一个异常</span></span><br><span class="line">    jthrowable exc = env-&gt;ExceptionOccurred(); <span class="comment">// 检测是否发生异常</span></span><br><span class="line">    <span class="keyword">if</span> (exc) &#123;<span class="comment">//如果发生异常</span></span><br><span class="line">        env-&gt;ExceptionDescribe(); <span class="comment">// 打印异常信息</span></span><br><span class="line">        env-&gt;ExceptionClear(); <span class="comment">// 清除掉发生的异常</span></span><br><span class="line">        jclass newExcCls = env-&gt;FindClass(<span class="string">"java/lang/IllegalArgumentException"</span>);</span><br><span class="line">        env-&gt;ThrowNew(newExcCls, <span class="string">"JNI 中发生了一个异常信息"</span>); <span class="comment">// 返回一个新的异常到 Java</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(name, j_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里还是使用的动态注册。</p>
<p>最后效果如下:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200108222721.png" alt=""></p>
<p>可以看见这里即捕获到了 Java 抛出的异常，也抛出了一个 JNI 新的异常信息。</p>
<h3 id="7-局部与全局引用"><a href="#7-局部与全局引用" class="headerlink" title="7. 局部与全局引用"></a>7. 局部与全局引用</h3><p>引用在 Java 程序设计中扮演非常重要的角色。虚拟机通过追踪类实例的引用并收回不在引用的垃圾来管理类实例的使用期限。因为原生代码不是一个管理环境，因此 JNI 提供了一组函数允许原生代码显式地管理对象引用及使用期间原生代码。 JNI 支持三种引用: 局部引用、全局引用和弱全局引用。下面将介绍这几类引用。</p>
<p><strong>局部引用:</strong></p>
<p>大多数 JNI 函数返回局部引用。局部应用不能在后续的调用中被缓存及重用，主要是因为它们的使用期限仅限于原生方法，一旦原生方法返回，局部引用即被释放。例如: FindClass 函数返回一个局部引用，当原生方法返回时，它被自动释放，也可以用 DeleteLocalRef 函数显式的释放原生代码。如下代码所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jclass personClass;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  <span class="comment">//支持 C 语言</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="comment">//告诉虚拟机，这是jni函数</span></span><br><span class="line">native_test4(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    LOGD(<span class="string">"测试局部引用"</span>)</span><br><span class="line">    <span class="keyword">if</span> (personClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *person_class = <span class="string">"com/devyk/ndk_sample/Person"</span>;</span><br><span class="line">        personClass = env-&gt;FindClass(person_class);</span><br><span class="line">        LOGD(<span class="string">"personClass == null 执行了。"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Java Person 构造方法实例化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sig = <span class="string">"()V"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *method = <span class="string">"&lt;init&gt;"</span>;<span class="comment">//Java 构造方法标识</span></span><br><span class="line">    jmethodID init = env-&gt;GetMethodID(personClass, method, sig);</span><br><span class="line">    <span class="comment">//创建出来</span></span><br><span class="line">    env-&gt;NewObject(personClass, init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200108231036.gif" alt=""></p>
<p>跟介绍的一样的吧。局部引用不能再后续的调用中重复使用，那么怎么解决这个问题勒，其实只要把局部引用提升为全局引用或者调用 DeleteLocalRef 显式释放就行了。这个我们在全局引用中演示。</p>
<p><strong>全局引用:</strong></p>
<p>全局引用在原生方法的后续调用过程中依然有效，除非它们被原生代码显式释放。</p>
<ol>
<li><p>创建全局引用</p>
<p>可以使用 NewGlobalRef 函数将局部引用初始化为全局引用，如下代码所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">jclass personClass;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  <span class="comment">//支持 C 语言</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="comment">//告诉虚拟机，这是jni函数</span></span><br><span class="line">native_test4(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    LOGD(<span class="string">"测试局部引用"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (personClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//1. 提升全局解决不能重复使用问题</span></span><br><span class="line"> 				<span class="keyword">const</span> <span class="keyword">char</span> *person_class = <span class="string">"com/devyk/ndk_sample/Person"</span>;</span><br><span class="line">        jclass jclass1 = env-&gt;FindClass(person_class);</span><br><span class="line">        personClass = <span class="keyword">static_cast</span>&lt;jclass&gt;(env-&gt;NewGlobalRef(jclass1));</span><br><span class="line">        LOGD(<span class="string">"personClass == null 执行了。"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java Person 构造方法实例化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sig = <span class="string">"()V"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *method = <span class="string">"&lt;init&gt;"</span>;<span class="comment">//Java 构造方法标识</span></span><br><span class="line">    jmethodID init = env-&gt;GetMethodID(personClass, method, sig);</span><br><span class="line">    <span class="comment">//创建出来</span></span><br><span class="line">    env-&gt;NewObject(personClass, init);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 显式释放主动删除全局引用</span></span><br><span class="line">    env-&gt;DeleteLocalRef(personClass);</span><br><span class="line">    personClass = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200108232508.gif" alt=""></p>
</li>
<li><p>删除全局引用</p>
<p>当原生代码不再需要一个全局引用时，可以随时用 DeleteGlobalRef 函数释放它，如下代码所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;DeleteLocalRef(personClass);</span><br><span class="line">personClass = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>弱全局引用</strong></p>
<p>全局引用的另一种类型是弱全局引用。与全局引用一样，弱全局引用在原生方法的后续调用依然有效。与全局引用不同，弱全局引用并不阻止潜在的对象被垃圾收回。</p>
<ol>
<li><p>创建弱全局引用</p>
<p>可以使用 NewWeakGlobalRef 函数对弱全局引用进行初始化，如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">jclass personClass;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  <span class="comment">//支持 C 语言</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="comment">//告诉虚拟机，这是jni函数</span></span><br><span class="line">native_test4(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    LOGD(<span class="string">"测试局部引用"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (personClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//1. 提升全局解决不能重复使用问题</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *person_class = <span class="string">"com/devyk/ndk_sample/Person"</span>;</span><br><span class="line">        jclass jclass1 = env-&gt;FindClass(person_class);</span><br><span class="line"><span class="comment">//        personClass = static_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(jclass1));</span></span><br><span class="line">        personClass = <span class="keyword">static_cast</span>&lt;jclass&gt;(env-&gt;NewWeakGlobalRef(jclass1));</span><br><span class="line">        LOGD(<span class="string">"personClass == null 执行了。"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java Person 构造方法实例化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sig = <span class="string">"()V"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *method = <span class="string">"&lt;init&gt;"</span>;<span class="comment">//Java 构造方法标识</span></span><br><span class="line">    jmethodID init = env-&gt;GetMethodID(personClass, method, sig);</span><br><span class="line">    <span class="comment">//创建出来</span></span><br><span class="line">    env-&gt;NewObject(personClass, init);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 显式释放主动删除局部引用</span></span><br><span class="line"><span class="comment">//    env-&gt;DeleteLocalRef(personClass);</span></span><br><span class="line">    env-&gt;DeleteWeakGlobalRef(personClass);</span><br><span class="line">    personClass = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱全局引用的有效性检验</p>
<p>可以用 IsSameObject 函数来检验一个弱全局引用是否仍然指向活动的类实例.</p>
</li>
<li><p>删除弱全局引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;DeleteWeakGlobalRef(personClass);</span><br></pre></td></tr></table></figure>

<p>全局引用显示释放前一直有效，它们可以被其它原生函数及原生线程使用。</p>
</li>
</ol>
<h3 id="8-JNI-线程操作"><a href="#8-JNI-线程操作" class="headerlink" title="8. JNI 线程操作"></a>8. JNI 线程操作</h3><p>作为多线程环境的一部分，虚拟机支持运行的原生代码。在开发构件时要记住 JNI 技术的一些约束:</p>
<ul>
<li>只有再原生方法执行期间及正在执行原生方法的线程环境下局部引用是有效的，局部引用不能再多线程间共享，只有全局可以被多个线程共享。</li>
<li>被传递给每个原生方法的 JNIEvn 接口指针在与方法调用相关的线程中也是有效的，它不能被其它线程缓存或使用。</li>
</ul>
<p><strong>同步:</strong></p>
<p>同步是多线程程序设计最终的特征。与 Java 同步类似， JNI 的监视器允许原生代码利用 Java 对象同步，虚拟机保证存取监视器的线程能够安全执行，而其他线程等待监视器对象变成可用状态。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">MonitorEnter</span><span class="params">(jobject obj)</span></span></span><br></pre></td></tr></table></figure>

<p>对 MonitorEnter 函数的调用应该与对 MonitorExit 的调用相匹配，从而避免代码出现死锁。</p>
<p>例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                count();</span><br><span class="line">                nativeCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        Log.d(<span class="string">"Java"</span>, <span class="string">"count="</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>native 代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  <span class="comment">//支持 C 语言</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="comment">//告诉虚拟机，这是jni函数</span></span><br><span class="line">native_count(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line">    jclass cls = env-&gt;GetObjectClass(instance);</span><br><span class="line">    jfieldID fieldID = env-&gt;GetFieldID(cls, <span class="string">"count"</span>, <span class="string">"I"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*if (env-&gt;MonitorEnter(instance) != JNI_OK) &#123;</span></span><br><span class="line"><span class="comment">        LOGE("%s: MonitorEnter() failed", __FUNCTION__);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* synchronized block */</span></span><br><span class="line">    <span class="keyword">int</span> val = env-&gt;GetIntField(instance, fieldID);</span><br><span class="line">    val++;</span><br><span class="line">    LOGI(<span class="string">"count=%d"</span>, val);</span><br><span class="line">    env-&gt;SetIntField(instance, fieldID, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*if (env-&gt;ExceptionOccurred()) &#123;</span></span><br><span class="line"><span class="comment">        LOGE("ExceptionOccurred()...");</span></span><br><span class="line"><span class="comment">        if (env-&gt;MonitorExit(instance) != JNI_OK) &#123;</span></span><br><span class="line"><span class="comment">            LOGE("%s: MonitorExit() failed", __FUNCTION__);</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (env-&gt;MonitorExit(instance) != JNI_OK) &#123;</span></span><br><span class="line"><span class="comment">        LOGE("%s: MonitorExit() failed", __FUNCTION__);</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 native 中没有进行同步，打印如下:</p>
<blockquote>
<p><strong>输出:</strong></p>
<p>2020-01-09 00:02:29.637 17573-17707/com.devyk.ndk_sample D/Java:         count=1<br>2020-01-09 00:02:29.637 17573-17707/com.devyk.ndk_sample I/native-lib:  count=2<br>2020-01-09 00:02:29.641 17573-17708/com.devyk.ndk_sample D/Java:         count=3<br>2020-01-09 00:02:29.641 17573-17708/com.devyk.ndk_sample I/native-lib:  count=4<br>2020-01-09 00:02:29.641 17573-17709/com.devyk.ndk_sample D/Java:         count=5<br>2020-01-09 00:02:29.641 17573-17709/com.devyk.ndk_sample I/native-lib: count=6<br>2020-01-09 00:02:29.641 17573-17710/com.devyk.ndk_sample D/Java:         count=7<br>2020-01-09 00:02:29.642 17573-17710/com.devyk.ndk_sample I/native-lib: count=8<br>2020-01-09 00:02:29.643 17573-17711/com.devyk.ndk_sample D/Java:         count=9<br>2020-01-09 00:02:29.643 17573-17711/com.devyk.ndk_sample I/native-lib: count=10<br>2020-01-09 00:02:29.643 17573-17712/com.devyk.ndk_sample D/Java:         count=11<br>2020-01-09 00:02:29.643 17573-17712/com.devyk.ndk_sample I/native-lib: count=12<br>2020-01-09 00:02:29.645 17573-17715/com.devyk.ndk_sample D/Java:         count=13<br>2020-01-09 00:02:29.646 17573-17715/com.devyk.ndk_sample I/native-lib: count=15<br>2020-01-09 00:02:29.646 17573-17714/com.devyk.ndk_sample D/Java:         count=15<br>2020-01-09 00:02:29.646 17573-17714/com.devyk.ndk_sample I/native-lib: count=16<br>2020-01-09 00:02:29.648 17573-17713/com.devyk.ndk_sample D/Java:        count=17<br>2020-01-09 00:02:29.648 17573-17713/com.devyk.ndk_sample I/native-lib: count=18<br>2020-01-09 00:02:29.648 17573-17716/com.devyk.ndk_sample D/Java:         count=19<br>2020-01-09 00:02:29.648 17573-17716/com.devyk.ndk_sample I/native-lib: count=20</p>
</blockquote>
<p>通过多线程对 count 字段操作，可以看见已经无法保证 count 的可见性了。这就需要 JNI 本地实现也要同步。</p>
<p>我们把注释放开:</p>
<p>打印如下:</p>
<blockquote>
<p><strong>输出:</strong></p>
<p>2020-01-09 00:07:10.579 18225-18385/com.devyk.ndk_sample D/Java:             count=1<br>2020-01-09 00:07:10.579 18225-18385/com.devyk.ndk_sample I/native-lib:     count=2<br>2020-01-09 00:07:10.581 18225-18386/com.devyk.ndk_sample D/Java:             count=3<br>2020-01-09 00:07:10.581 18225-18386/com.devyk.ndk_sample I/native-lib:     count=4<br>2020-01-09 00:07:10.582 18225-18387/com.devyk.ndk_sample D/Java:             count=5<br>2020-01-09 00:07:10.582 18225-18387/com.devyk.ndk_sample I/native-lib:     count=6<br>2020-01-09 00:07:10.584 18225-18388/com.devyk.ndk_sample D/Java:             count=7<br>2020-01-09 00:07:10.584 18225-18388/com.devyk.ndk_sample I/native-lib:     count=8<br>2020-01-09 00:07:10.586 18225-18390/com.devyk.ndk_sample D/Java:             count=9<br>2020-01-09 00:07:10.586 18225-18390/com.devyk.ndk_sample I/native-lib:     count=10<br>2020-01-09 00:07:10.586 18225-18391/com.devyk.ndk_sample D/Java:             count=11<br>2020-01-09 00:07:10.586 18225-18391/com.devyk.ndk_sample I/native-lib:     count=12<br>2020-01-09 00:07:10.586 18225-18393/com.devyk.ndk_sample D/Java:             count=13<br>2020-01-09 00:07:10.587 18225-18389/com.devyk.ndk_sample D/Java:             count=14<br>2020-01-09 00:07:10.587 18225-18389/com.devyk.ndk_sample I/native-lib:     count=15<br>2020-01-09 00:07:10.587 18225-18393/com.devyk.ndk_sample I/native-lib:     count=16<br>2020-01-09 00:07:10.587 18225-18394/com.devyk.ndk_sample D/Java:             count=17<br>2020-01-09 00:07:10.588 18225-18394/com.devyk.ndk_sample I/native-lib:     count=18<br>2020-01-09 00:07:10.588 18225-18392/com.devyk.ndk_sample D/Java:             count=19<br>2020-01-09 00:07:10.588 18225-18392/com.devyk.ndk_sample I/native-lib:     count=20</p>
</blockquote>
<p>现在保证了count 的可见性了。</p>
<p><strong>原生线程:</strong></p>
<p>为了执行特定任务，这些原生构建可以并行使用原生线程。因为虚拟机不知道原生线程，因此它们不能与 Java 构建直接通信。为了与应用的依然活跃部分交互，原生线程应该先附着在虚拟机上。</p>
<p>JNI 通过 JavaVM 接口指针提供了 AttachCurrentThread 函数以便于让原生代码将原生线程附着到虚拟机上，如下代码所示, JavaVM 接口指针应该尽早被缓存，否则的话它不能被获取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaVM* jvm；</span><br><span class="line">...</span><br><span class="line">JNIEnv* env = <span class="literal">NULL</span>；</span><br><span class="line">...</span><br><span class="line">jvm-&gt;AttachCurrentThread(&amp;env,<span class="number">0</span>);<span class="comment">//把 native 线程附着到 JVM 上</span></span><br><span class="line">...</span><br><span class="line">jvm-&gt;DetachCurrentThread();<span class="comment">//解除 附着 到 JVM 的 native 线程</span></span><br></pre></td></tr></table></figure>

<p>对 AttachCurrentThread 函数的调用允许应用程序获得对当前线程有效的 JNIEnv 接口指针。将一个已经附着的原生线程再次附着不会有任何副作用。当原生线程完成时，可以用 DetachCurrentThread 函数将原生线程与虚拟机分离。</p>
<p>例子:</p>
<p>MainActivity.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    testThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AndroidUI操作，让C++线程里面来调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Looper.getMainLooper() == Looper.myLooper()) &#123;</span><br><span class="line">        <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">                .setTitle(<span class="string">"UI"</span>)</span><br><span class="line">                .setMessage(<span class="string">"native 运行在主线程，直接更新 UI ..."</span>)</span><br><span class="line">                .setPositiveButton(<span class="string">"确认"</span>, <span class="keyword">null</span>)</span><br><span class="line">                .show();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">                        .setTitle(<span class="string">"UI"</span>)</span><br><span class="line">                        .setMessage(<span class="string">"native运行在子线程切换为主线程更新 UI ..."</span>)</span><br><span class="line">                        .setPositiveButton(<span class="string">"确认"</span>, <span class="keyword">null</span>)</span><br><span class="line">                        .show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">testThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    unThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>native-lib.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">JavaVM * jvm;</span><br><span class="line">jobject instance;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customThread</span><span class="params">(<span class="keyword">void</span> * pVoid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用的话，一定需要JNIEnv *env</span></span><br><span class="line">    <span class="comment">// JNIEnv *env 无法跨越线程，只有JavaVM才能跨越线程</span></span><br><span class="line"></span><br><span class="line">    JNIEnv * env = <span class="literal">NULL</span>; <span class="comment">// 全新的env</span></span><br><span class="line">    <span class="keyword">int</span> result = jvm-&gt;AttachCurrentThread(&amp;env, <span class="number">0</span>); <span class="comment">// 把native的线程，附加到JVM</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jclass mainActivityClass = env-&gt;GetObjectClass(instance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到MainActivity的updateUI</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * sig = <span class="string">"()V"</span>;</span><br><span class="line">    jmethodID updateUI = env-&gt;GetMethodID(mainActivityClass, <span class="string">"updateUI"</span>, sig);</span><br><span class="line"></span><br><span class="line">    env-&gt;CallVoidMethod(instance, updateUI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除 附加 到 JVM 的native线程</span></span><br><span class="line">    jvm-&gt;DetachCurrentThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  <span class="comment">//支持 C 语言</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="comment">//告诉虚拟机，这是jni函数</span></span><br><span class="line">native_testThread(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    instance = env-&gt;NewGlobalRef(thiz); <span class="comment">// 全局的，就不会被释放，所以可以在线程里面用</span></span><br><span class="line">    <span class="comment">// 如果是非全局的，函数一结束，就被释放了</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadID;</span><br><span class="line">    pthread_create(&amp;pthreadID, <span class="number">0</span>, customThread, instance);</span><br><span class="line">    pthread_join(pthreadID, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  <span class="comment">//支持 C 语言</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="comment">//告诉虚拟机，这是jni函数</span></span><br><span class="line">native_unThread(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != instance) &#123;</span><br><span class="line">        env-&gt;DeleteGlobalRef(instance);</span><br><span class="line">        instance = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200109003303.gif" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该篇文件全面介绍了 JNI 技术实现 Java 应用程序与原生代码之间通信的方式，关于更多 JNI 技术可以下载  <a href="https://pan.baidu.com/s/1HudsXKOghlmHEcMMlp1W6g">JNI 使用手册</a> 。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T09:40:00.000Z" title="2020-06-04T09:40:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">3 小时 读完 (大约 28994 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%BA%8C-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/">音视频学习 (二) C++ 语言入门</a></h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200106223914.png" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章我们学习了 C 语言基础，那么按照咱们的学习计划该学习 C++ 语言基础了，如果没有 C/C++ 基础了可以按照我的文章序列跟着敲一篇，不会没什么可怕的，可怕的是不会还不练习，光看是学不会的。前面几篇学习语言基础我知道很枯燥，但是没有 C/C++ 语言基础到时候学习 NDK 的内容你就更看不懂了，完全就像是在看科幻片一样。所以，我们一起加油，一起学习，共同进步 。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>如果您使用的是 Mac ，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。</p>
<p>开发工具我这里还是使用的 CLion , 下一篇文章讲解 JNI 技术就开始用  AndroidStudio 。</p>
<h2 id="C-语言入门"><a href="#C-语言入门" class="headerlink" title="C++ 语言入门"></a>C++ 语言入门</h2><p>还是以 ”HelloWorld“ 打开 C++ 的门。</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="comment">// 空间命名</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//跟 C 一样入口都是 main 函数</span></span><br><span class="line">  test1();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 使用命名空间</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "C++ 语言入门第一行代码 Hello World!" &lt;&lt; endl;</span></span><br><span class="line">  	<span class="comment">//就是一个对 C++ 打印的封装</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">""</span>, <span class="string">"C++ 语言入门第一行代码 Hello World!"</span>);</span><br><span class="line">    <span class="comment">//未使用命名空间</span></span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; "C++ 语言入门第一行代码 Hello World!" &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++ 语言入门第一行代码 Hello World!</span><br></pre></td></tr></table></figure>

<p>下面我们就来解释一下上面这段最简单的程序的组成部分</p>
<ul>
<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <strong><iostream></strong>。</li>
<li>下一行是一个 // 的注释。</li>
<li>下一行 <strong>using namespace std;</strong> 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>
<li>下一行 <strong>int main()</strong> 是主函数，程序从这里开始执行。</li>
<li>下一行调用 test1() 函数</li>
<li>下一行 <strong>cout &lt;&lt; “C++ 语言入门第一行代码 Hello World!” &lt;&lt; endl;</strong> 会在屏幕上显示消息 “C++ 语言入门第一行代码 Hello World!”。</li>
<li>下一行 <strong>return 0;</strong> 终止 main( )函数，并向调用进程返回值 0。</li>
</ul>
<p>中间忽略了一些注释讲解，我相信这还是能看懂的。; </p>
<p><strong>1. 使用 g++ 编译</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ *.cpp *.h</span><br><span class="line">$ .&#x2F;a.out</span><br></pre></td></tr></table></figure>

<p>g++ 后面跟用到了的 cpp h 文件</p>
<p><strong>2. 使用 Clion 工具编译</strong></p>
<p>直接点击 run,如下所示:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20191219181436.gif" alt=""></p>
<p>跟 C，Java 一样。</p>
<h3 id="2-C-关键字"><a href="#2-C-关键字" class="headerlink" title="2. C++ 关键字"></a>2. C++ 关键字</h3><p>下面表格描述了 C++ 中的关键字。这些关键字跟 C/Java 一样都不能作为常量名，变量名或其它标识符名称。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>asm</strong></td>
<td>允许在 C++ 程序中嵌入汇编代码</td>
<td><strong>auto</strong></td>
<td>（自动，automatic）是存储类型标识符，表明变量”自动”具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。</td>
</tr>
<tr>
<td><strong>bool</strong></td>
<td>bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。</td>
<td><strong>break</strong></td>
<td>break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。</td>
</tr>
<tr>
<td><strong>case</strong></td>
<td>用于 switch 语句中，用于判断不同的条件类型。</td>
<td><strong>namespace</strong></td>
<td>namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。</td>
</tr>
<tr>
<td><strong>catch</strong></td>
<td>catch 和 try 语句一起用于异常处理。</td>
<td><strong>new</strong></td>
<td>new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建</td>
</tr>
<tr>
<td><strong>char</strong></td>
<td>char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 <strong>‘</strong> 括起来。</td>
<td><strong>operator</strong></td>
<td>operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。</td>
</tr>
<tr>
<td><strong>class</strong></td>
<td>class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。</td>
<td><strong>private</strong></td>
<td>private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。</td>
</tr>
<tr>
<td><strong>const</strong></td>
<td>const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。</td>
<td><strong>protected</strong></td>
<td>protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。</td>
</tr>
<tr>
<td><strong>const_cast</strong></td>
<td>该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</td>
<td><strong>public</strong></td>
<td>public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类</td>
</tr>
<tr>
<td><strong>continue</strong></td>
<td>continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是”继续循环”之意，不是 break（跳出）。</td>
<td><strong>register</strong></td>
<td>register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。</td>
</tr>
<tr>
<td><strong>default</strong></td>
<td>default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。</td>
<td><strong>reinterpret_cast</strong></td>
<td>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。</td>
</tr>
<tr>
<td><strong>delete</strong></td>
<td>delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。</td>
<td><strong>return</strong></td>
<td>return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。</td>
</tr>
<tr>
<td><strong>do</strong></td>
<td>do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。</td>
<td><strong>short</strong></td>
<td>short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。</td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。</td>
<td><strong>signed</strong></td>
<td>signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。</td>
</tr>
<tr>
<td><strong>dynamic_cast</strong></td>
<td>dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。</td>
<td><strong>sizeof</strong></td>
<td>由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 sizeof 运算符获得该数据类型占用的字节数。</td>
</tr>
<tr>
<td><strong>else</strong></td>
<td>else 紧跟在 if 后面，用于对 if 不成立的情况的选择。</td>
<td><strong>static</strong></td>
<td>static（静态的）静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。静态变量或静态函数，只有本文件内的代码才可访问它，它的名字（变量名或函数名）在其它文件中不可见。因此也称为”文件作用域”。在 C++ 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private 类型的也不例外。</td>
</tr>
<tr>
<td><strong>enum</strong></td>
<td>enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。</td>
<td><strong>static_cast</strong></td>
<td>该运算符把 expression 转换为 type-id 类型，但没有运行时类型检查来保证转换的安全性。</td>
</tr>
<tr>
<td><strong>explicit</strong></td>
<td>explicit（显式的）的作用是”禁止单参数构造函数”被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。</td>
<td><strong>struct</strong></td>
<td>struct（结构）类型，类似于 class 关键字，与 C 语言兼容（class 关键字是不与 C 语言兼容的），可以实现面向对象程序设计。</td>
</tr>
<tr>
<td><strong>export</strong></td>
<td>为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。</td>
<td><strong>switch</strong></td>
<td>switch（转换）类似于 if-else-if 语句，是一种多分枝语句。它提供了一种简洁的书写，并且能够生成效率更好的代码。但是，switch 后面的判断只能是int（char也可以，但char本质上也是一种int类型）。switch 语句最后的 default 分支是可选的。</td>
</tr>
<tr>
<td><strong>extern</strong></td>
<td>extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 <strong>C</strong> 转换标记，来支持 C 编译器链接。</td>
<td><strong>template</strong></td>
<td>template（模板），C++ 中泛型机制的实现。</td>
</tr>
<tr>
<td><strong>false</strong></td>
<td>false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。</td>
<td><strong>this</strong></td>
<td>this 返回调用者本身的指针。</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>float（浮点数），C++ 中的基本数据结构，精度小于 double。</td>
<td><strong>throw</strong></td>
<td>throw（抛出）用于实现 C++ 的异常处理机制，可以通过 throw 关键字”抛出”一个异常。</td>
</tr>
<tr>
<td><strong>for</strong></td>
<td>for 是 C++ 中的循环结构之一。</td>
<td><strong>true</strong></td>
<td>true（真的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的非 0 值。</td>
</tr>
<tr>
<td><strong>friend</strong></td>
<td>friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。</td>
<td><strong>try</strong></td>
<td>try（尝试）用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理。</td>
</tr>
<tr>
<td><strong>goto</strong></td>
<td>goto（转到），用于无条件跳转到某一标号处开始执行。</td>
<td><strong>typedef</strong></td>
<td>类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。</td>
</tr>
<tr>
<td><strong>if</strong></td>
<td>if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。</td>
<td><strong>typeid</strong></td>
<td>指出指针或引用指向的对象的实际派生类型。</td>
</tr>
<tr>
<td><strong>inline</strong></td>
<td>inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。</td>
<td><strong>typename</strong></td>
<td>typename（类型名字）关键字告诉编译器把一个特殊的名字解释成一个类型。</td>
</tr>
<tr>
<td><strong>int</strong></td>
<td>int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。</td>
<td><strong>union</strong></td>
<td>union（联合），类似于 enum。不同的是 enum 实质上是 int 类型的，而 union 可以用于所有类型，并且其占用空间是随着实际类型大小变化的。</td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。</td>
<td><strong>unsigned</strong></td>
<td>unsigned（无符号），表明该类型是无符号数，和 signed 相反。</td>
</tr>
<tr>
<td><strong>mutable</strong></td>
<td>mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。</td>
<td><strong>using</strong></td>
<td>表明使用 namespace。</td>
</tr>
<tr>
<td><strong>virtual</strong></td>
<td>virtual（虚的），C++ 中用来实现多态机制。</td>
<td><strong>void</strong></td>
<td>void（空的），可以作为函数返回值，表明不返回任何数据；可以作为参数，表明没有参数传入（C++中不是必须的）；可以作为指针使用。</td>
</tr>
<tr>
<td><strong>volatile</strong></td>
<td>volatile（不稳定的）限定一个对象可被外部进程（操作系统、硬件或并发线程等）改变</td>
<td><strong>wchar_t</strong></td>
<td>wchar_t 是宽字符类型，每个 wchar_t 类型占 2 个字节，16 位宽。汉字的表示就要用到 wchar_t。</td>
</tr>
</tbody></table>
<h3 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h3><p><strong>基本的内置类型</strong></p>
<p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">布尔型</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">字符型</td>
<td align="left">char</td>
</tr>
<tr>
<td align="left">整型</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">浮点型</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">双浮点型</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">无类型</td>
<td align="left">void</td>
</tr>
<tr>
<td align="left">宽字符型</td>
<td align="left">wchar_t (wchar_t 实际上的空间是和 short int 一样)</td>
</tr>
</tbody></table>
<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>
<p><strong>注意：</strong>不同系统会有所差异。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 个字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">4 个字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="left">signed int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">unsigned short int</td>
<td align="left">2 个字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">signed short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">signed long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">unsigned long int</td>
<td align="left">8 个字节</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">4 个字节</td>
<td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 个字节</td>
<td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 个字节</td>
<td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">2 或 4 个字节</td>
<td align="left">1 个宽字符</td>
</tr>
</tbody></table>
<p>从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。</p>
<p>下面实例会输出您电脑上各种数据类型的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"C++\t\t"</span>, <span class="string">"**************基本数据类型 Size ***********\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"bool\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">bool</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">bool</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"char\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">char</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">char</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"unsigned char\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"signed char\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">char</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">signed</span> <span class="keyword">char</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">signed</span> <span class="keyword">char</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"unsigned int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"signed int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">signed</span> <span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">signed</span> <span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"short int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(short <span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;short <span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;short <span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"unsigned short int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> short <span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">unsigned</span> short <span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">unsigned</span> short <span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"signed short int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">signed</span> short <span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">signed</span> short <span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">signed</span> short <span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"long int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"signed long int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"unsigned long int\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"float\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">float</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">float</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"double\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"long double\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"wchar_t\t\t"</span>, <span class="string">"所占字节数:"</span>, <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>), <span class="string">"\t\t最大值:"</span>,</span><br><span class="line">            (numeric_limits&lt;<span class="keyword">wchar_t</span>&gt;::<span class="built_in">max</span>)(), <span class="string">"\t\t最小值:"</span>, (numeric_limits&lt;<span class="keyword">wchar_t</span>&gt;::<span class="built_in">min</span>)());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *   bool                 所占字节数:1       最大值:1                 最小值:0</span><br><span class="line"> *   char                 所占字节数:1       最大值:127               最小值:-128</span><br><span class="line"> *   unsigned char        所占字节数:1       最大值:255               最小值:0</span><br><span class="line"> *   signed char          所占字节数:1       最大值:127               最小值:-128</span><br><span class="line"> *   int                  所占字节数:4       最大值:2147483647        最小值:-2147483648</span><br><span class="line"> *   unsigned int         所占字节数:4       最大值:-1            		最小值:0</span><br><span class="line"> *   signed int           所占字节数:4       最大值:2147483647    		最小值:-2147483648</span><br><span class="line"> *   short int            所占字节数:2       最大值:32767             最小值:-32768</span><br><span class="line"> *   unsigned short int   所占字节数:2       最大值:65535             最小值:0</span><br><span class="line"> *   signed short int     所占字节数:2       最大值:32767             最小值:-32768</span><br><span class="line"> *   long int             所占字节数:8       最大值:-1            		最小值:0</span><br><span class="line"> *   signed long int      所占字节数:8       最大值:-1            		最小值:0</span><br><span class="line"> *   unsigned long int    所占字节数:8       最大值:-1            		最小值:0</span><br><span class="line"> *   float                所占字节数:4       最大值:-2147483648       最小值:0</span><br><span class="line"> *   double               所占字节数:8       最大值:-2147483648       最小值:0</span><br><span class="line"> *   long double          所占字节数:16      最大值:-2147483648       最小值:0</span><br><span class="line"> *   wchar_t              所占字节数:4       最大值:2147483647    		最小值:-2147483648</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>typedef 声明</strong></p>
<p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式: typedef type newname; </span></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> feet;</span><br></pre></td></tr></table></figure>

<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure>

<p><strong>枚举类型</strong></p>
<p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong> 跟 Java 语法差不多。枚举类型的一般形式为： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123; </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>

<p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>
<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure>

<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, green=<span class="number">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>
<h3 id="5-变量类型"><a href="#5-变量类型" class="headerlink" title="5. 变量类型"></a>5. 变量类型</h3><p>变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。</p>
<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解。</p>
<p>下面我们将讲解如何定义、声明和使用各种类型的变量。</p>
<p><strong>定义:</strong></p>
<p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：type variable_list;</span></span><br><span class="line"><span class="comment">//在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子:</span></span><br><span class="line"><span class="keyword">int</span>    i, j, k;</span><br><span class="line"><span class="keyword">char</span>   c, ch;</span><br><span class="line"><span class="keyword">float</span>  f, salary;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure>

<p><strong>变量声明:</strong></p>
<p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<p><strong>例子:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//变量定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"声明变量\t"</span>, <span class="string">"a + b="</span>, c);</span><br><span class="line"></span><br><span class="line">    f = <span class="number">10</span> / <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"声明变量\t"</span>, <span class="string">"10/3="</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>声明变量    a + b=30<br>声明变量    10/3=3</p>
</blockquote>
<h3 id="6-变量作用域"><a href="#6-变量作用域" class="headerlink" title="6. 变量作用域"></a>6. 变量作用域</h3><p>作用域是程序的一个区域，一般来说有三个地方可以定义变量：</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>在函数参数的定义中声明的变量，称为形式参数。</li>
<li>在所有函数外部声明的变量，称为全局变量。</li>
</ul>
<p>我们将在后续的小节中学习什么是函数和参数。本小节我们先来讲解什么是局部变量和全局变量。</p>
<p><strong>局部变量:</strong></p>
<p>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//局部变量声明</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = i * j;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"局部变量:"</span>, <span class="string">"i * j="</span>, c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>局部变量:i * j=200</p>
</blockquote>
<p><strong>全局变量:</strong></p>
<p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>
<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g, l = <span class="number">20</span>;<span class="comment">//声明全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//局部变量声明</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = i * j;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"局部变量:"</span>, <span class="string">"i * j="</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值给全局变量</span></span><br><span class="line">    g = (<span class="keyword">int</span>)i / j;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"全局变量:"</span>, <span class="string">"i / j="</span>, g);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"全局变量:"</span>, <span class="string">"l ="</span>, l);</span><br><span class="line">    l = <span class="number">100</span>;<span class="comment">//重新赋值给全局变量 l</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"全局变量:"</span>, <span class="string">"l ="</span>, l);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>局部变量:i * j=100<br>全局变量:i / j=1<br>全局变量:l =20<br>全局变量:l =100</p>
</blockquote>
<p><strong>初始化局部变量和全局变量:</strong></p>
<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\0’</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">pointer</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。</p>
<h3 id="7-常量"><a href="#7-常量" class="headerlink" title="7. 常量"></a>7. 常量</h3><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p>
<p><strong>整数常量:</strong></p>
<p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
<p>下面列举几个整数常量的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">// 合法的</span></span><br><span class="line"><span class="number">215u</span>        <span class="comment">// 合法的</span></span><br><span class="line"><span class="number">0xFee</span>L      <span class="comment">// 合法的</span></span><br><span class="line"><span class="number">078</span>         <span class="comment">// 非法的：8 不是八进制的数字</span></span><br><span class="line"><span class="number">032U</span>U       <span class="comment">// 非法的：不能重复后缀</span></span><br><span class="line">  </span><br><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30u</span>l       <span class="comment">// 无符号长整数</span></span><br></pre></td></tr></table></figure>

<p><strong>浮点常量:</strong></p>
<p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<p>下面列举几个浮点常量的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的 </span></span><br><span class="line"><span class="number">314159E-5</span>L    <span class="comment">// 合法的 </span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">// 非法的：不完整的指数</span></span><br><span class="line"><span class="number">210f</span>          <span class="comment">// 非法的：没有小数或指数</span></span><br><span class="line">.e55          <span class="comment">// 非法的：缺少整数或分数</span></span><br></pre></td></tr></table></figure>

<p><strong>布尔常量:</strong></p>
<p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<ul>
<li><strong>true</strong> 值代表真。</li>
<li><strong>false</strong> 值代表假。</li>
</ul>
<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>
<p><strong>字符常量:</strong></p>
<p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">\ 字符</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">‘ 字符</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">“ 字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">? 字符</td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">警报铃声</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格键</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left">\ooo</td>
<td align="left">一到三位的八进制数</td>
</tr>
<tr>
<td align="left">\xhh . . .</td>
<td align="left">一个或多个数字的十六进制数</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字符常量</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"字符常量"</span>, <span class="string">"\tC\n+\n+\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>字符常量    C<br>+<br>+</p>
</blockquote>
<p><strong>字符串常量:</strong></p>
<p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<p>下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello, World"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello, \</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">World"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello, "</span> <span class="string">"W"</span> <span class="string">"orld"</span></span><br></pre></td></tr></table></figure>

<p><strong>定义常量:</strong></p>
<p>在 C++ 中，有两种简单的定义常量的方式：</p>
<ul>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义常量 const,#define</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"DevYK"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Blog <span class="meta-string">"https://www.devyk.top"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> _NAME = <span class="string">"DevYK"</span>, _Blog = <span class="string">"https://www.devyk.top"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打印定义的常量</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"#define 定义常量:"</span>, NAME <span class="string">"\t"</span> Blog);</span><br><span class="line">    <span class="comment">//const 定义的常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">10</span>, <span class="built_in">width</span> = <span class="number">20</span>, <span class="built_in">height</span> = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"const 定义的常量\t"</span> &lt;&lt; _NAME &lt;&lt; <span class="string">"\t"</span> + _Blog &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"const 定义常量\t"</span>, <span class="string">"求 width * height * length = "</span>, length * <span class="built_in">width</span> * <span class="built_in">height</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>define 定义常量:DevYK    <a href="https://www.devyk.top">https://www.devyk.top</a><br>const 定义的常量    DevYK    <a href="https://www.devyk.top">https://www.devyk.top</a><br>const 定义常量    求 width * height * length = 6000</p>
</blockquote>
<h3 id="8-修饰符类型"><a href="#8-修饰符类型" class="headerlink" title="8. 修饰符类型"></a>8. 修饰符类型</h3><p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>
<p>下面列出了数据类型修饰符：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>long</li>
<li>short</li>
</ul>
<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>
<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>
<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>unsigned、long</strong>，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> x;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> y;</span><br></pre></td></tr></table></figure>

<p>为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//演示有符号和无符号整数之间的差别</span></span><br><span class="line">    short <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    short <span class="keyword">unsigned</span> <span class="keyword">int</span> j;</span><br><span class="line">    j = <span class="number">50000</span>;</span><br><span class="line">    i = j;</span><br><span class="line">    k = j;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>-15536 50000 50000</p>
</blockquote>
<p>上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。</p>
<h3 id="9-存储类"><a href="#9-存储类" class="headerlink" title="9. 存储类"></a>9. 存储类</h3><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
<p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<p><strong>auto 存储类:</strong></p>
<p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>
<p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。</p>
<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">'r'</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure>

<p><strong>register 存储类:</strong></p>
<p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="keyword">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<p><strong>static 存储类:</strong></p>
<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test7_fun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> valueCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">while</span>(valueCount--)&#123;</span><br><span class="line">        test7_fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test7_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line">    value++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"变量 value 为："</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"变量 valueCount 为："</span> &lt;&lt; valueCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>变量 value 为：6<br>变量 valueCount 为：4<br>变量 value 为：7<br>变量 valueCount 为：3<br>变量 value 为：8<br>变量 valueCount 为：2<br>变量 value 为：9<br>变量 valueCount 为：1<br>变量 value 为：10<br>变量 valueCount 为：0</p>
</blockquote>
<p><strong>extern 存储类:</strong></p>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p>第一个文件: main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern 存储值</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">value_extern</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个文件：main_1.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">value_extern</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"value_extern 执行了"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>value_extern 执行了</p>
</blockquote>
<h3 id="10-运算符"><a href="#10-运算符" class="headerlink" title="10. 运算符"></a>10. 运算符</h3><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<p>本小节将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。</p>
<p><strong>算术运算符:</strong></p>
<p>下表显示了 C++ 支持的算术运算符。</p>
<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">把两个操作数相加</td>
<td align="left">A + B 将得到 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">从第一个操作数中减去第二个操作数</td>
<td align="left">A - B 将得到 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">把两个操作数相乘</td>
<td align="left">A * B 将得到 200</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">分子除以分母</td>
<td align="left">B / A 将得到 2</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取模运算符，整除后的余数</td>
<td align="left">B % A 将得到 0</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html">自增运算符</a>，整数值增加 1</td>
<td align="left">A++ 将得到 11</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html">自减运算符</a>，整数值减少 1</td>
<td align="left">A– 将得到 9</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//算术运算符</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 1 - c 的值是 "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c = a - b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 2 - c 的值是 "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c = a * b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 3 - c 的值是 "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c = a / b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 4 - c 的值是 "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c = a % b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 5 - c 的值是 "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">10</span>;   <span class="comment">//  测试自增、自减</span></span><br><span class="line">    c = d++; <span class="comment">//先赋值，再自增</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 6 - c 的值是 "</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    d = <span class="number">12</span>;    <span class="comment">// 重新赋值</span></span><br><span class="line">    c = d--; <span class="comment">//先赋值，再自减</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 7 - c 的值是 "</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>Line 1 - c 的值是 31<br>Line 2 - c 的值是 11<br>Line 3 - c 的值是 210<br>Line 4 - c 的值是 2<br>Line 5 - c 的值是 1<br>Line 6 - c 的值是 10 11<br>Line 7 - c 的值是 12 11</p>
</blockquote>
<p><strong>关系运算符:</strong></p>
<p>下表显示了 C++ 支持的关系运算符。</p>
<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="left">(A == B) 不为真。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td align="left">(A != B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &gt; B) 不为真。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &lt; B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &gt;= B) 不为真。</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &lt;= B) 为</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//关系运算符</span></span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 1 - a 等于 b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 1 - a 不等于 b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 2 - a 小于 b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 2 - a 不小于 b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 3 - a 大于 b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 3 - a 不大于 b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 改变 a 和 b 的值 */</span></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 4 - a 小于或等于 b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 5 - b 大于或等于 a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>Line 1 - a 不等于 b<br>Line 2 - a 不小于 b<br>Line 3 - a 大于 b<br>Line 4 - a 小于或等于 b<br>Line 5 - b 大于或等于 a</p>
</blockquote>
<p><strong>逻辑运算符:</strong></p>
<p>下表显示了 C++ 支持的关系逻辑运算符。</p>
<p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td align="left">(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td align="left">(A || B) 为真。</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td align="left">!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//逻辑运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 1 - 条件为真"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a || b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 2 - 条件为真"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 改变 a 和 b 的值 */</span></span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 3 - 条件为真"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 4 - 条件不为真"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(a &amp;&amp; b)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 5 - 条件为真"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>Line 1 - 条件为真<br>Line 2 - 条件为真<br>Line 4 - 条件不为真<br>Line 5 - 条件为真</p>
</blockquote>
<p><strong>位运算符:</strong></p>
<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr>
<th align="left">p</th>
<th align="left">q</th>
<th align="left">p &amp; q</th>
<th align="left">p | q</th>
<th align="left">p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-—————-</p>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A  = 1100 0011</p>
<p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
<td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
<td align="left">(A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
<td align="left">(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>
<td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
<td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
<td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"\n\n\n"</span>, <span class="string">"位运算符"</span>);</span><br><span class="line">    <span class="comment">//位运算符</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> aW = <span class="number">60</span>;      <span class="comment">// 60 = 0011 1100</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bW = <span class="number">13</span>;      <span class="comment">// 13 = 0000 1101</span></span><br><span class="line">    <span class="keyword">int</span> cW = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cW = aW &amp; bW;             <span class="comment">// 12 = 0000 1100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 1 - cW 的值是 "</span> &lt;&lt; cW &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cW = aW | bW;             <span class="comment">// 61 = 0011 1101</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 2 - cW 的值是 "</span> &lt;&lt; cW &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cW = aW ^ bW;             <span class="comment">// 49 = 0011 0001</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 3 - cW 的值是 "</span> &lt;&lt; cW &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cW = ~aW;                <span class="comment">// -61 = 1100 0011</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 4 - cW 的值是 "</span> &lt;&lt; cW &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cW = aW &lt;&lt; <span class="number">2</span>;            <span class="comment">// 240 = 1111 0000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 5 - cW 的值是 "</span> &lt;&lt; cW &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cW = aW &gt;&gt; <span class="number">2</span>;            <span class="comment">// 15 = 0000 1111</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 6 - cW 的值是 "</span> &lt;&lt; cW &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<blockquote>
<p>Line 1 - cW 的值是 12<br>Line 2 - cW 的值是 61<br>Line 3 - cW 的值是 49<br>Line 4 - cW 的值是 -61<br>Line 5 - cW 的值是 240<br>Line 6 - cW 的值是 15</p>
</blockquote>
<p><strong>赋值运算符:</strong></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td align="left">C = A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td align="left">+=</td>
<td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td align="left">C += A 相当于 C = C + A</td>
</tr>
<tr>
<td align="left">-=</td>
<td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td align="left">C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td align="left">*=</td>
<td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td align="left">C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td align="left">/=</td>
<td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td align="left">C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td align="left">%=</td>
<td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td align="left">C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td align="left">&lt;&lt;=</td>
<td align="left">左移且赋值运算符</td>
<td align="left">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td align="left">&gt;&gt;=</td>
<td align="left">右移且赋值运算符</td>
<td align="left">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td align="left">&amp;=</td>
<td align="left">按位与且赋值运算符</td>
<td align="left">C &amp;= 2 等同于 C = C &amp; 2</td>
</tr>
<tr>
<td align="left">^=</td>
<td align="left">按位异或且赋值运算符</td>
<td align="left">C ^= 2 等同于 C = C ^ 2</td>
</tr>
<tr>
<td align="left">|=</td>
<td align="left">按位或且赋值运算符</td>
<td align="left">C |= 2 等同于 C = C | 2</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"\n\n\n"</span>, <span class="string">"赋值运算符"</span>);</span><br><span class="line">    a = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">//赋值运算符</span></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 1 - =  运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c += a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 2 - += 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c -= a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 3 - -= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c *= a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 4 - *= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c /= a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 5 - /= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c = <span class="number">200</span>;</span><br><span class="line">    c %= a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 6 - %= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 7 - &lt;&lt;= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 8 - &gt;&gt;= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c &amp;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 9 - &amp;= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c ^= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 10 - ^= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c |= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 11 - |= 运算符实例，c 的值 = : "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出:</p>
<p>Line 1 - =  运算符实例，c 的值 = : 50<br>Line 2 - += 运算符实例，c 的值 = : 100<br>Line 3 - -= 运算符实例，c 的值 = : 50<br>Line 4 - *= 运算符实例，c 的值 = : 2500<br>Line 5 - /= 运算符实例，c 的值 = : 50<br>Line 6 - %= 运算符实例，c 的值 = : 0<br>Line 7 - &lt;&lt;= 运算符实例，c 的值 = : 0<br>Line 8 - &gt;&gt;= 运算符实例，c 的值 = : 0<br>Line 9 - &amp;= 运算符实例，c 的值 = : 0<br>Line 10 - ^= 运算符实例，c 的值 = : 2<br>Line 11 - |= 运算符实例，c 的值 = : 2</p>
</blockquote>
<p><strong>其它:</strong></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sizeof</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-sizeof-operator.html">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td>
</tr>
<tr>
<td align="left">Condition ? X : Y</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td>
</tr>
<tr>
<td align="left">,</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td>
</tr>
<tr>
<td align="left">.（点）和 -&gt;（箭头）</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td>
</tr>
<tr>
<td align="left">Cast</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td>
</tr>
</tbody></table>
<h3 id="11-循环"><a href="#11-循环" class="headerlink" title="11. 循环"></a>11. 循环</h3><p>C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p>
<table>
<thead>
<tr>
<th align="left">循环类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-while-loop.html">while 循环</a></td>
<td align="left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-for-loop.html">for 循环</a></td>
<td align="left">多次执行一个语句序列，简化管理循环变量的代码。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-do-while-loop.html">do…while 循环</a></td>
<td align="left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-nested-loops.html">嵌套循环</a></td>
<td align="left">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>
</tr>
</tbody></table>
<p><strong>循环控制语句:</strong></p>
<p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p>
<p>C++ 提供了下列的控制语句。点击链接查看每个语句的细节。</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-break-statement.html">break 语句</a></td>
<td align="left">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-continue-statement.html">continue 语句</a></td>
<td align="left">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-goto-statement.html">goto 语句</a></td>
<td align="left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>
</tr>
</tbody></table>
<p><strong>死循环:</strong></p>
<p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">//也可以使用  while (true)&#123;&#125;</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This loop will run forever.\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。</p>
<p><strong>注意：</strong>您可以按 Ctrl + C 键终止一个无限循环。</p>
<p><strong>例子:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"=="</span> &lt;&lt; i % <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//跳出当前循环，继续下一次操作</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"跳出循环"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历中..."</span> &lt;&lt; <span class="string">"=="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"j 跳出循环"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"j 就遍历中..."</span> &lt;&lt; <span class="string">"=="</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>遍历中…==0<br>1==1<br>遍历中…==2<br>3==1<br>遍历中…==4<br>5==1<br>遍历中…==6<br>7==1<br>跳出循环<br>j 就遍历中…==0<br>j 跳出循环</p>
</blockquote>
<h3 id="12-判断"><a href="#12-判断" class="headerlink" title="12. 判断"></a>12. 判断</h3><p><strong>判断语句:</strong></p>
<p>C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-if.html">if 语句</a></td>
<td align="left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-if-else.html">if…else 语句</a></td>
<td align="left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-nested-if.html">嵌套 if 语句</a></td>
<td align="left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-switch.html">switch 语句</a></td>
<td align="left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-nested-switch.html">嵌套 switch 语句</a></td>
<td align="left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td>
</tr>
</tbody></table>
<p><strong>三元运算符:</strong></p>
<p>我们已经在前面的章节中讲解了 <a href="https://www.runoob.com/cplusplus/cpp-conditional-operator.html"><strong>条件运算符 ? :</strong></a>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">		<span class="comment">//格式：Exp1 ? Exp2 : Exp3;</span></span><br><span class="line">  	<span class="comment">//其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</span></span><br><span class="line">		<span class="comment">//? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的			//值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</span></span><br><span class="line">    i = i == <span class="number">10</span> ? i = <span class="number">9</span> : i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>9</p>
</blockquote>
<h3 id="13-函数"><a href="#13-函数" class="headerlink" title="13. 函数"></a>13. 函数</h3><p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>
<p><strong>定义函数:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数声明:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式: return_type function_name( parameter list );</span></span><br><span class="line"><span class="comment">//例子:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>
<p><strong>调用函数:</strong></p>
<p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>
<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用函数来获取最大值</span></span><br><span class="line">   ret = <span class="built_in">max</span>(a, b);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max value is : "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>Max value is : 200</p>
</blockquote>
<p><strong>函数参数:</strong></p>
<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有三种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-value.html">传值调用</a></td>
<td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html">指针调用</a></td>
<td align="left">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html">引用调用</a></td>
<td align="left">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
</tbody></table>
<p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。</p>
<p><strong>参数的默认值:</strong></p>
<p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>
<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">  result = a + b;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用函数来添加值</span></span><br><span class="line">   result = sum(a, b);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 再次调用函数</span></span><br><span class="line">   result = sum(a);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>Total value is :300<br>Total value is :120</p>
</blockquote>
<h3 id="14-数学运算"><a href="#14-数学运算" class="headerlink" title="14. 数学运算"></a>14. 数学运算</h3><p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置</strong>函数。您可以在程序中引用这些函数。</p>
<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p>
<p>为了利用这些函数，您需要引用数学头文件 <strong><cmath></strong>。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>double fabs(double);</strong> 该函数返回任意一个浮点数的绝对值。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td>
</tr>
</tbody></table>
<p>下面是一个关于数学运算的简单实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数字定义</span></span><br><span class="line">    short s = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1000</span>;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">250.41</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">200.45</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数学运算</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sin(d) :"</span> &lt;&lt; <span class="built_in">sin</span>(d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"abs(i)  :"</span> &lt;&lt; <span class="built_in">abs</span>(i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"floor(d) :"</span> &lt;&lt; <span class="built_in">floor</span>(d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sqrt(f) :"</span> &lt;&lt; <span class="built_in">sqrt</span>(f) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pow( d, 2) :"</span> &lt;&lt; <span class="built_in">pow</span>(d, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成随机数之前必须先调用 srand() 函数。</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>) time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">//生成 5 个随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">        a = rand();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"随机数："</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>sin(d) :-0.574448<br>abs(i)  :1000<br>floor(d) :200<br>sqrt(f) :15.8243<br>pow( d, 2) :40180.2<br>随机数：1753472662<br>随机数：696942453<br>随机数：1135996833<br>随机数：1569150401<br>随机数：1611604447</p>
</blockquote>
<h3 id="15-数组"><a href="#15-数组" class="headerlink" title="15. 数组"></a>15. 数组</h3><p>C++ 支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。</p>
<p><strong>声明数组:</strong></p>
<p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式:</span></span><br><span class="line">type arrayName [ arraySize ];<span class="comment">//这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。</span></span><br><span class="line"><span class="comment">//例子:</span></span><br><span class="line"><span class="keyword">double</span> balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p><strong>初始化数组:</strong></p>
<p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d[<span class="number">5</span>] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"><span class="comment">//修改数组</span></span><br><span class="line">d[<span class="number">4</span>] = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>

<p>上面的意思是先定义一个大小为 5 的数组，然后在修改索引为 4 的数值，以下是上面的图形表示:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200105213603.png" alt=""></p>
<p><strong>访问数组元素:</strong></p>
<p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> temp = d[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>上面的语句将把数组中第 4 个元素的值赋给 temp 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n[<span class="number">100</span>]; <span class="comment">//包含 100 个整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        n[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setw 可以理解为 输出的间隔为 10 个字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element"</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">"value"</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; n[<span class="number">20</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组中每个元素的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element"</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">"value"</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; n[j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>Element     value        20<br>Element     value         0<br>Element     value         1<br>Element     value         2<br>Element     value         3<br>Element     value         4<br>Element     value         5<br>Element     value         6<br>Element     value         7<br>Element     value         8<br>Element     value         9<br>Element     value        10<br>Element     value        11<br>Element     value        12</p>
<p>…</p>
</blockquote>
<p><strong>其它:</strong></p>
<p>在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-multi-dimensional-arrays.html">多维数组</a></td>
<td align="left">C++ 支持多维数组。多维数组最简单的形式是二维数组。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-to-an-array.html">指向数组的指针</a></td>
<td align="left">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-passing-arrays-to-functions.html">传递数组给函数</a></td>
<td align="left">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-return-arrays-from-function.html">从函数返回数组</a></td>
<td align="left">C++ 允许从函数返回数组。</td>
</tr>
</tbody></table>
<h3 id="16-字符串"><a href="#16-字符串" class="headerlink" title="16. 字符串"></a>16. 字符串</h3><p>C++ 提供了以下两种类型的字符串表示形式：</p>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
<p><strong>C 风格字符串:</strong></p>
<p>在上一篇文章中我们学习了 C 中定义字符串，这里我们在复习下，看下面示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">//等同于如下定义</span></span><br><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>

<p>以下是 C/C++ 中定义的字符串的内存表示：</p>
<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。让我们尝试输出上面的字符串：<img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200105214650.png" alt=""></p>
<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。</p>
<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">10</span>] = &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>123456789</p>
</blockquote>
<p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<p>下面的实例使用了上述的一些函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ctr1[<span class="number">20</span>] = <span class="string">"网名:"</span>;</span><br><span class="line">    <span class="keyword">char</span> ctr2[<span class="number">50</span>] = <span class="string">"个人Blog地址:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ctr1Len, ctr2Len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(ctr1, <span class="string">"DevYK"</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(ctr2, <span class="string">"https://www.devyk.top"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ctr1\t"</span> &lt;&lt; ctr1 &lt;&lt; <span class="string">"\n"</span> &lt;&lt; <span class="string">"ctr2\t"</span> &lt;&lt; ctr2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ctr1Len = <span class="built_in">strlen</span>(ctr1);</span><br><span class="line">    ctr2Len = <span class="built_in">strlen</span>(ctr2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ctr1Len"</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; ctr1Len &lt;&lt; <span class="string">"\nctr2Len"</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; ctr2Len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>ctr1    网名:DevYK<br>ctr2    个人Blog地址:<a href="https://www.devyk.top">https://www.devyk.top</a><br>ctr1Len        12<br>ctr2Len        38</p>
</blockquote>
<p><strong>C++ 中的 String:</strong></p>
<p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p>
<p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  test13();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n\nstring 类型字符串"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> meg[<span class="number">10</span>] = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; meg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//定义 string 变量</span></span><br><span class="line">    <span class="built_in">string</span> str1add, str2add;</span><br><span class="line">    <span class="keyword">int</span> str1Len, str2Len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">"网名:"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"个人Blog地址:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//追加到 str 末尾</span></span><br><span class="line">    str1add = str1.append(<span class="string">"DevYK"</span>);</span><br><span class="line">    str2add = str2.append(<span class="string">"https://www.devyk.top"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"str1\t"</span> &lt;&lt; str1 &lt;&lt; <span class="string">"\n"</span> &lt;&lt; <span class="string">"str2\t"</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    str1Len = str1add.length();</span><br><span class="line">    str2Len = str2add.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"str1Len"</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; str1Len &lt;&lt; <span class="string">"\nstr2Len"</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; str2Len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>string 类型字符串0x7ffee9b98550<br>str1    网名:DevYK<br>str2    个人Blog地址:<a href="https://www.devyk.top">https://www.devyk.top</a><br>str1Len        12<br>str2Len        38</p>
</blockquote>
<h3 id="17-指针"><a href="#17-指针" class="headerlink" title="17. 指针"></a>17. 指针</h3><p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>
<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test14</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1;</span><br><span class="line">    <span class="keyword">char</span> var2[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"var1 变量的地址\t"</span> &lt;&lt; &amp;var1 &lt;&lt; <span class="string">"\nvar2 变量的地址\t"</span> &lt;&lt; &amp;var2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>var1 变量的地址    0x7ffeeef58698<br>var2 变量的地址    0x7ffeeef5869e</p>
</blockquote>
<p>通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。</p>
<p><strong>指针是什么？</strong></p>
<p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var-name;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C++ 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="keyword">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="keyword">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="keyword">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>

<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<p><strong>指针的使用:</strong></p>
<p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test14</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">20</span>; <span class="comment">//实际变量的声明</span></span><br><span class="line">    <span class="keyword">int</span> *ip;</span><br><span class="line">    <span class="comment">//将 var 地址赋值给 ip 指针变量中</span></span><br><span class="line">    ip = &amp;var;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"指针变量中存储的地址\t"</span> &lt;&lt; ip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"指针变量中的地址\t"</span> &lt;&lt; ip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"指针变量中地址对应的值\t"</span> &lt;&lt; *ip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>指针变量中存储的地址    0x7ffeeef58694<br>指针变量中的地址    0x7ffeeef58694<br>指针变量中地址对应的值    20</p>
</blockquote>
<h3 id="18-引用"><a href="#18-引用" class="headerlink" title="18. 引用"></a>18. 引用</h3><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<p><strong>引用 VS 指针:</strong></p>
<p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p><strong>创建引用:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">17</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以为 i 声明引用变量，如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  r = i;</span><br><span class="line"><span class="keyword">double</span>&amp; s = d;</span><br></pre></td></tr></table></figure>

<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//声明引用变量</span></span><br><span class="line">    <span class="keyword">int</span> &amp;i = a;</span><br><span class="line">    <span class="keyword">int</span> &amp;j = b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a == "</span> &lt;&lt; a &lt;&lt; <span class="string">"\t &amp;i =="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b == "</span> &lt;&lt; b &lt;&lt; <span class="string">"\t &amp;j =="</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">5</span>, b = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a == "</span> &lt;&lt; a &lt;&lt; <span class="string">"\t &amp;i =="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b == "</span> &lt;&lt; b &lt;&lt; <span class="string">"\t &amp;j =="</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>a == 10     &amp;i ==10<br>b == 20     &amp;j ==20<br>a == 5       &amp;i ==5<br>b == 6       &amp;j ==6</p>
</blockquote>
<p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html">把引用作为参数</a></td>
<td align="left">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html">把引用作为返回值</a></td>
<td align="left">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td>
</tr>
</tbody></table>
<h3 id="19-日期-amp-时间"><a href="#19-日期-amp-时间" class="headerlink" title="19. 日期 &amp; 时间"></a>19. 日期 &amp; 时间</h3><p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</p>
<p>有四个与时间相关的类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong>。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>
<p>结构类型 <strong>tm</strong> 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;   <span class="comment">// 秒，正常范围从 0 到 59，但允许至 61</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;   <span class="comment">// 分，范围从 0 到 59</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;  <span class="comment">// 小时，范围从 0 到 23</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;  <span class="comment">// 一月中的第几天，范围从 1 到 31</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;   <span class="comment">// 月，范围从 0 到 11</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;  <span class="comment">// 自 1900 年起的年数</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;  <span class="comment">// 一周中的第几天，范围从 0 到 6，从星期日算起</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;  <span class="comment">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst; <span class="comment">// 夏令时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-time.html"><strong>time_t time(time_t *time);</strong></a> 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-ctime.html"><strong>char *ctime(const time_t *time);</strong></a> 该返回一个表示当地时间的字符串指针，字符串形式 <em>day month year hours:minutes:seconds year\n\0</em>。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-localtime.html"><strong>struct tm *localtime(const time_t *time);</strong></a> 该函数返回一个指向表示本地时间的 <strong>tm</strong> 结构的指针。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-clock.html"><strong>clock_t clock(void);</strong></a> 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-asctime.html"><strong>char * asctime ( const struct tm * time );</strong></a> 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-gmtime.html"><strong>struct tm *gmtime(const time_t *time);</strong></a> 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-mktime.html"><strong>time_t mktime(struct tm *time);</strong></a> 该函数返回日历时间，相当于 time 所指向结构中存储的时间。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-difftime.html"><strong>double difftime ( time_t time2, time_t time1 );</strong></a> 该函数返回 time1 和 time2 之间相差的秒数。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/cplusplus/c-function-strftime.html"><strong>size_t strftime();</strong></a> 该函数可用于格式化日期和时间为指定的格式。</td>
</tr>
</tbody></table>
<p><strong>当前日期:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取系统的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//把 now 转为字符串</span></span><br><span class="line">    <span class="keyword">char</span> *curTime = ctime(&amp;now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把 now 转为 tm 结构</span></span><br><span class="line">    tm *gmtm = gmtime(&amp;now);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"当前时间\t"</span> &lt;&lt; curTime &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    curTime = asctime(gmtm);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"UTC 日期和时间\t"</span> &lt;&lt; curTime &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>当前时间                    Sun Jan  5 22:11:15 2020</p>
<p>UTC 日期和时间        Sun Jan  5 14:11:15 2020</p>
</blockquote>
<p><strong>使用结构 tm 格式化时间:</strong></p>
<p><strong>tm</strong> 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</p>
<p>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基于当前系统的日期/时间</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1970 到目前经过的秒数:"</span> &lt;&lt; now &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    tm *ltm = localtime(&amp;now);</span><br><span class="line">    <span class="comment">//输出 tm 结构的各个组成部分</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"年: "</span> &lt;&lt; <span class="number">1990</span> + ltm-&gt;tm_year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"月: "</span> &lt;&lt; <span class="number">1</span> + ltm-&gt;tm_mon &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"日: "</span> &lt;&lt; ltm-&gt;tm_mday &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"时: "</span> &lt;&lt; ltm-&gt;tm_hour &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"分: "</span> &lt;&lt; ltm-&gt;tm_min &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"秒: "</span> &lt;&lt; ltm-&gt;tm_sec &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>1970 到目前经过的秒数:1578233475<br>年: 2110<br>月: 1<br>日: 5<br>时: 22<br>分: 11<br>秒: 15</p>
</blockquote>
<h3 id="20-输入输出"><a href="#20-输入输出" class="headerlink" title="20. 输入输出"></a>20. 输入输出</h3><p>C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。</p>
<p>C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>
<p><strong>I/O 库头文件</strong></p>
<p>下列的头文件在 C++ 编程中很重要。</p>
<table>
<thead>
<tr>
<th align="left">头文件</th>
<th align="left">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><iostream></strong></td>
<td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>
</tr>
<tr>
<td align="left"><strong><iomanip></strong></td>
<td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td>
</tr>
<tr>
<td align="left"><strong><fstream></strong></td>
<td align="left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td>
</tr>
</tbody></table>
<p><strong>标准输入流 cout:</strong></p>
<p>预定义的对象 <strong>cout</strong> 是 <strong>iostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p><strong>标准输入流 cin:</strong></p>
<p>预定义的对象 <strong>cin</strong> 是 <strong>iostream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的。</p>
<p><strong>标准错误流 cerr:</strong></p>
<p>预定义的对象 <strong>cerr</strong> 是 <strong>iostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>
<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p><strong>标准日志流 clog:</strong></p>
<p>预定义的对象 <strong>clog</strong> 是 <strong>iostream</strong> 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test17</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 标准输出流 cout</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"值为:"</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//2.  标准输入流 cin</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你的名称: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"你的名称是："</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    请输入你的名称: DevYK</span></span><br><span class="line"><span class="comment">//    你的名称是：DevYK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 标准错误流 cerr</span></span><br><span class="line">    <span class="keyword">char</span> errStr[] = <span class="string">"Read Error"</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"error message："</span> &lt;&lt; errStr &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出为报红的:error message：Read Error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 标准日志流 clog</span></span><br><span class="line">    <span class="keyword">char</span> logStr[] = <span class="string">"out Log"</span>;</span><br><span class="line">    <span class="built_in">clog</span> &lt;&lt; <span class="string">"Debug Log："</span> &lt;&lt; logStr &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出为报红的 Debug Logout Log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
</blockquote>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200105222252.gif" alt=""></p>
<h3 id="21-数据结构"><a href="#21-数据结构" class="headerlink" title="21. 数据结构"></a>21. 数据结构</h3><p>C/C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p><strong>定义结构:</strong></p>
<p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_name</span> &#123;</span></span><br><span class="line">member_type1 member_name1;</span><br><span class="line">member_type2 member_name2;</span><br><span class="line">member_type3 member_name3;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125; object_names;</span><br></pre></td></tr></table></figure>

<p><strong>type_name</strong> 是结构体类型的名称，<strong>member_type1 member_name1</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong> 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 <strong>Movies</strong>，变量为 <strong>movies</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movies</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> address[<span class="number">30</span>];</span><br><span class="line">&#125;movies;</span><br></pre></td></tr></table></figure>

<p><strong>访问结构成员:</strong></p>
<p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>
<p>下面的实例演示了结构的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movies</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> address[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test18</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义结构体变量</span></span><br><span class="line">    Movies movieA, movieB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//movieA 详述</span></span><br><span class="line">    <span class="built_in">strcpy</span>(movieA.title, <span class="string">"叶问4"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(movieA.address, <span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//movieB 详述</span></span><br><span class="line">    <span class="built_in">strcpy</span>(movieB.title, <span class="string">"战狼2"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(movieB.address, <span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出电影信息</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; movieA.title &lt;&lt; <span class="string">"\t"</span> &lt;&lt; movieA.address &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; movieB.title &lt;&lt; <span class="string">"\t"</span> &lt;&lt; movieB.address &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>叶问4    china<br>战狼2    china</p>
</blockquote>
<p><strong>结构体作为函数参数:</strong></p>
<p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movies</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> address[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movieInfo</span><span class="params">(struct Movies movie)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test18</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义结构体变量</span></span><br><span class="line">    Movies movieA, movieB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//movieA 详述</span></span><br><span class="line">    <span class="built_in">strcpy</span>(movieA.title, <span class="string">"叶问4"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(movieA.address, <span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//movieB 详述</span></span><br><span class="line">    <span class="built_in">strcpy</span>(movieB.title, <span class="string">"战狼2"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(movieB.address, <span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结构体作为函数参数传递</span></span><br><span class="line">    movieInfo(movieA);</span><br><span class="line">    movieInfo(movieB);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movieInfo</span><span class="params">(struct Movies movie)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出电影信息</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; movie.title &lt;&lt; <span class="string">"\t"</span> &lt;&lt; movie.address &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>叶问4    china<br>战狼2    china</p>
</blockquote>
<p><strong>指针结构的指针:</strong></p>
<p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movies</span> *<span class="title">struct_pointer</span>;</span></span><br></pre></td></tr></table></figure>

<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer = &amp;Movies;</span><br></pre></td></tr></table></figure>

<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movies</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> address[<span class="number">30</span>];</span><br><span class="line">&#125;movies;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movieInfo</span><span class="params">(struct Movies *movie)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test18</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义结构体变量</span></span><br><span class="line">    Movies movieA, movieB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//movieA 详述</span></span><br><span class="line">    <span class="built_in">strcpy</span>(movieA.title, <span class="string">"叶问4"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(movieA.address, <span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//movieB 详述</span></span><br><span class="line">    <span class="built_in">strcpy</span>(movieB.title, <span class="string">"战狼2"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(movieB.address, <span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结构体作为指针传递</span></span><br><span class="line">    movieInfo(&amp;movieA);</span><br><span class="line">    movieInfo(&amp;movieB);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movieInfo</span><span class="params">(struct Movies *movie)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出电影信息</span></span><br><span class="line">    <span class="comment">// 为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; movie-&gt;title &lt;&lt; <span class="string">"\t"</span> &lt;&lt; movie-&gt;address &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>叶问4    china<br>战狼2    china</p>
</blockquote>
<h3 id="22-类-amp-对象"><a href="#22-类-amp-对象" class="headerlink" title="22. 类 &amp; 对象"></a>22. 类 &amp; 对象</h3><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>
<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p>
<p><strong>类定义:</strong></p>
<p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们创建一个 <em>.h 文件 使用关键字 *</em>class** 定义 Person 数据类型，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个 Person ,跟 Java class 差不多</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公共的属性</span></span><br><span class="line">    Person(); <span class="comment">//空参</span></span><br><span class="line"></span><br><span class="line">    ~Person(); <span class="comment">//Person 销毁执行</span></span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">char</span> *name, <span class="keyword">char</span> *gen, <span class="keyword">int</span> age); <span class="comment">//有参构造</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *gen;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setGen</span><span class="params">(<span class="keyword">char</span> *gen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getGen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>。</p>
<p><strong>定义 C++ 对象:</strong></p>
<p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Person的两个对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person personTemp;<span class="comment">//声明 personTemp 类型为 Person</span></span><br></pre></td></tr></table></figure>

<p><strong>访问数据成员:</strong></p>
<p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. person.h 文件中定义 Person 对象</span></span><br><span class="line"><span class="comment">//定义了一个 Person ,跟 Java class 差不多</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公共的属性</span></span><br><span class="line">    Person();</span><br><span class="line"></span><br><span class="line">    ~Person();</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">char</span> *name, <span class="keyword">char</span> *gen, <span class="keyword">int</span> age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *gen;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setGen</span><span class="params">(<span class="keyword">char</span> *gen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getGen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. person.cpp </span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">char</span> *name, <span class="keyword">char</span> *gen, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;gen = gen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~Person() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person 销毁"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::Person() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"执行 Person 空参构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setName</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setGen</span><span class="params">(<span class="keyword">char</span> *gen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;gen = gen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Person::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DevYK getName"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Person::getGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;gen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test19</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//栈里面定义的当该方法执行完就会回收掉 Person 对象</span></span><br><span class="line">    Person personTemp;</span><br><span class="line">    personTemp.setGen(<span class="string">"男"</span>);</span><br><span class="line">    personTemp.setName(<span class="string">"小明"</span>);</span><br><span class="line">    personTemp.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; personTemp.getName() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; personTemp.getGen() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; personTemp.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//初始化 Person 对象，在堆内存中，如果不主动清理 那么就会造成 内存泄漏</span></span><br><span class="line">    Person *person = <span class="keyword">new</span> Person(<span class="string">"DevYK"</span>, <span class="string">"男"</span>, <span class="number">28</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person-&gt;getName() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; person-&gt;getGen() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; person-&gt;getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//释放 person 堆内存</span></span><br><span class="line">    <span class="keyword">delete</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>执行 Person 空参构造函数<br>小明    男    18<br>DevYK    男    28<br>Person 销毁<br>Person 销毁</p>
</blockquote>
<p>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。</p>
<p><strong>类 &amp; 对象详解:</strong></p>
<p>到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-class-member-functions.html">类成员函数</a></td>
<td align="left">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-class-access-modifiers.html">类访问修饰符</a></td>
<td align="left">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">构造函数 &amp; 析构函数</a></td>
<td align="left">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-copy-constructor.html">C++ 拷贝构造函数</a></td>
<td align="left">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html">C++ 友元函数</a></td>
<td align="left"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-inline-functions.html">C++ 内联函数</a></td>
<td align="left">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-this-pointer.html">C++ 中的 this 指针</a></td>
<td align="left">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-to-class.html">C++ 中指向类的指针</a></td>
<td align="left">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cplusplus/cpp-static-members.html">C++ 类的静态成员</a></td>
<td align="left">类的数据成员和函数成员都可以被声明为静态的。</td>
</tr>
</tbody></table>
<h3 id="23-继承"><a href="#23-继承" class="headerlink" title="23. 继承"></a>23. 继承</h3><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>
<p><strong>基类 &amp; 派生类:</strong></p>
<p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="title">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>

<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~SuperMan();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *superName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSuperName</span><span class="params">(<span class="keyword">char</span> *superName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getSuperName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevYK</span> :</span> <span class="keyword">public</span> SuperMan &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DevYK();</span><br><span class="line"></span><br><span class="line">    ~DevYK();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getSupName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test20</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//子类</span></span><br><span class="line">    DevYK *devYkTemp = <span class="keyword">new</span> DevYK();</span><br><span class="line">    <span class="comment">//父类set Name</span></span><br><span class="line">    devYkTemp-&gt;setSuperName(<span class="string">"superMan"</span>);</span><br><span class="line">    <span class="comment">//子类获取</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"单继承:"</span> &lt;&lt; devYkMoreTemp-&gt;getPersonName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针类型的访问需要以 “-&gt;” 形式来访问</p>
<blockquote>
<p><strong>输出:</strong></p>
<p>执行 DevYK 空参构造函数</p>
<p>单继承:superMan</p>
</blockquote>
<p><strong>访问控制和继承:</strong></p>
<p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">访问</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同一个类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">派生类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">外部的类</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
</tbody></table>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<p><strong>多继承:</strong></p>
<p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义基类 Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公共的属性</span></span><br><span class="line">    Person();</span><br><span class="line"></span><br><span class="line">    ~Person();</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">char</span> *name, <span class="keyword">char</span> *gen, <span class="keyword">int</span> age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *gen;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setGen</span><span class="params">(<span class="keyword">char</span> *gen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getGen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义基类 SuperMan</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~SuperMan();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *superName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSuperName</span><span class="params">(<span class="keyword">char</span> *superName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getSuperName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 派生类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承关系</span></span><br><span class="line"><span class="comment"> * 多继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevYK</span> :</span> <span class="keyword">public</span> Person, <span class="keyword">public</span> SuperMan &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DevYK(<span class="keyword">char</span> *name, <span class="keyword">int</span> age) : Person(name, <span class="string">"nan"</span>, age) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    DevYK();</span><br><span class="line"></span><br><span class="line">    ~DevYK();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getPersonName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getSupName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test20</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    //子类</span></span><br><span class="line">    DevYK *devYkTemp = <span class="keyword">new</span> DevYK();</span><br><span class="line">    <span class="comment">//父类set Name</span></span><br><span class="line">    devYkTemp-&gt;setName(<span class="string">"DevYK"</span>);</span><br><span class="line">    <span class="comment">//子类获取</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"单继承 Person Name:"</span> &lt;&lt; devYkTemp-&gt;getPersonName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多继承</span></span><br><span class="line">    DevYK *devYkMoreTemp = <span class="keyword">new</span> DevYK();</span><br><span class="line">    <span class="comment">//给父类 Person set Name</span></span><br><span class="line">    devYkMoreTemp-&gt;setName(<span class="string">"DevYK"</span>);</span><br><span class="line">    <span class="comment">//给父类 Super set Name</span></span><br><span class="line">    devYkMoreTemp-&gt;setSuperName(<span class="string">"superMan"</span>);</span><br><span class="line">    <span class="comment">//子类获取</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"多继承 Person Name:"</span> &lt;&lt; devYkMoreTemp-&gt;getPersonName()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"多继承  SuperMan Name:"</span> &lt;&lt; devYkMoreTemp-&gt;getSupName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> devYkTemp, devYkMoreTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>执行 Person 空参构造函数<br>执行 DevYK 空参构造函数<br>单继承 Person Name:DevYK<br>执行 Person 空参构造函数<br>执行 DevYK 空参构造函数<br>多继承 Person Name:DevYK<br>多继承  SuperMan Name:superMan<br>DevYK 销毁<br>SuperMan 销毁<br>Person 销毁</p>
</blockquote>
<h3 id="24-重载运算符和重载函数"><a href="#24-重载运算符和重载函数" class="headerlink" title="24. 重载运算符和重载函数"></a>24. 重载运算符和重载函数</h3><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>
<p><strong>函数重载:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 在 .h 文件中定义 DevYK 对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevYK</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    DevYK();</span><br><span class="line"></span><br><span class="line">    ~DevYK();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. .cpp 实现</span></span><br><span class="line"></span><br><span class="line">DevYK::DevYK() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"执行 DevYK 空参构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DevYK::~DevYK() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DevYK 销毁"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DevYK::setLength</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DevYK::getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test21</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.运算符重载</span></span><br><span class="line">    DevYK devYkA;</span><br><span class="line">    DevYK devYkB;</span><br><span class="line">    DevYK devYkC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行初始化赋值</span></span><br><span class="line">    devYkA.setLength(<span class="number">500</span>);</span><br><span class="line">    devYkB.setLength(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"devYkA length ： "</span> &lt;&lt; devYkA.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"devYkB length ： "</span> &lt;&lt; devYkB.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>devYkA length ： 500<br>devYkB length ： 20</p>
</blockquote>
<p><strong>运算符重载:</strong></p>
<p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DevYK <span class="keyword">operator</span>+(<span class="keyword">const</span> DevYK &amp;b);</span><br></pre></td></tr></table></figure>

<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 <strong>this</strong> 运算符进行访问，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 在 .h 文件中定义 DevYK 对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevYK</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    DevYK();</span><br><span class="line"></span><br><span class="line">    ~DevYK();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    DevYK <span class="keyword">operator</span>+(<span class="keyword">const</span> DevYK &amp;b);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. .cpp 实现</span></span><br><span class="line"></span><br><span class="line">DevYK::DevYK() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"执行 DevYK 空参构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DevYK::~DevYK() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DevYK 销毁"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DevYK::setLength</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DevYK::getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevYK</span> <span class="title">DevYK</span>:</span>:<span class="keyword">operator</span>+(<span class="keyword">const</span> class DevYK &amp;b) &#123;</span><br><span class="line">    DevYK devYk;</span><br><span class="line">    devYk.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">    <span class="keyword">return</span> devYk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 测试:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test21</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.运算符重载</span></span><br><span class="line">    DevYK devYkA;</span><br><span class="line">    DevYK devYkB;</span><br><span class="line">    DevYK devYkC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行初始化赋值</span></span><br><span class="line">    devYkA.setLength(<span class="number">500</span>);</span><br><span class="line">    devYkB.setLength(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"devYkA length ： "</span> &lt;&lt; devYkA.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"devYkB length ： "</span> &lt;&lt; devYkB.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    devYkC = devYkA + devYkB;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DevYK 运算符重载 = "</span> &lt;&lt; devYkC.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>devYkA length ： 500<br>devYkB length ： 20</p>
<p>DevYK 运算符重载 = 520</p>
</blockquote>
<h3 id="25-多态"><a href="#25-多态" class="headerlink" title="25. 多态"></a>25. 多态</h3><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义了一个 Person 基类,跟 Java class 差不多</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公共的属性</span></span><br><span class="line">    Person();</span><br><span class="line"></span><br><span class="line">    ~Person();</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">char</span> *name, <span class="keyword">char</span> *gen, <span class="keyword">int</span> age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *gen;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setGen</span><span class="params">(<span class="keyword">char</span> *gen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getGen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚函数 是在基类中使用关键字 virtual 声明的函数。</span></span><br><span class="line"><span class="comment">     * 在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//virtual 转移给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义 DevYK 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevYK</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DevYK(<span class="keyword">char</span> *name, <span class="keyword">int</span> age) : Person(name, <span class="string">"nan"</span>, age) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    DevYK();</span><br><span class="line"></span><br><span class="line">    ~DevYK();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getPersonName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    DevYK <span class="keyword">operator</span>+(<span class="keyword">const</span> DevYK &amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. .cpp 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ClssSample.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">char</span> *name, <span class="keyword">char</span> *gen, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;gen = gen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~Person() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person 销毁"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::Person() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"执行 Person 空参构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setName</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setGen</span><span class="params">(<span class="keyword">char</span> *gen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;gen = gen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Person::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Person::getGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;gen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DevYK::DevYK() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"执行 DevYK 空参构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DevYK::~DevYK() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DevYK 销毁"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">DevYK::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DevYK getName"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">DevYK::getPersonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DevYK::setLength</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DevYK::getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevYK</span> <span class="title">DevYK</span>:</span>:<span class="keyword">operator</span>+(<span class="keyword">const</span> class DevYK &amp;b) &#123;</span><br><span class="line">    DevYK devYk;</span><br><span class="line">    devYk.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">    <span class="keyword">return</span> devYk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 测试</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test22</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//父类</span></span><br><span class="line">    Person *person;</span><br><span class="line">    <span class="comment">//定义子类</span></span><br><span class="line">    <span class="function">DevYK <span class="title">devYk</span><span class="params">(<span class="string">"DevYK"</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (person) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person\t"</span> &lt;&lt; person-&gt;getName() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; person-&gt;getGen() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; person-&gt;getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DevYK-&gt;\t"</span> &lt;&lt; devYk.getName() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; devYk.getGen() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; devYk.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把 devyk 的内存地址赋值给 person</span></span><br><span class="line">    person = &amp;devYk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (person) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person\t"</span> &lt;&lt; person-&gt;getName() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; person-&gt;getGen() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; person-&gt;getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DevYK 内存地址-&gt;\t"</span> &lt;&lt; &amp;devYk &lt;&lt; <span class="string">" Person 内存地址\t"</span> &lt;&lt; person &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取子类数据</span></span><br><span class="line">    <span class="keyword">int</span> test = person-&gt;test();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test-&gt;\t"</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>DevYK-&gt;    DevYK getName<br>DevYK        nan    27<br>Person        DevYK    nan    27<br>DevYK 内存地址-&gt;    0x7ffee1d26628 Person 内存地址    0x7ffee1d26628<br>test-&gt;    -10<br>DevYK 销毁<br>Person 销毁</p>
</blockquote>
<p><strong>虚函数:</strong></p>
<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<p><strong>纯虚函数:</strong></p>
<p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
<h3 id="26-数据封装"><a href="#26-数据封装" class="headerlink" title="26. 数据封装"></a>26. 数据封装</h3><p>所有的 C++ 程序都有以下两个基本要素：</p>
<ul>
<li><strong>程序语句（代码）：</strong>这是程序中执行动作的部分，它们被称为函数。</li>
<li><strong>程序数据：</strong>数据是程序的信息，会受到程序函数的影响。</li>
</ul>
<p>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即<strong>数据隐藏</strong>。</p>
<p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>
<p>C++ 通过创建<strong>类</strong>来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * <span class="built_in">height</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;      <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。</p>
<p>为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 <strong>public</strong> 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。</p>
<p>把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. .h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * <span class="built_in">height</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;      <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2. .cpp</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getVolume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length * <span class="keyword">this</span>-&gt;<span class="built_in">height</span> * <span class="keyword">this</span>-&gt;<span class="built_in">width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Box::initValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">    length = a, <span class="built_in">width</span> = b, <span class="built_in">height</span> = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. cpp 测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test23</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.initValue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"数据私有封住:"</span> &lt;&lt; box.getVolume() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>数据私有封住:6000</p>
</blockquote>
<h3 id="27-接口-抽象类"><a href="#27-接口-抽象类" class="headerlink" title="27. 接口(抽象类)"></a>27. 接口(抽象类)</h3><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<p>C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。</p>
<p>例子参考 25 小节的多态。</p>
<h3 id="28-文件和流"><a href="#28-文件和流" class="headerlink" title="28. 文件和流"></a>28. 文件和流</h3><p>到目前为止，我们已经使用了 <strong>iostream</strong> 标准库，它提供了 <strong>cin</strong> 和 <strong>cout</strong> 方法分别用于从标准输入读取流和向标准输出写入流。</p>
<p>本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ofstream</td>
<td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>
</tr>
<tr>
<td align="left">ifstream</td>
<td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td>
</tr>
<tr>
<td align="left">fstream</td>
<td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody></table>
<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</p>
<p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p>
<table>
<thead>
<tr>
<th align="left">模式标志</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ios::app</td>
<td align="left">追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::ate</td>
<td align="left">文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::in</td>
<td align="left">打开文件用于读取。</td>
</tr>
<tr>
<td align="left">ios::out</td>
<td align="left">打开文件用于写入。</td>
</tr>
<tr>
<td align="left">ios::trunc</td>
<td align="left">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
</tbody></table>
<p>您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.<span class="built_in">open</span>(<span class="string">"file.dat"</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>

<p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream  afile;</span><br><span class="line">afile.<span class="built_in">open</span>(<span class="string">"file.dat"</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure>

<p><strong>关闭文件:</strong></p>
<p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>
<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>写入文件:</strong></p>
<p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>
<p><strong>读取文件:</strong></p>
<p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p>
<p><strong>读取 &amp; 写入实例:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test24</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//ofstream: 用于创建文件并向文件写入信息。</span></span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.<span class="built_in">open</span>(<span class="string">"/Users/devyk/Data/ClionProjects/NDK_Sample/README.md"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入写入文件的内容："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.getline(data, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">//向文件开始写入数据</span></span><br><span class="line">    outfile &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    <span class="comment">//关闭打开的文件</span></span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> readData[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//开始读文件</span></span><br><span class="line">    ifstream readFile;</span><br><span class="line">    readFile.<span class="built_in">open</span>(<span class="string">"/Users/devyk/Data/ClionProjects/NDK_Sample/README.md"</span>);</span><br><span class="line">    readFile.getline(readData, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"读取成功\n"</span> &lt;&lt; readData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    readFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200106211229.gif" alt=""></p>
<h3 id="29-异常处理"><a href="#29-异常处理" class="headerlink" title="29. 异常处理"></a>29. 异常处理</h3><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p>
<p><strong>抛出异常:</strong></p>
<p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<p>以下是尝试除以零时抛出异常的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">"Division by zero condition!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>捕获异常:</strong></p>
<p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">"Division by zero condition!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">double</span> z = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = division(x, y);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">     <span class="built_in">cerr</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p>
<blockquote>
<p><strong>输出:</strong></p>
<p>Division by zero condition!</p>
</blockquote>
<p><strong>自定义异常:</strong></p>
<p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个新的异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span>  <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C++ 操作失误，请检查代码是否正确!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test25</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"空指针异常"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span> *msg) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误日志:\t"</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> MyException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyException exception) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义异常:"</span> &lt;&lt; exception.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception &amp;error) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"其它异常:"</span> &lt;&lt; error.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>错误日志:    空指针异常<br>自定义异常:C++ 操作失误，请检查代码是否正确!</p>
</blockquote>
<h3 id="30-动态内存"><a href="#30-动态内存" class="headerlink" title="30. 动态内存"></a>30. 动态内存</h3><p>了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：</p>
<ul>
<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>
<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>
<p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p>
<p>如果您不再需要动态分配的内存空间，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p>
<p><strong>new 和 delete 运算符:</strong></p>
<p>下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> data-type;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>data-type</strong> 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 <strong>new</strong> 运算符来完成这点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="keyword">double</span>;   <span class="comment">// 为变量请求内存</span></span><br></pre></td></tr></table></figure>

<p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* pvalue  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>( !(pvalue  = <span class="keyword">new</span> <span class="keyword">double</span> ))</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: out of memory."</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>malloc()</strong> 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p>
<p>在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pvalue;        <span class="comment">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>

<p>下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test26</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//演示如何使用 new 和 delete 运算符：</span></span><br><span class="line">    <span class="comment">//初始化为 null 的指针</span></span><br><span class="line">    <span class="keyword">double</span> *pvalue = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//为变量申请内存</span></span><br><span class="line">    pvalue = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">    <span class="comment">//在分配的地址存储值</span></span><br><span class="line">    *pvalue = <span class="number">1314.520</span>;</span><br><span class="line">    <span class="comment">//打印存储的数字</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pvalue 的地址值为:\t"</span> &lt;&lt; &amp;pvalue &lt;&lt; <span class="string">"\n在该地址存储的值为:\t"</span> &lt;&lt; *pvalue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> pvalue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组的动态内存分配</span></span><br><span class="line">    <span class="comment">//动态分配，数组长度为 10</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//释放数组内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象的动态内存分配</span></span><br><span class="line">    Box *testBox = <span class="keyword">new</span> Box[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] testBox;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>pvalue 的地址值为:    0x7ffee8b27658<br>在该地址存储的值为:    1314.52</p>
<p>pvalue 的地址值为:    0x7ffee7b8c658<br>在该地址存储的值为:    1314.52<br>调用构造函数！<br>调用构造函数！<br>调用构造函数！<br>调用构造函数！<br>调用构造函数！<br>调用构造函数！<br>调用构造函数！<br>调用构造函数！<br>调用构造函数！<br>调用构造函数！<br>调用析构函数！<br>调用析构函数！<br>调用析构函数！<br>调用析构函数！<br>调用析构函数！<br>调用析构函数！<br>调用析构函数！<br>调用析构函数！<br>调用析构函数！<br>调用析构函数！</p>
</blockquote>
<h3 id="31-命名空间"><a href="#31-命名空间" class="headerlink" title="31. 命名空间"></a>31. 命名空间</h3><p><strong>定义命名空间:</strong></p>
<p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name::code;  <span class="comment">// code 可以是变量或函数</span></span><br></pre></td></tr></table></figure>

<p>让我们来看看命名空间如何为变量或函数等实体定义范围：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> test1_space &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test1_space"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> test2_space &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test2_space"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test27</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test1_space::func();</span><br><span class="line">    test2_space::func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>test1_space<br>test2_space</p>
</blockquote>
<p><strong>using 指令:</strong></p>
<p>您可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> test1_space &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test1_space"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> test2_space &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test2_space"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 使用 using 指令</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> test1_space;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> test2_space;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test27</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    test1_space::func();</span><br><span class="line">    test2_space::func2();</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    func();</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>test1_space<br>test2_space</p>
<p>test1_space<br>test2_space</p>
</blockquote>
<h3 id="32-预处理器"><a href="#32-预处理器" class="headerlink" title="32. 预处理器"></a>32. 预处理器</h3><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>
<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p>
<p>我们已经看到，之前所有的实例中都有 <strong>#include</strong> 指令。这个宏用于把头文件包含到源文件中。</p>
<p>C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。</p>
<p><strong>define 预处理:</strong></p>
<p>define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>，指令的一般形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> macro-name replacement-text</span></span><br></pre></td></tr></table></figure>

<p>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 预处理器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX 100;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test28</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"通过预处理器定义了一个 MAX:"</span> &lt;&lt; MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>通过预处理器定义了一个 MAX:100</p>
</blockquote>
<p><strong>参数宏:</strong></p>
<p>您可以使用 #define 来定义一个带有参数的宏，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 参数宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_VALUE(a, b)(a&gt;b?a:b);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test28</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n通过预处理器定义了一个 MAX_VALUE:"</span> &lt;&lt; MAX_VALUE(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>通过预处理器定义了一个 MAX_VALUE:20</p>
</blockquote>
<p><strong>条件编译:</strong></p>
<p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p>
<p>条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 条件编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="33-多线程"><a href="#33-多线程" class="headerlink" title="33. 多线程"></a>33. 多线程</h3><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
</ul>
<p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p>
<p>本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。</p>
<p><strong>创建线程:</strong></p>
<p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">pthread_create (thread, attr, start_routine, arg)</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>pthread_create</strong> 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">thread</td>
<td align="left">指向线程标识符指针。</td>
</tr>
<tr>
<td align="left">attr</td>
<td align="left">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>
</tr>
<tr>
<td align="left">start_routine</td>
<td align="left">线程运行函数起始地址，一旦线程被创建就会执行。</td>
</tr>
<tr>
<td align="left">arg</td>
<td align="left">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>
</tr>
</tbody></table>
<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>
<p><strong>终止线程:</strong></p>
<p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">pthread_exit (status)</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。</p>
<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个线程数量宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">logD</span><span class="params">(<span class="keyword">void</span> * args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> threadID =  *((<span class="keyword">int</span>*)args);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"线程执行了"</span> &lt;&lt; threadID &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test29</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义线程的 ID 变量，多个变量使用数组</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        <span class="comment">//参数依次是：创建的线程 id,线程参数，调用的函数，传入的参数函数</span></span><br><span class="line">        <span class="keyword">int</span> ptc = pthread_create(&amp;tids[i],<span class="literal">NULL</span>,logD,(<span class="keyword">void</span>*)&amp;(i));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>!=ptc)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error code ："</span> &lt;&lt; ptc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等线程执行完毕后在释放线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出:</strong></p>
<p>线程执行了线程执行了5<br>线程执行了5<br>5<br>线程执行了5<br>线程执行了5</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里差不多 C++ 基础都讲解完了，面向对象思想还是很好理解的，下来大家一定要好好消化，下一个开始就开始使用 AS 学习 JNI 知识了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html">C++ 关键字介绍</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples.html">C++ 实例练习</a></li>
<li>[C++ 基础入门</li>
</ul>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">1</a></li><li><a class="pagination-link" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200427113132.jpeg" alt="DevYK"></figure><p class="title is-size-4 is-block line-height-inherit">DevYK</p><p class="is-size-6 is-block">Android/NDK/音视频/跨平台</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>BeiJing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yangkun19921001" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yangkun19921001"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="http://wpa.qq.com/msgrd?v=1&amp;uin=919079498&amp;site=ioshenmue&amp;menu=yes"><i class="fab fa-qq"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/"><span class="level-start"><span class="level-item">专题</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/"><span class="level-start"><span class="level-item">音视频</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="level-start"><span class="level-item">服务器</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"><span class="tag">音视频学习路线</span><span class="tag is-grey-lightest">12</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:26:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%BA%8C-FFmpeg-OpenSL-ES-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/">音视频学习 (十二) FFmpeg + OpenSL ES 实现音频播放器</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:24:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/Android-%E5%8D%81%E4%B8%80-Android-%E7%AB%AF-rtmp-%E6%8E%A8%E6%B5%81/">音视频学习 (十一) Android 端 rtmp 推流</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:22:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81-%E5%9F%BA%E4%BA%8E-Nginx-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/">音视频学习 (十) 基于 Nginx 搭建直播服务器</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a> / <a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/">nginx</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:21:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B9%9D-FFmpeg-librtmp-%E5%AE%9E%E7%8E%B0%E6%8B%89%E6%B5%81%E6%92%AD%E6%94%BE%E5%99%A8/">音视频学习 (九) FFmpeg + librtmp 实现拉流播放器</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:13:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/">音视频学习 (八) 视频渲染</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="DevYK 个人博客" height="28"></a><p class="size-small"><span>&copy; 2020 DevYK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>