<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>音视频学习 (八) 视频渲染 - DevYK 个人博客</title><meta description="简介上一篇文章我们学习了音频的基础知识和音频的渲染之后，该篇我们学习视频的知识，与上一篇学习方式一样，基础 + demo ，主打渲染，采集跟编码我们后面学习播放器和录屏在来研究。 视频的基础知识图像的物理现象做过 Camera 采集或者做过帧动画其实应该知道，视频是由一幅幅图像或者说一帧帧 YUV 数据组成，所以要学习视频还得从图像开始学习。 我们回顾一下，应该是初中的时候做过一个三棱镜实验，内"><meta property="og:type" content="blog"><meta property="og:title" content="音视频学习 (八) 视频渲染"><meta property="og:url" content="http://yoursite.com/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"><meta property="og:site_name" content="DevYK 个人博客"><meta property="og:description" content="简介上一篇文章我们学习了音频的基础知识和音频的渲染之后，该篇我们学习视频的知识，与上一篇学习方式一样，基础 + demo ，主打渲染，采集跟编码我们后面学习播放器和录屏在来研究。 视频的基础知识图像的物理现象做过 Camera 采集或者做过帧动画其实应该知道，视频是由一幅幅图像或者说一帧帧 YUV 数据组成，所以要学习视频还得从图像开始学习。 我们回顾一下，应该是初中的时候做过一个三棱镜实验，内"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214005005.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214003820.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200224235100.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200213232202.gif"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200118212209.gif"><meta property="article:published_time" content="2020-06-04T10:13:00.000Z"><meta property="article:modified_time" content="2020-06-04T15:54:59.155Z"><meta property="article:author" content="DevYK"><meta property="article:tag" content="音视频学习路线"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214005005.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"},"headline":"DevYK 个人博客","image":["https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214005005.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214003820.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200224235100.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200213232202.gif","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200118212209.gif"],"datePublished":"2020-06-04T10:13:00.000Z","dateModified":"2020-06-04T15:54:59.155Z","author":{"@type":"Person","name":"DevYK"},"description":"简介上一篇文章我们学习了音频的基础知识和音频的渲染之后，该篇我们学习视频的知识，与上一篇学习方式一样，基础 + demo ，主打渲染，采集跟编码我们后面学习播放器和录屏在来研究。 视频的基础知识图像的物理现象做过 Camera 采集或者做过帧动画其实应该知道，视频是由一幅幅图像或者说一帧帧 YUV 数据组成，所以要学习视频还得从图像开始学习。 我们回顾一下，应该是初中的时候做过一个三棱镜实验，内"}</script><link rel="canonical" href="http://yoursite.com/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="DevYK 个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:13:00.000Z" title="2020-06-04T10:13:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">1 小时 读完 (大约 6894 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">音视频学习 (八) 视频渲染</h1><div class="content"><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214005005.png" alt=""></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>上一篇文章我们学习了音频的基础知识和音频的渲染之后，该篇我们学习视频的知识，与上一篇学习方式一样，基础 + demo ，主打渲染，采集跟编码我们后面学习播放器和录屏在来研究。</p>
<h2 id="视频的基础知识"><a href="#视频的基础知识" class="headerlink" title="视频的基础知识"></a>视频的基础知识</h2><h3 id="图像的物理现象"><a href="#图像的物理现象" class="headerlink" title="图像的物理现象"></a>图像的物理现象</h3><p>做过 Camera 采集或者做过帧动画其实应该知道，视频是由一幅幅图像或者说一帧帧 YUV 数据组成，所以要学习视频还得从图像开始学习。</p>
<p>我们回顾一下，应该是初中的时候做过一个三棱镜实验，内容是如何利用三棱镜将太阳光分解成彩色的光带？第一个做这个实验者是 <strong>牛顿</strong> ，各色光因其所形成的折射角不同而彼此分离，就像彩虹一样，所以白光能够分解成多种色彩的光。后来人们通过实验证明，红绿蓝三种色光无法被分解，故称为三原色光，等量的三原色光相加会变为白光，即白光中含有等量的红光(R),绿光(G),蓝光(B)。</p>
<p>在日常生活中，由于光的反射，我们才能看到各类物体的轮廓和颜色。但是如果将这个理论应用到手机中，那么该结论还成立吗？答案是否定的，因为在黑暗中我们也可以看到手机屏幕中的内容，实际上人眼能看到手机屏幕上的内容的原理如下。</p>
<a id="more"></a>

<p>假设一部手机屏幕的分辨率是 1920 * 1080 说明水平方向有 1080 个像素点，垂直方向有 1920 个像素点，所以整个屏幕就有 1920 * 1080 个像素点(这也是分辨率的含义)。每个像素点都由三个子像素点组成，如下图所示，这些密密麻麻的子像素点在图像放大或者在显微镜下可以看得一清二楚。当要显示某篇文字或者某幅图像时，就会把这幅图像的每一个像素点的 RGB 通道分别对应的屏幕位置上的子像素点绘制到屏幕上，从而显示整个图像。</p>
<p>所以在黑暗的环境下也能看到手机屏幕上的内容，是因为手机屏幕是自发光的，而不是通过光的反射才被人们看到的。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200214003820.png" alt=""></p>
<h3 id="图像的数值表示"><a href="#图像的数值表示" class="headerlink" title="图像的数值表示"></a>图像的数值表示</h3><h4 id="RGB-表示方式"><a href="#RGB-表示方式" class="headerlink" title="RGB 表示方式"></a>RGB 表示方式</h4><p>通过上一小节我们清楚的知道任何一个图像都是由 RGB 组成，那么一个像素点的 RGB 该如何表示呢？音频里面的每一个采样 (sample) 均使用 16 bit 来表示，那么像素里面的子像素又该如何表示呢？通常的表示方式有以下几种。</p>
<ul>
<li>浮点表示: 取值范围在 0.0 ~ 1.0 之间，比如在 OpenGL ES 中对每一个子像素点的表示使用的就是这种方式。</li>
<li>整数表示: 取值范围为 0 ~ 255 或者 00 ~ FF , 8 个 bit 表示一个子像素点，32 个 bit 表示一个像素，这就是类似某些平台上表示图像格式的 RGBA_8888 数据格式。比如 Android 平台上的 RGB_565 的表示方法为 16 个 bit 模式表示一个像素， R 用 5 个 bit , G 用 6 个 bit, B 用 5 个 bit 来表示。</li>
</ul>
<p>对于一幅图像，一般使用整数表示方法进行描述，比如计算一张 1920 * 1080 的 RGB_8888 的图像大小，可采用如下计算方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1920 * 1080 * 4 &#x2F; 1024 &#x2F; 1024 ≈ 7.910 MB</span><br></pre></td></tr></table></figure>

<p>这也是 Bitmap 在内存中所占用的大小，所以每一张图像的裸数据都是很大的。对于图像的裸数据来说，直接来网络中进行传输也是不大可能的，所以就有了图像的压缩格式，比如我之前开源过一个基于 <a href="https://github.com/yangkun19921001/LIBJPEG_SAMPLE">JPEG 压缩</a> :JPEG 是静态图像压缩标准，由 ISO 制定。 JPEG 图像压缩算法在提供良好的压缩性能的同时，具有较好的重建质量。这种算法被广泛应用于图像处理领域，当然它也是一种有损压缩。在很多网站如淘宝上使用的都是这种压缩之后的图像，但是，这种压缩不能直接应用于视频压缩，因为对于视频来讲，还有一个时域上的因素需要考虑，也就是说不仅仅要考虑帧内编码，还要考虑帧间编码。视频采用的是更加成熟的算法，关于视频压缩算法的相关内容我们会在后面进行介绍。</p>
<h4 id="YUV-表示方式"><a href="#YUV-表示方式" class="headerlink" title="YUV 表示方式"></a>YUV 表示方式</h4><p>对于视频帧的裸数据表示，其实更多的是 YUV 数据格式的表示， YUV 主要应用于优化彩色视频信号的传输，使其向后兼容老式黑白电视。在 RGB 视频信号传输相比，它最大的优点在于只需要占用极少的频宽(RGB 要求三个独立的视频信号同时传输)。其中 Y 表示明亮度，而 “U”,”V” 表示的则是色度值，它们的作用是描述影像的色彩及饱和度，用于指定像素的颜色。“亮度” 是透过 RGB 输入信号来建立的，方法时将 RGB 信号的特定部分叠加到一起。“色度” 则定义了颜色的两个方面 - 色调与饱和度，分别用 Cr 和 Cb 来表示。其中，Cr 反应了 RGB 输入信号红色部分与 RGB 信号亮度值之间的差异，而 Cb 反映的则是 RGB 输入信号蓝色部分与 RGB 信号亮度值之间的差异。</p>
<p>之所以采用 YUV 色彩空间，是因为它的亮度信号 Y 和色度信号 U、V 是分离的。如果只有 Y 信号分量而没有 U 、V 分量，那么这样表示的图像就是黑白灰图像。彩色电视采用 YUV 空间正是为了用亮度信号 Y 解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号，最常用的表示形式是 Y、U、V 都使用 8 字节来表示，所以取值范围是 0 ~ 255 。 在广播电视系统中不传输很低和很高的数值，实际上是为了防止信号变动造成过载， Y 的取值范围都是 16 ~ 235 ，UV 的取值范围都是 16 ~ 240。</p>
<p>YUV 最常用的采样格式是 4:2:0 ， 4:2:0 并不意味着只有 Y 、Cb 而没有 Cr 分量。它指的是对每行扫描线来说，只有一种色度分量是以 2：1 的抽样率来存储的。相邻的扫描行存储着不同的色度分量，也就是说，如果某一行是 4：2：0，那么下一行就是 4：0：2，在下一行是 4：2：0，以此类推。对于每个色度分量来说，水平方向和竖直方向的抽象率都是 2：1，所以可以说色度的抽样率是 4：1。对非压缩的 8 bit 量化的视频来说，8*4 的一张图片需要占用 48 byte 内存。</p>
<p>相较于 RGB ，我们可以计算一帧为 1920 * 1080 的视频帧，用 YUV420P 的格式来表示，其数据量的大小如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1920 * 1080 * 1 + 1920 * 1080 * 0.5 ) &#x2F; 1024 &#x2F;1024 ≈ 2.966MB</span><br></pre></td></tr></table></figure>

<p>如果 fps（1 s 的视频帧数量）是 25 ，按照 5 分钟的一个短视频来计算，那么这个短视频用 YUV420P 的数据格式来表示的话，其数据量的大小就是 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.966MB * 25fps * 5min * 60s &#x2F; 1024 ≈ 21GB</span><br></pre></td></tr></table></figure>

<p>可以看到仅仅 5 分钟的视频数据量就能达到 21 G, 像抖音，快手这样短视频领域的代表这样的话还不卡死，那么如何对短视频进行存储以及流媒体播放呢？答案肯定是需要进行视频编码，后面会介绍视频编码的内容。</p>
<p>如果对 YUV  采样或者存储不明白的可以看这篇文章:<a href="https://zhuanlan.zhihu.com/p/68532444">音视频基础知识—像素格式YUV</a></p>
<h4 id="YUV-和-RGB-的转化"><a href="#YUV-和-RGB-的转化" class="headerlink" title="YUV 和 RGB 的转化"></a>YUV 和 RGB 的转化</h4><p>前面已经讲过，凡是渲染到屏幕上的文字、图片、或者其它，都需要转为 RGB 的表示形式，那么 YUV 的表示形式和 RGB 的表示形式之间是如何进行转换的呢？可以参考该篇文章<a href="http://blog.shenyuanluo.com/ColorConverter.html">YUV &lt;——&gt; RGB 转换算法</a>, 相互转换 C++ 代码可以参考<a href="https://github.com/shenyuanluo/SYKit/tree/master/SYKit/SYConverter">地址</a></p>
<h3 id="视频的编码方式"><a href="#视频的编码方式" class="headerlink" title="视频的编码方式"></a>视频的编码方式</h3><h4 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h4><p>还记得上一篇文章我们学习的音频编码方式吗？音频的编码主要是去除冗余信息，从而实现数据量的压缩。那么对于视频压缩，又该从哪几个方面来对数据进行压缩呢？其实与之前提到的音频编码类似，视频压缩也是通过去除冗余信息来进行压缩的。相较于音频数据，视频数据有极强的相关性，也就是说有大量的冗余信息，包括空间上的冗余信息和时间上的冗余信息，具体包括以下几个部分。</p>
<ul>
<li>运动补偿: 运动补偿是通过先前的局部图像来预测，，补偿当前的局部图像，它是减少帧序列冗余信息的有效方法。</li>
<li>运动表示: 不同区域的图像需要使用不同的运动矢量来描述运动信息。</li>
<li>运动估计: 运动估计是从视频序列中抽取运动信息的一整套技术。</li>
</ul>
<p>使用帧内编码技术可以去除空间上的冗余信息。</p>
<p>大家还记得之前提到的图像编码<a href="https://github.com/libjpeg-turbo/libjpeg-turbo"> JPEG </a> 吗？对于视频， ISO 同样也制定了标准: Motion JPEG 即 MPEG ，MPEG 算法是适用于动态视频的压缩算法，它除了对单幅图像进行编码外，还利用图像序列中的相关原则去除冗余，这样可以大大提高视频的压缩比，截至目前，MPEG 的版本一直在不断更新中，主要包括这样几个版本: Mpeg1(用于 VCD)、Mpeg2(用于 DVD)、Mpeg4 AVC(现在流媒体使用最多的就是它了)。</p>
<p>想比较 ISO 指定的 MPEG 的视频压缩标准，ITU-T 指定的 H.261、H.262、H.263、H.264 一系列视频编码标准是一套单独的体系。其中，H.264 集中了以往标准的所有优点，并吸取了以往标准的经验，采样的是简洁设计，这使得它比 Mpeg4 更容易推广。现在使用最多的就是 H.264 标准, H.264 创造了多参考帧、多块类型、整数变换、帧内预测等新的压缩技术，使用了更精准的分像素运动矢量(1/4、1/8) 和新一代的环路滤波器，这使得压缩性能得到大大提高，系统也变得更加完善。</p>
<h4 id="编码概念"><a href="#编码概念" class="headerlink" title="编码概念"></a>编码概念</h4><p>视频编码中，每帧都代表着一幅静止的图像。而在进行实际压缩时，会采取各种算法以减少数据的容量，其中 IPB 帧就是最常见的一种。</p>
<h5 id="IPB-帧"><a href="#IPB-帧" class="headerlink" title="IPB 帧"></a>IPB 帧</h5><ul>
<li>I 帧:  表示关键帧，你可以理解为这一帧画面的完整保留，解码时只需要本帧数据就可以完成(包含完整画面)。</li>
<li>P 帧: 表示的是当前 P 帧与上一帧( I 帧或者 P帧)的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别生成最终画面。(也就是差别帧， P 帧没有完整画面数据，只有与前一帧的画面差别的数据。)</li>
<li>B 帧: 表示双向差别帧，也就是 B 帧记录的是当前帧与前后帧(前一个 I 帧或 P 帧和后面的 P 帧)的差别(具体比较复杂，有 4 种情况)， 换言之，要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面数据与本帧数据的叠加取得最终的画面。B 帧压缩率高，但是解码时 CPU 会比较吃力。 </li>
</ul>
<h5 id="IDR-帧与-I-帧的理解"><a href="#IDR-帧与-I-帧的理解" class="headerlink" title="IDR 帧与 I 帧的理解"></a>IDR 帧与 I 帧的理解</h5><p>在 H264 的概念中有一个帧称为 IDR 帧，那么 IDR 帧与 I 帧的区别是什么呢 ？ 首先要看下 IDR 的英文全称 instantaneous decoding refresh picture , 因为 H264 采用了多帧预测，所以 I 帧之后的 P 帧有可能会参考 I 帧之前的帧，这就使得在随机访问的时候不能以找到 I 帧作为参考条件，因为即使找到 I 帧，I 帧之后的帧还是有可能解析不出来，而 IDR 帧就是一种特殊的 I 帧，即这一帧之后的所有参考帧只会参考到这个 IDR 帧，而不会再参考前面的帧。在解码器中，一旦收到第一个 IDR 帧，就会立即清理参考帧缓冲区，并将 IDR 帧作为被参考的帧。</p>
<h5 id="PTS-与-DTS"><a href="#PTS-与-DTS" class="headerlink" title="PTS 与 DTS"></a>PTS 与 DTS</h5><p>DTS 主要用视频的解码，全称为(Decoding Time Stamp), PTS 主要用于解码阶段进行视频的同步和输出， 全称为 (Presentation Time Stamp) 。在没有 B 帧的情况下， DTS 和 PTS 的输出顺序是一样的。因为 B 帧打乱了解码和显示的顺序，所以一旦存在 B 帧， PTS 与 DTS 势必就会不同。在大多数编解码标准(H.264 或者 HEVC) 中，编码顺序和输入顺序并不一致，于是才会需要 PTS 和 DTS 这两种不同的时间戳。</p>
<h5 id="GOP-的概念"><a href="#GOP-的概念" class="headerlink" title="GOP 的概念"></a>GOP 的概念</h5><p>两个 I 帧之间形成的一组图片，就是 GOP (Group Of Picture) 的概念。通常在为编码器设置参数的时候，必须要设置 gop_size 的值，其代表的是两个 I 帧之间的帧数目。一个 GOP 中容量最大的帧就是 I 帧，所以相对来讲，gop_size 设置得越大，整个画面的质量就会越好，但是在解码端必须从接收到的第一个 I 帧开始才可以正确的解码出原始图像，否则会无法正确解码，在提高视频质量的技巧中，还有个技巧是多使用 B 帧，一般来说，I 的压缩率是 7 （与 JPG 差不多），P 是 20 ，B 可以达到 50 ，可见使用 B 帧能节省大量空间，节省出来的空间可以用来更多地保存 I 帧，这样就能在相同的码率下提供更好的画质，所以我们要根据不同的业务场景，适当地设置 gop_size 的大小，以得到更高质量的视频。</p>
<p>结合下图，希望可以帮组大家更好的理解 DTS 和 PTS 的概念。</p>
<p>!<img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200224235100.png" alt=""></p>
<h2 id="视频渲染"><a href="#视频渲染" class="headerlink" title="视频渲染"></a>视频渲染</h2><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h3><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200213232202.gif" alt=""></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://www.khronos.org/opengl/">OpenGL</a> (Open Graphics Lib) 定义了一个跨编程语言、跨平台编程的专业图形程序接口。可用于二维或三维图像的处理与渲染，它是一个功能强大、调用方便的底层图形库。对于嵌入式的设备，其提供了 <a href="https://developer.android.com/guide/topics/graphics/opengl?hl=zh-cN">OpenGL ES</a>(OpenGL for Embedded System) 版本，该版本是针对手机、Pad 等嵌入式设备而设计的，是 OpenGL 的一个子集。到目前为止，OpenGL ES 已经经历过很多版本的迭代与更新，到目前为止运用最广泛的还是 <a href="https://www.khronos.org/opengles/">OpenGL ES</a> 2.0 版本。我们接下来所实现的 Demo 就是基于 OpenGL ES 2.0 接口进行编程并实现图像的渲染。</p>
<p>由于 OpenGL ES 是基于跨平台的设计，所以在每个平台上都要有它的具体实现，既要提供 OpenGL ES 的上下文环境以及窗口的管理。在 OpenGL 的设计中，OpenGL 是不负责管理窗口的。那么在 Android 平台上其实是使用 EGL 提供本地平台对 OpenGL ES 的实现。 </p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>要在 Android 平台下使用 OpenGL ES , 第一种方式是直接使用 GLSurfaceView  ，通过这种方式使用 OpenGL ES 比较简单，因为不需要开发者搭建 OpenGL ES 的上下文环境，以及创建 OpenGL ES 的显示设备。但是凡事都有两面，有好处也有坏处，使用 GLSurfaceView 不够灵活，很多真正的 OpenGL ES 的核心用法(比如共享上下文来达到多线程使用 EGL 的 API 来搭建的，并且是基于 C++ 的环境搭建的。因为如果仅仅在 Java 层编写 ，那么对于普通的应用也许可行，但是对于要进行解码或者使用第三方库的场景(比如人脸识别)，则需要到 C++ 层来实施。处于效率和性能的考虑，这里的架构将直接使用 Native 层的 EGL 搭建一个 OpenGL ES 的开发环境。要想在 Native 层使用 EGL ,那么就必须在 CmakeLists.txt 中添加 EGL 库(可以参考如下提供的 CMakeLists 文件配置)，并在使用该库的 C++ 文件中引入对应的头文件，需要引如的头文件地址如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 在开发中如果要使用 EGL 需要在 CMakeLists.txt 中添加 EGL 库，并指定头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 EGL 需要添加的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;EGL/egl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;EGL/eglext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用 OpenGL ES 2.0  也需要在 CMakeLists.txt 中添加 GLESv2 库，并指定头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 OpenGL ES 2.0 需要添加的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLES2/gl2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLES2/gl2ext.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>CMakeLists 文件配置:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#音频渲染</span></span><br><span class="line"><span class="keyword">set</span>(OpenSL <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/opensl)</span><br><span class="line"><span class="comment">#视频渲染</span></span><br><span class="line"><span class="keyword">set</span>(OpenGL <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/gles)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了</span></span><br><span class="line"><span class="keyword">file</span>(GLOB ALL_CPP <span class="variable">$&#123;OpenSL&#125;</span>/*.cpp <span class="variable">$&#123;OpenGL&#125;</span>/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加自己编写 cpp 源文件生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(audiovideo SHARED <span class="variable">$&#123;ALL_CPP&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#找系统中 NDK log库</span></span><br><span class="line"><span class="keyword">find_library</span>(log_lib</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后才开始链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">				<span class="comment">#最后生成的 so 库名称</span></span><br><span class="line">        audiovideo</span><br><span class="line">        <span class="comment">#音频渲染</span></span><br><span class="line">        OpenSLES</span><br><span class="line"></span><br><span class="line">        <span class="comment"># OpenGL 与 NativeWindow 连接本地窗口的中间者</span></span><br><span class="line">        EGL</span><br><span class="line">        <span class="comment">#视频渲染</span></span><br><span class="line">        GLESv2</span><br><span class="line">        <span class="comment">#添加本地库</span></span><br><span class="line">        android</span><br><span class="line"></span><br><span class="line">        <span class="variable">$&#123;log_lib&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>至此，对于 OpenGL 的开发需要用到的头文件以及库文件就引入完毕了，下面再来看看如何使用 EGL 搭建出 OpenGL 的上下文环境以及渲染视频数据。</p>
<ul>
<li><ol>
<li><p>使用 EGL 首先必须创建，建立本地窗口系统和 OpenGL ES 的连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取原始窗口</span></span><br><span class="line">nativeWindow = ANativeWindow_fromSurface(env, surface);</span><br><span class="line"><span class="comment">//获取Display</span></span><br><span class="line"><span class="built_in">display</span> = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">display</span> == EGL_NO_DISPLAY) &#123;</span><br><span class="line">        LOGD(<span class="string">"egl display failed"</span>);</span><br><span class="line">        showMessage(env, <span class="string">"egl display failed"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>初始化 EGL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化egl，后两个参数为主次版本号</span></span><br><span class="line">    <span class="keyword">if</span> (EGL_TRUE != eglInitialize(<span class="built_in">display</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        LOGD(<span class="string">"eglInitialize failed"</span>);</span><br><span class="line">        showMessage(env, <span class="string">"eglInitialize failed"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li><p>确定可用的渲染表面（ Surface ）的配置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//surface 配置，可以理解为窗口</span></span><br><span class="line">EGLConfig eglConfig;</span><br><span class="line">EGLint configNum;</span><br><span class="line">EGLint configSpec[] = &#123;</span><br><span class="line">        EGL_RED_SIZE, <span class="number">8</span>,</span><br><span class="line">        EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">        EGL_BLUE_SIZE, <span class="number">8</span>,</span><br><span class="line">        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,</span><br><span class="line">        EGL_NONE</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> (EGL_TRUE != eglChooseConfig(<span class="built_in">display</span>, configSpec, &amp;eglConfig, <span class="number">1</span>, &amp;configNum)) &#123;</span><br><span class="line">    LOGD(<span class="string">"eglChooseConfig failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"eglChooseConfig failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="4">
<li><p>创建渲染表面 surface（4/5步骤可互换）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建surface(egl和NativeWindow进行关联。最后一个参数为属性信息，0表示默认版本)</span></span><br><span class="line">    winSurface = eglCreateWindowSurface(<span class="built_in">display</span>, eglConfig, nativeWindow, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (winSurface == EGL_NO_SURFACE) &#123;</span><br><span class="line">        LOGD(<span class="string">"eglCreateWindowSurface failed"</span>);</span><br><span class="line">        showMessage(env, <span class="string">"eglCreateWindowSurface failed"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="5">
<li><p>创建渲染上下文 Context</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4 创建关联上下文</span></span><br><span class="line"><span class="keyword">const</span> EGLint ctxAttr[] = &#123;</span><br><span class="line">        EGL_CONTEXT_CLIENT_VERSION, <span class="number">2</span>, EGL_NONE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//EGL_NO_CONTEXT表示不需要多个设备共享上下文</span></span><br><span class="line">context = eglCreateContext(<span class="built_in">display</span>, eglConfig, EGL_NO_CONTEXT, ctxAttr);</span><br><span class="line"><span class="keyword">if</span> (context == EGL_NO_CONTEXT) &#123;</span><br><span class="line">    LOGD(<span class="string">"eglCreateContext failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"eglCreateContext failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="6">
<li><p>指定某个 EGLContext 为当前上下文, 关联起来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将egl和opengl关联</span></span><br><span class="line"><span class="comment">//两个surface一个读一个写。第二个一般用来离线渲染</span></span><br><span class="line"><span class="keyword">if</span> (EGL_TRUE != eglMakeCurrent(<span class="built_in">display</span>, winSurface, winSurface, context)) &#123;</span><br><span class="line">    LOGD(<span class="string">"eglMakeCurrent failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"eglMakeCurrent failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="7">
<li><p>使用 OpenGL 相关的 API 进行绘制操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">GLint vsh = initShader(vertexShader, GL_VERTEX_SHADER);</span><br><span class="line">GLint fsh = initShader(fragYUV420P, GL_FRAGMENT_SHADER);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//创建渲染程序</span></span><br><span class="line">GLint program = glCreateProgram();</span><br><span class="line"><span class="keyword">if</span> (program == <span class="number">0</span>) &#123;</span><br><span class="line">    LOGD(<span class="string">"glCreateProgram failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"glCreateProgram failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//向渲染程序中加入着色器</span></span><br><span class="line">glAttachShader(program, vsh);</span><br><span class="line">glAttachShader(program, fsh);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//链接程序</span></span><br><span class="line">glLinkProgram(program);</span><br><span class="line">GLint status = <span class="number">0</span>;</span><br><span class="line">glGetProgramiv(program, GL_LINK_STATUS, &amp;status);</span><br><span class="line"><span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">    LOGD(<span class="string">"glLinkProgram failed"</span>);</span><br><span class="line">    showMessage(env, <span class="string">"glLinkProgram failed"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LOGD(<span class="string">"glLinkProgram success"</span>);</span><br><span class="line"><span class="comment">//激活渲染程序</span></span><br><span class="line">glUseProgram(program);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//加入三维顶点数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> ver[] = &#123;</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line">GLuint apos = <span class="keyword">static_cast</span>&lt;GLuint&gt;(glGetAttribLocation(program, <span class="string">"aPosition"</span>));</span><br><span class="line">glEnableVertexAttribArray(apos);</span><br><span class="line">glVertexAttribPointer(apos, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, ver);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//加入纹理坐标数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> fragment[] = &#123;</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">GLuint aTex = <span class="keyword">static_cast</span>&lt;GLuint&gt;(glGetAttribLocation(program, <span class="string">"aTextCoord"</span>));</span><br><span class="line">glEnableVertexAttribArray(aTex);</span><br><span class="line">glVertexAttribPointer(aTex, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, fragment);</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">//纹理初始化</span></span><br><span class="line"><span class="comment">//设置纹理层对应的对应采样器？</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  //获取一致变量的存储位置</span></span><br><span class="line"><span class="comment">GLint textureUniformY = glGetUniformLocation(program, "SamplerY");</span></span><br><span class="line"><span class="comment">GLint textureUniformU = glGetUniformLocation(program, "SamplerU");</span></span><br><span class="line"><span class="comment">GLint textureUniformV = glGetUniformLocation(program, "SamplerV");</span></span><br><span class="line"><span class="comment">//对几个纹理采样器变量进行设置</span></span><br><span class="line"><span class="comment">glUniform1i(textureUniformY, 0);</span></span><br><span class="line"><span class="comment">glUniform1i(textureUniformU, 1);</span></span><br><span class="line"><span class="comment">glUniform1i(textureUniformV, 2);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//对sampler变量，使用函数glUniform1i和glUniform1iv进行设置</span></span><br><span class="line">glUniform1i(glGetUniformLocation(program, <span class="string">"yTexture"</span>), <span class="number">0</span>);</span><br><span class="line">glUniform1i(glGetUniformLocation(program, <span class="string">"uTexture"</span>), <span class="number">1</span>);</span><br><span class="line">glUniform1i(glGetUniformLocation(program, <span class="string">"vTexture"</span>), <span class="number">2</span>);</span><br><span class="line"><span class="comment">//纹理ID</span></span><br><span class="line">GLuint texts[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//创建若干个纹理对象，并且得到纹理ID</span></span><br><span class="line">glGenTextures(<span class="number">3</span>, texts);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//绑定纹理。后面的的设置和加载全部作用于当前绑定的纹理对象</span></span><br><span class="line"><span class="comment">//GL_TEXTURE0、GL_TEXTURE1、GL_TEXTURE2 的就是纹理单元，GL_TEXTURE_1D、GL_TEXTURE_2D、CUBE_MAP为纹理目标</span></span><br><span class="line"><span class="comment">//通过 glBindTexture 函数将纹理目标和纹理绑定后，对纹理目标所进行的操作都反映到对纹理上</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texts[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//缩小的过滤器</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//放大的过滤器</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//设置纹理的格式和大小</span></span><br><span class="line"><span class="comment">// 加载纹理到 OpenGL，读入 buffer 定义的位图数据，并把它复制到当前绑定的纹理对象</span></span><br><span class="line"><span class="comment">// 当前绑定的纹理对象就会被附加上纹理图像。</span></span><br><span class="line"><span class="comment">//width,height表示每几个像素公用一个yuv元素？比如width / 2表示横向每两个像素使用一个元素？</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D,</span><br><span class="line">             <span class="number">0</span>,<span class="comment">//细节基本 默认0</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//gpu内部格式 亮度，灰度图（这里就是只取一个亮度的颜色通道的意思）</span></span><br><span class="line">             <span class="built_in">width</span>,<span class="comment">//加载的纹理宽度。最好为2的次幂(这里对y分量数据当做指定尺寸算，但显示尺寸会拉伸到全屏？)</span></span><br><span class="line">             <span class="built_in">height</span>,<span class="comment">//加载的纹理高度。最好为2的次幂</span></span><br><span class="line">             <span class="number">0</span>,<span class="comment">//纹理边框</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//数据的像素格式 亮度，灰度图</span></span><br><span class="line">             GL_UNSIGNED_BYTE,<span class="comment">//像素点存储的数据类型</span></span><br><span class="line">             <span class="literal">NULL</span> <span class="comment">//纹理的数据（先不传）</span></span><br><span class="line">);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//绑定纹理</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texts[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//缩小的过滤器</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//设置纹理的格式和大小</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D,</span><br><span class="line">             <span class="number">0</span>,<span class="comment">//细节基本 默认0</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//gpu内部格式 亮度，灰度图（这里就是只取一个颜色通道的意思）</span></span><br><span class="line">             <span class="built_in">width</span> / <span class="number">2</span>,<span class="comment">//u数据数量为屏幕的4分之1</span></span><br><span class="line">             <span class="built_in">height</span> / <span class="number">2</span>,</span><br><span class="line">             <span class="number">0</span>,<span class="comment">//边框</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//数据的像素格式 亮度，灰度图</span></span><br><span class="line">             GL_UNSIGNED_BYTE,<span class="comment">//像素点存储的数据类型</span></span><br><span class="line">             <span class="literal">NULL</span> <span class="comment">//纹理的数据（先不传）</span></span><br><span class="line">);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//绑定纹理</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texts[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//缩小的过滤器</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//设置纹理的格式和大小</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D,</span><br><span class="line">             <span class="number">0</span>,<span class="comment">//细节基本 默认0</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//gpu内部格式 亮度，灰度图（这里就是只取一个颜色通道的意思）</span></span><br><span class="line">             <span class="built_in">width</span> / <span class="number">2</span>,</span><br><span class="line">             <span class="built_in">height</span> / <span class="number">2</span>,<span class="comment">//v数据数量为屏幕的4分之1</span></span><br><span class="line">             <span class="number">0</span>,<span class="comment">//边框</span></span><br><span class="line">             GL_LUMINANCE,<span class="comment">//数据的像素格式 亮度，灰度图</span></span><br><span class="line">             GL_UNSIGNED_BYTE,<span class="comment">//像素点存储的数据类型</span></span><br><span class="line">             <span class="literal">NULL</span> <span class="comment">//纹理的数据（先不传）</span></span><br><span class="line">);</span><br><span class="line">     </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buf[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">buf[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[<span class="built_in">width</span> * <span class="built_in">height</span>];<span class="comment">//y</span></span><br><span class="line">buf[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[<span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">4</span>];<span class="comment">//u</span></span><br><span class="line">buf[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[<span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">4</span>];<span class="comment">//v</span></span><br><span class="line">     </span><br><span class="line">showMessage(env, <span class="string">"onSucceed"</span>, <span class="literal">true</span>);</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">FILE *fp = fopen(data_source, <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">    LOGD(<span class="string">"oepn file %s fail"</span>, data_source);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">    <span class="comment">//解决异常退出,终止读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (!isPlay)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    fread(buf[<span class="number">0</span>], <span class="number">1</span>, <span class="built_in">width</span> * <span class="built_in">height</span>, fp);</span><br><span class="line">    fread(buf[<span class="number">1</span>], <span class="number">1</span>, <span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">4</span>, fp);</span><br><span class="line">    fread(buf[<span class="number">2</span>], <span class="number">1</span>, <span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">4</span>, fp);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//激活第一层纹理，绑定到创建的纹理</span></span><br><span class="line">    <span class="comment">//下面的width,height主要是显示尺寸？</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE0);</span><br><span class="line">    <span class="comment">//绑定y对应的纹理</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texts[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//替换纹理，比重新使用glTexImage2D性能高多</span></span><br><span class="line">    glTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>,<span class="comment">//相对原来的纹理的offset</span></span><br><span class="line">                    <span class="built_in">width</span>, <span class="built_in">height</span>,<span class="comment">//加载的纹理宽度、高度。最好为2的次幂</span></span><br><span class="line">                    GL_LUMINANCE, GL_UNSIGNED_BYTE,</span><br><span class="line">                    buf[<span class="number">0</span>]);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//激活第二层纹理，绑定到创建的纹理</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE1);</span><br><span class="line">    <span class="comment">//绑定u对应的纹理</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texts[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//替换纹理，比重新使用glTexImage2D性能高</span></span><br><span class="line">    glTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">width</span> / <span class="number">2</span>, <span class="built_in">height</span> / <span class="number">2</span>, GL_LUMINANCE,</span><br><span class="line">                    GL_UNSIGNED_BYTE,</span><br><span class="line">                    buf[<span class="number">1</span>]);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//激活第三层纹理，绑定到创建的纹理</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE2);</span><br><span class="line">    <span class="comment">//绑定v对应的纹理</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texts[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//替换纹理，比重新使用glTexImage2D性能高</span></span><br><span class="line">    glTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">width</span> / <span class="number">2</span>, <span class="built_in">height</span> / <span class="number">2</span>, GL_LUMINANCE,</span><br><span class="line">                    GL_UNSIGNED_BYTE,</span><br><span class="line">                    buf[<span class="number">2</span>]);</span><br><span class="line">     </span><br><span class="line">    glDrawArrays(GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//8. 窗口显示，交换双缓冲区</span></span><br><span class="line">    eglSwapBuffers(<span class="built_in">display</span>, winSurface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="8">
<li><p>交换 EGL 的 Surface 的内部缓冲和 EGL 创建的和平台无关的窗口 diaplay</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口显示，交换双缓冲区</span></span><br><span class="line">eglSwapBuffers(<span class="built_in">display</span>, winSurface);</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="9">
<li><p>释放资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gles_play::release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">display</span> || winSurface || context) &#123;</span><br><span class="line">        <span class="comment">//销毁显示设备</span></span><br><span class="line">        eglDestroySurface(<span class="built_in">display</span>, winSurface);</span><br><span class="line">        <span class="comment">//销毁上下文</span></span><br><span class="line">        eglDestroyContext(<span class="built_in">display</span>, context);</span><br><span class="line">        <span class="comment">//释放窗口</span></span><br><span class="line">        ANativeWindow_release(nativeWindow);</span><br><span class="line">        <span class="comment">//释放线程</span></span><br><span class="line">        eglReleaseThread();</span><br><span class="line">        <span class="comment">//停止</span></span><br><span class="line">        eglTerminate(<span class="built_in">display</span>);</span><br><span class="line">        eglMakeCurrent(<span class="built_in">display</span>, winSurface, EGL_NO_SURFACE, context);</span><br><span class="line">        context = EGL_NO_CONTEXT;</span><br><span class="line">        <span class="built_in">display</span> = EGL_NO_SURFACE;</span><br><span class="line">        winSurface = <span class="literal">nullptr</span>;</span><br><span class="line">        winSurface = <span class="number">0</span>;</span><br><span class="line">        nativeWindow = <span class="number">0</span>;</span><br><span class="line">        isPlay = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>到这里整个 OpenGL ES 渲染工作都完成了，代码已上传到 <a href="https://github.com/yangkun19921001/ndk_study/blob/master/audio_video/src/main/java/com/devyk/audiovideo/video/VideoPlayActivity.java">GitHub 仓库，需要的可以自行查看</a>,注意: 测试的时候需要把 raw/*.yuv 放入 sdcard/ 根目录中。</p>
<p><a href="https://wemp.app/posts/051d4914-5332-4472-8995-d93c1753aa4f">OpenGL ES 使用可以参考该篇博客</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章的概念比较多，难免会枯燥一些，但是了解这些概念是必须的。下一篇将带来 FFmpeg + LibRtmp 播放器开发练习，支持 rtmp 拉流、本地视频播放(该篇文章和上一篇文章都分别讲解了音频视频基础和渲染就是为了播放器开发做准备)，可以先看一下效果(如下图)。是不是有那么一点小小的期待 😜 ，预计在 2 月下旬发布文章，在等一等。</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200118212209.gif" alt=""></p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">音视频学习路线</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200604150710.jpeg" alt="支付宝"></span></a><a class="button donate" href="/" style="background-color:rgba(255,128,62,.87);border-color:transparent;color:white;" target="_blank" rel="noopener"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button is-danger donate" href="/" target="_blank" rel="noopener"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200604150835.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B9%9D-FFmpeg-librtmp-%E5%AE%9E%E7%8E%B0%E6%8B%89%E6%B5%81%E6%92%AD%E6%94%BE%E5%99%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">音视频学习 (九) FFmpeg + librtmp 实现拉流播放器</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E9%9F%B3%E9%A2%91%E6%B8%B2%E6%9F%93/"><span class="level-item">音视频学习 (七) 音频渲染</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "j16d0HiTJvVWRQzjQN625f4W-gzGzoHsz",
            appKey: "7cgla0UfvddS9PjRz7Lcvqn7",
            placeholder: "请遵守中华人民共和国法律法规。填写邮箱信息以接收回复。",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200427113132.jpeg" alt="DevYK"></figure><p class="title is-size-4 is-block line-height-inherit">DevYK</p><p class="is-size-6 is-block">Android/NDK/音视频/跨平台</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>BeiJing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yangkun19921001" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yangkun19921001"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="http://wpa.qq.com/msgrd?v=1&amp;uin=919079498&amp;site=ioshenmue&amp;menu=yes"><i class="fab fa-qq"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://github.com/yangkun19921001/Blog/blob/master/about.md" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">联系我</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://juejin.im/user/578259398ac2470061f3a3fb/posts" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.im</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/README/"><span class="level-start"><span class="level-item">README</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/"><span class="level-start"><span class="level-item">专题</span></span><span class="level-end"><span class="level-item tag">25</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="level-start"><span class="level-item">性能优化</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/"><span class="level-start"><span class="level-item">音视频</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">服务</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1/apprtc/"><span class="level-start"><span class="level-item">apprtc</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/webrtc/"><span class="tag">webrtc</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"><span class="tag">关于我</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"><span class="tag">音视频学习路线</span><span class="tag is-grey-lightest">12</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-05T05:26:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/about/">README</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/README/">README</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:33:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E5%BF%85%E7%9C%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/">必看的性能优化总结</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:31:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%B8%89-%E7%A8%B3%E5%AE%9A%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96%E4%B9%8B%E6%8D%95%E8%8E%B7-Native-Crash/">性能优化 (十三) 稳定运行优化之捕获 Native Crash </a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:30:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%BA%8C-%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96%E4%B9%8B%E6%9E%81%E9%99%90%E7%98%A6%E8%BA%AB/">性能优化 (十二) 体积优化之极限瘦身</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T16:29:00.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%B8%80-%E7%A8%B3%E5%AE%9A%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96%E4%B9%8B%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/">性能优化 (十一) 稳定运行优化之热修复原理探索</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="DevYK 个人博客" height="28"></a><p class="size-small"><span>&copy; 2020 DevYK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><a href="http://www.beian.miit.gov.cn">京ICP备19052442号-1</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>