<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>音视频学习 (十二) FFmpeg + OpenSL ES 实现音频播放器 - DevYK 个人博客</title><meta description="前言 唠叨一句: 说实话现在搞 Android 开发的要求是越来越高，初级都要被淘汰的感觉。所以想要一直往 Android 的道路上走，深入 音视频领域 是一个不错的选择。虽然现在跨平台 Flutter 很火，但终究它还是一个写 UI 的(个人看法)。程序员随着年龄的增长不可能一直写 UI 。但是深入 C&amp;#x2F;C++ 就不一样了。它可以给移动端甚至 Flutter 提供底层 SDK 和技术支持这难道不"><meta property="og:type" content="blog"><meta property="og:title" content="音视频学习 (十二) FFmpeg + OpenSL ES 实现音频播放器"><meta property="og:url" content="http://yoursite.com/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%BA%8C-FFmpeg-OpenSL-ES-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"><meta property="og:site_name" content="DevYK 个人博客"><meta property="og:description" content="前言 唠叨一句: 说实话现在搞 Android 开发的要求是越来越高，初级都要被淘汰的感觉。所以想要一直往 Android 的道路上走，深入 音视频领域 是一个不错的选择。虽然现在跨平台 Flutter 很火，但终究它还是一个写 UI 的(个人看法)。程序员随着年龄的增长不可能一直写 UI 。但是深入 C&amp;#x2F;C++ 就不一样了。它可以给移动端甚至 Flutter 提供底层 SDK 和技术支持这难道不"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505195250.gif"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505221954.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505204348.png"><meta property="og:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200315232530.jpg"><meta property="article:published_time" content="2020-06-04T10:26:00.000Z"><meta property="article:modified_time" content="2020-06-04T10:26:40.454Z"><meta property="article:author" content="DevYK"><meta property="article:tag" content="音视频学习路线"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505195250.gif"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%BA%8C-FFmpeg-OpenSL-ES-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"},"headline":"DevYK 个人博客","image":["https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505195250.gif","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505221954.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505204348.png","https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200315232530.jpg"],"datePublished":"2020-06-04T10:26:00.000Z","dateModified":"2020-06-04T10:26:40.454Z","author":{"@type":"Person","name":"DevYK"},"description":"前言 唠叨一句: 说实话现在搞 Android 开发的要求是越来越高，初级都要被淘汰的感觉。所以想要一直往 Android 的道路上走，深入 音视频领域 是一个不错的选择。虽然现在跨平台 Flutter 很火，但终究它还是一个写 UI 的(个人看法)。程序员随着年龄的增长不可能一直写 UI 。但是深入 C&#x2F;C++ 就不一样了。它可以给移动端甚至 Flutter 提供底层 SDK 和技术支持这难道不"}</script><link rel="canonical" href="http://yoursite.com/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%BA%8C-FFmpeg-OpenSL-ES-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="DevYK 个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">about</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-04T10:26:00.000Z" title="2020-06-04T10:26:00.000Z">2020-06-04</time><span class="level-item"> DevYK </span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span><span class="level-item">19 分钟 读完 (大约 2902 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">音视频学习 (十二) FFmpeg + OpenSL ES 实现音频播放器</h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>唠叨一句:</p>
<p>说实话现在搞 Android 开发的要求是越来越高，初级都要被淘汰的感觉。所以想要一直往 Android 的道路上走，深入 <strong>音视频领域</strong> 是一个不错的选择。虽然现在跨平台 <strong>Flutter</strong> 很火，但终究它还是一个写 UI 的(个人看法)。程序员随着年龄的增长不可能一直写 UI 。但是深入 <strong>C/C++</strong> 就不一样了。它可以给移动端甚至 <strong>Flutter</strong> 提供底层 SDK 和技术支持这难道不香吗？所以想要或者准备学习音视频知识的，那么该篇文章可以助你快速入门。</p>
</blockquote>
<p>五一假期即将结束，不知道大家玩的怎么样，我了也趁着这个假期抽出了一天时间去爬了长城，有句话不是说，不到长城非好汉嘛。何况来北京好些年了一直没机会去。之后利用剩下的这 4 天写了一个音频处理库，目前包含如下功能:</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>是否完成</th>
</tr>
</thead>
<tbody><tr>
<td>读取任意格式音频流</td>
<td>Yes</td>
</tr>
<tr>
<td>FFmpeg 音频解码为 PCM</td>
<td>Yes</td>
</tr>
<tr>
<td>音频 Native OpenSL ES 渲染</td>
<td>Yes</td>
</tr>
<tr>
<td>音量控制</td>
<td>Yes</td>
</tr>
<tr>
<td>seek 控制</td>
<td>Yes</td>
</tr>
<tr>
<td>声道切换</td>
<td>Yes</td>
</tr>
<tr>
<td><a href="[SoundTouch](https://gitlab.com/soundtouch/soundtouch)">变调变速</a></td>
<td>Yes</td>
</tr>
<tr>
<td>变声</td>
<td>No</td>
</tr>
<tr>
<td>裁剪音频输出 MP3/PCM 等格式</td>
<td>pcm-ok</td>
</tr>
<tr>
<td>边播边录制</td>
<td>No</td>
</tr>
<tr>
<td>音频编码为 AAC、MP3、WAV</td>
<td>No</td>
</tr>
</tbody></table>
<p>其实音频处理的库在 GitHub 搜都是一大堆，那为什么我自己还要写一个呢？原因是我不想当伸手党，如果每次都这样，那自己的技术何来进步，是吧？而且自己写的库也便于自己修改和增加一些特殊的功能。下面我就大概来说一下具体每个功能是如何实现及做一个音频处理的库需要搭建怎样的一个架构。当然我也不是一时兴起就来写一个音频处理库。</p>
<p>还是有一个小目标的:</p>
<ul>
<li><p>打造一个万能音频播放器。不管是直播源还是网络/本地源，只要给我一个路径我就能播放。</p>
</li>
<li><p>增加一些特殊的处理比如，变调变速、变声、裁剪…</p>
</li>
<li><p>一切皆有可能。</p>
</li>
</ul>
<p>可以看下效果图:</p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505195250.gif" alt=""></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>编码环境</strong></p>
<p>FFmpeg : 4.2.2</p>
<p>NDK: 17c</p>
<p>OS: MAC</p>
<p><strong>实现流程:</strong></p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505221954.png" alt=""></p>
<p><strong>粗略架构组成:</strong></p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200505204348.png" alt=""></p>
<p><strong><a href="https://github.com/JetBrains/kotlin">kotlin</a>:</strong></p>
<p><strong>Kotlin</strong> 语言是由 <strong>JetBrains</strong> 公司开发，2010 面世，2017 年正式在谷歌 I/O 大会上推荐 Kotlin 作为 Android 开发语言。</p>
<p><strong><a href="https://github.com/FFmpeg/FFmpeg">FFmpeg</a>:</strong></p>
<p>FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。</p>
<p><strong><a href="https://gitlab.com/soundtouch/soundtouch">SoundTouch</a>:</strong></p>
<p>可以在 PCM 音频裸流基础上对音频变调变速</p>
<p><strong><a href="https://developer.android.google.cn/ndk/guides/audio/opensl-for-android">OpenSLES</a>:</strong></p>
<p><strong>OpenSL ES</strong>（<strong>嵌入式系统的开放声音库</strong>）是一种免版税，跨平台，硬件加速的 <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C语言</a> 音频<a href="https://en.wikipedia.org/wiki/Application_programming_interface">API，</a>用于2D和3D音频。它提供对<a href="https://en.wikipedia.org/wiki/3D_audio">3D位置音频</a>和<a href="https://en.wikipedia.org/wiki/MIDI">MIDI</a>播放等功能的访问。它是为移动和游戏行业的开发人员设计的，致力于使跨多个平台的应用程序轻松移植。</p>
<h2 id="FFmpeg-初始化"><a href="#FFmpeg-初始化" class="headerlink" title="FFmpeg 初始化"></a>FFmpeg 初始化</h2><p>编译 FFmpeg 可以参考我之前写的文章<a href="https://juejin.im/post/5e1eace16fb9a02fec66474e">音视频学习 (六) 一键编译 32/64 位 FFmpeg 4.2.2</a></p>
<p>这里我们就按照 FFmpeg 初始化流程来进行介绍 API 如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 分配一个 AVFormatContext。</span></span><br><span class="line"><span class="function">AVFormatContext *<span class="title">avformat_alloc_context</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//对应的释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avformat_free_context</span><span class="params">(AVFormatContext *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 打开输入流，读取头部信息，一般包含有音频，视频流信息也可能有弹幕信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, ff_const59 AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br><span class="line"><span class="comment">//对应的关闭流信息，释放所有内容资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avformat_close_input</span><span class="params">(AVFormatContext **s)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//3. 读取媒体文件的数据包以获取流信息。返回 &gt;=0 则成功</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br><span class="line"><span class="comment">//3.1 拿到当前流的数量信息，一般会有音频，视频，或者弹幕</span></span><br><span class="line"><span class="keyword">int</span> number = (*AVFormatContext)-&gt;nb_streams</span><br><span class="line"><span class="comment">//3.2 遍历拿到对应的 stream</span></span><br><span class="line"><span class="comment">//视频流</span></span><br><span class="line"><span class="keyword">if</span> ((*pFormatCtx)-&gt;streams &amp;&amp; (*pFormatCtx)-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line"><span class="comment">//语音流</span></span><br><span class="line"> <span class="keyword">if</span> ((*pFormatCtx)-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO)</span><br><span class="line"><span class="comment">//其它流类型</span></span><br><span class="line"><span class="keyword">enum</span> AVMediaType &#123;</span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 根据 AVCodecID 拿到已经注册的解码器</span></span><br><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 分配一个 AVCodecContext </span></span><br><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="keyword">const</span> AVCodec *codec)</span></span>;</span><br><span class="line"><span class="comment">//对应的释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avcodec_free_context</span><span class="params">(AVCodecContext **avctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 给解码器设置参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> AVCodecParameters *par)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 打开解码器 is 0 success</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上 7 步如果没有问题证明编解码器打开成功，可以进行下一步操作。</p>
<h2 id="FFmpeg-读取音频帧"><a href="#FFmpeg-读取音频帧" class="headerlink" title="FFmpeg 读取音频帧"></a>FFmpeg 读取音频帧</h2><p>这里还是介绍 API 使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 分配一个 AVPacket </span></span><br><span class="line"><span class="function">AVPacket *<span class="title">av_packet_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//结果必须释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_packet_free</span><span class="params">(AVPacket **pkt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 读取待解码数据包</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对，就是这么简单，就调用 3 个 API 然后循环读取，送入待解码队列中。</p>
<h2 id="FFmpeg-解码音频为-PCM"><a href="#FFmpeg-解码音频为-PCM" class="headerlink" title="FFmpeg 解码音频为 PCM"></a>FFmpeg 解码音频为 PCM</h2><p>这里相当于是读取待解码队列中的数据，进行解码为 PCM 数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 将待解码数据 AVPacket 送入解码器 0 is ok</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVPacket *avpkt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 分配一个 AVFrame 用于接收解码之后的数据</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//对应的释放 API</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 接收解码之后的数据 0 is ok</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对解码之后的 PCM 进行统一重采样。规定一些格式，避免不统一而渲染异常</span></span><br><span class="line"><span class="comment">//4. 根据传入的参数来分配一个 SwrContext</span></span><br><span class="line"><span class="function">struct SwrContext *<span class="title">swr_alloc_set_opts</span><span class="params">(struct SwrContext *s,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int64_t</span> out_ch_layout, <span class="keyword">enum</span> AVSampleFormat out_sample_fmt, <span class="keyword">int</span> out_sample_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int64_t</span>  in_ch_layout, <span class="keyword">enum</span> AVSampleFormat  in_sample_fmt, <span class="keyword">int</span>  in_sample_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> log_offset, <span class="keyword">void</span> *log_ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.1 对 SwrContext 进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swr_init</span><span class="params">(struct SwrContext *s)</span></span>;</span><br><span class="line"><span class="comment">//4.2 开始重采样</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swr_convert</span><span class="params">(struct SwrContext *s, <span class="keyword">uint8_t</span> **out, <span class="keyword">int</span> out_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">uint8_t</span> **in , <span class="keyword">int</span> in_count)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="OpenSLES-渲染-PCM"><a href="#OpenSLES-渲染-PCM" class="headerlink" title="OpenSLES 渲染 PCM"></a>OpenSLES 渲染 PCM</h2><p>这里还是以流程的形式介绍 API 含义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建播放引擎</span></span><br><span class="line">result = slCreateEngine(&amp;engineObject, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">result = (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE);</span><br><span class="line">result = (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineEngine);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建混音器</span></span><br><span class="line"><span class="keyword">const</span> SLInterfaceID mids[<span class="number">1</span>] = &#123;SL_IID_ENVIRONMENTALREVERB&#125;;</span><br><span class="line"><span class="keyword">const</span> SLboolean mreq[<span class="number">1</span>] = &#123;SL_BOOLEAN_FALSE&#125;;</span><br><span class="line">result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE);</span><br><span class="line">result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB,</span><br><span class="line">                                              &amp;outputMixEnvironmentalReverb);</span><br><span class="line">    <span class="keyword">if</span> (SL_RESULT_SUCCESS == result) &#123;</span><br><span class="line">        result = (*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties(</span><br><span class="line">                outputMixEnvironmentalReverb, &amp;reverbSettings);</span><br><span class="line">        (<span class="keyword">void</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line">SLDataLocator_OutputMix outputMix = &#123;SL_DATALOCATOR_OUTPUTMIX, outputMixObject&#125;;</span><br><span class="line">SLDataSink audioSnk = &#123;&amp;outputMix, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 配置PCM格式信息</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue android_queue = &#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    SLDataFormat_PCM pcm = &#123;</span><br><span class="line">            SL_DATAFORMAT_PCM,<span class="comment">//播放pcm格式的数据</span></span><br><span class="line">            <span class="number">2</span>,<span class="comment">//2个声道（立体声）</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;SLuint32&gt;(getCurSampleRate(sample_rate)),<span class="comment">//44100hz的频率</span></span><br><span class="line">            SL_PCMSAMPLEFORMAT_FIXED_16,<span class="comment">//位数 16位</span></span><br><span class="line">            SL_PCMSAMPLEFORMAT_FIXED_16,<span class="comment">//和位数一致就行</span></span><br><span class="line">            SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT,<span class="comment">//立体声（前左前右）</span></span><br><span class="line">            SL_BYTEORDER_LITTLEENDIAN<span class="comment">//结束标志</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    SLDataSource slDataSource = &#123;&amp;android_queue, &amp;pcm&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> SLInterfaceID ids[<span class="number">3</span>] = &#123;SL_IID_BUFFERQUEUE, SL_IID_VOLUME, SL_IID_MUTESOLO&#125;;</span><br><span class="line">    <span class="keyword">const</span> SLboolean req[<span class="number">3</span>] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"></span><br><span class="line">    result = (*engineEngine)-&gt;CreateAudioPlayer(engineEngine, &amp;pcmPlayerObject, &amp;slDataSource, &amp;audioSnk,</span><br><span class="line">                                                <span class="keyword">sizeof</span>(ids) / <span class="keyword">sizeof</span>(ids[<span class="number">0</span>]), ids, req);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 初始化播放器</span></span><br><span class="line">result = (*pcmPlayerObject)-&gt;Realize(pcmPlayerObject, SL_BOOLEAN_FALSE);</span><br><span class="line">result = (*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_PLAY, &amp;pcmPlayerPlay);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 注册回调缓冲区 获取缓冲队列接口</span></span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_BUFFERQUEUE, &amp;pcmBufferQueue);</span><br><span class="line">(*pcmBufferQueue)-&gt;RegisterCallback(pcmBufferQueue, pcmBufferCallBack, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 设置播放状态</span></span><br><span class="line">(*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PLAYING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 手动激活回调接口</span></span><br><span class="line">pcmBufferCallBack(pcmBufferQueue, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>初始化就是这 7 大步，那么渲染的话，就是在 <code>pcmBufferCallBack</code> 中进行设置，直接上代码吧:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcmBufferCallBack</span><span class="params">(SLAndroidSimpleBufferQueueItf bf, <span class="keyword">void</span> *pVoid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> audioPlayer = <span class="keyword">static_cast</span>&lt;BaseAudioChannel *&gt;(pVoid);</span><br><span class="line">    <span class="keyword">if</span> (!audioPlayer)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (audioPlayer-&gt;status &amp;&amp; audioPlayer-&gt;status-&gt;<span class="built_in">exit</span>)</span><br><span class="line">        LOGE(<span class="string">"looper  pcmBufferCallBack start"</span>);</span><br><span class="line">    <span class="comment">//拿到 PCM 原始数据</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = audioPlayer-&gt;getPCMData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对 PCM 做变速变调操作。</span></span><br><span class="line">    <span class="built_in">size</span> = audioPlayer-&gt;setSoundTouchData();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">            <span class="comment">//8. 放入缓存，开始播放声音</span></span><br><span class="line">		(*audioPlayer-&gt;pcmBufferQueue)-&gt;Enqueue(audioPlayer-&gt;pcmBufferQueue, audioPlayer-&gt;out_pcm_buffer, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对，没错。第八步就是真正将 PCM 放入 OpenSL ES 缓冲队列中，这里要注意，一点要等它的上一帧渲染完在放入下一帧 PCM 数据。</p>
<h2 id="功能点实现"><a href="#功能点实现" class="headerlink" title="功能点实现:"></a>功能点实现:</h2><h3 id="声道选择"><a href="#声道选择" class="headerlink" title="声道选择"></a>声道选择</h3><p>声道操作直接操作的是 OpenSLES 接口，具体 API 如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 得到音频声道通道接口</span></span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_MUTESOLO, &amp;pcmChannelModePlay);</span><br><span class="line"><span class="comment">//2. 设置音频通道</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置音频通道</span></span><br><span class="line"><span class="comment"> * @param channelMode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseAudioChannel::setChannelMode</span><span class="params">(<span class="keyword">int</span> channelMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mChannelMode = channelMode;</span><br><span class="line">    <span class="keyword">if</span> (pcmChannelModePlay != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelMode == <span class="number">0</span>)<span class="comment">//右声道</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (channelMode == <span class="number">1</span>)<span class="comment">//左声道</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (channelMode == <span class="number">2</span>)<span class="comment">//立体声 通道为 2 也就是我们重采样设置的 AV_CH_LAYOUT_STEREO</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><p>声音音量控制这里还是基于的是 OpenSLES 接口，对应 API 如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 拿到音频声音控制接口</span></span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_VOLUME, &amp;pcmVolumePlay);</span><br><span class="line"><span class="comment">//2. 设置声音</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平滑设置当前音量</span></span><br><span class="line"><span class="comment"> * @param volume</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseAudioChannel::setVolume</span><span class="params">(<span class="keyword">int</span> percent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;curVolume = percent;</span><br><span class="line">    <span class="keyword">if</span> (pcmVolumePlay != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (percent &gt; <span class="number">30</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-20</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">25</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-22</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-25</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">15</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-28</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-30</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-34</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-37</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (percent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-40</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (<span class="number">100</span> - percent) * <span class="number">-100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语调语速设置"><a href="#语调语速设置" class="headerlink" title="语调语速设置"></a>语调语速设置</h3><p>语调语速功能这里用的开源的 <a href="https://gitlab.com/soundtouch/soundtouch">SoundTouch</a> ，具体实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BaseAudioChannel::setSoundTouchData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (status &amp;&amp; !status-&gt;<span class="built_in">exit</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            finished = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mBufSize &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;out_pcm_buffer) &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutexSpeed);</span><br><span class="line">                soundTouch-&gt;putSamples(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> SAMPLETYPE *&gt;(<span class="keyword">this</span>-&gt;out_pcm_buffer), <span class="keyword">this</span>-&gt;oldSize);</span><br><span class="line">                num = soundTouch-&gt;receiveSamples(<span class="keyword">reinterpret_cast</span>&lt;SAMPLETYPE *&gt;(<span class="keyword">this</span>-&gt;out_pcm_buffer),</span><br><span class="line">                                                 <span class="keyword">this</span>-&gt;mBufSize / <span class="number">4</span>);</span><br><span class="line">                pthread_mutex_unlock(&amp;mutexSpeed);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                soundTouch-&gt;<span class="built_in">flush</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            finished = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="seek-指定在某个时间段播放"><a href="#seek-指定在某个时间段播放" class="headerlink" title="seek 指定在某个时间段播放"></a>seek 指定在某个时间段播放</h3><p>seek 功能直接调取的 FFmpeg API ，操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseDecodec::seek</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (number &gt;= <span class="number">0</span> &amp;&amp; number &lt;= number) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> rel = number * AV_TIME_BASE;</span><br><span class="line">        avcodec_flush_buffers(<span class="keyword">this</span>-&gt;avCodecContext);</span><br><span class="line">        avformat_seek_file(<span class="keyword">this</span>-&gt;avFormatContext, <span class="number">-1</span>, INT64_MIN, rel, INT64_MAX, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="截取-PCM"><a href="#截取-PCM" class="headerlink" title="截取 PCM"></a>截取 PCM</h3><p>截取 PCM 原理其实很简单，比如一段音频的总长为  500s ，我想要截取 300 - 400s 部分，那么我首先 seek(300)作为起点，如果解码帧的时间到了 500 那么就直接退出就 OK 了，是不是很简单。</p>
<p>这里我说下怎么获取时间:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是基本的时间单位（以秒为单位）表示其中的帧时间戳。</span></span><br><span class="line"><span class="keyword">this</span>-&gt;time_base = (*pFormatCtx)-&gt;streams[i]-&gt;time_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 初始化 FFmpeg 读取流 header 信息可以获取</span></span><br><span class="line"><span class="keyword">int</span> audioDuration = (*pFormatCtx)-&gt;streams[i]-&gt;duration / AV_TIME_BASE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 读取待解码 AVPacket 包获取时间</span></span><br><span class="line"><span class="keyword">int</span> readCurAudioTime = avPacket-&gt;pts * av_q2d(time_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 解码获取时间</span></span><br><span class="line"><span class="keyword">int</span> decodeAudioCurTime = avFrame-&gt;pts * av_q2d(time_base);</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我们的音频处理库就讲解完了，对于音视频感兴趣的可以作为学习资料，因为我本人不喜欢弄 UI ，不然我可以仿照一个 网易云音乐的 UI + 我自己的音频处理库来做一个音频 APP 。当然你可以这样来搞。</p>
<p>文章中所有的代码已上传 <a href="https://github.com/yangkun19921001/AudioManager">GitHub</a></p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><ul>
<li>Email: <a href="mailto:yang1001yk@gmail.com">yang1001yk@gmail.com</a></li>
<li>个人博客: <a href="https://www.devyk.top">https://www.devyk.top</a></li>
<li>GitHub: <a href="https://github.com/yangkun19921001">https://github.com/yangkun19921001</a></li>
<li>掘金博客: <a href="https://juejin.im/user/578259398ac2470061f3a3fb">https://juejin.im/user/578259398ac2470061f3a3fb/posts</a></li>
</ul>
<p><strong>扫码关注我的公众号，让我们离得更近一些!</strong></p>
<p><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200315232530.jpg" alt=""></p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">音视频学习路线</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200604150710.jpeg" alt="支付宝"></span></a><a class="button donate" href="/" style="background-color:rgba(255,128,62,.87);border-color:transparent;color:white;" target="_blank" rel="noopener"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button is-danger donate" href="/" target="_blank" rel="noopener"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200604150835.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/04/Android-%E5%8D%81%E4%B8%80-Android-%E7%AB%AF-rtmp-%E6%8E%A8%E6%B5%81/"><span class="level-item">音视频学习 (十一) Android 端 rtmp 推流</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "j16d0HiTJvVWRQzjQN625f4W-gzGzoHsz",
            appKey: "7cgla0UfvddS9PjRz7Lcvqn7",
            placeholder: "请遵守中华人民共和国法律法规。填写邮箱信息以接收回复。",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200427113132.jpeg" alt="DevYK"></figure><p class="title is-size-4 is-block line-height-inherit">DevYK</p><p class="is-size-6 is-block">Android/NDK/音视频/跨平台</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>BeiJing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yangkun19921001" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yangkun19921001"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="http://wpa.qq.com/msgrd?v=1&amp;uin=919079498&amp;site=ioshenmue&amp;menu=yes"><i class="fab fa-qq"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/"><span class="level-start"><span class="level-item">专题</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/"><span class="level-start"><span class="level-item">音视频</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="level-start"><span class="level-item">服务器</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"><span class="tag">音视频学习路线</span><span class="tag is-grey-lightest">12</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:26:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%BA%8C-FFmpeg-OpenSL-ES-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/">音视频学习 (十二) FFmpeg + OpenSL ES 实现音频播放器</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:24:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/Android-%E5%8D%81%E4%B8%80-Android-%E7%AB%AF-rtmp-%E6%8E%A8%E6%B5%81/">音视频学习 (十一) Android 端 rtmp 推流</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:22:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81-%E5%9F%BA%E4%BA%8E-Nginx-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/">音视频学习 (十) 基于 Nginx 搭建直播服务器</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a> / <a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/">nginx</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:21:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B9%9D-FFmpeg-librtmp-%E5%AE%9E%E7%8E%B0%E6%8B%89%E6%B5%81%E6%92%AD%E6%94%BE%E5%99%A8/">音视频学习 (九) FFmpeg + librtmp 实现拉流播放器</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-04T10:13:00.000Z">2020-06-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/">音视频学习 (八) 视频渲染</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/">专题</a> / <a class="link-muted" href="/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="DevYK 个人博客" height="28"></a><p class="size-small"><span>&copy; 2020 DevYK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>