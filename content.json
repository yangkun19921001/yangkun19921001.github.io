{"pages":[{"title":"","text":"title: 404date: 2020-06-03 11:53:32type: “404”layout: “404”description: “Oops～，我崩溃了！找不到你想要的页面 :(“","link":"/404.html"}],"posts":[{"title":"README","text":"联系我 手机/微信: 15810618744 Email: yang1001yk@gmail.com 个人博客: https://www.devyk.top GitHub: https://github.com/yangkun19921001 掘金博客: https://juejin.im/user/578259398ac2470061f3a3fb/posts 扫码关注我的公众号，让我们离得更近一些!","link":"/2020/06/05/about/"},{"title":"webrtc 学习 (一) 搭建 AppRTC 服务","text":"前言最近折腾了几天 apprtc 服务器搭建，搭建的主要目的是为了学习 Android 、WEB 等各端基于 webrtc 音视频通信。 经过这几天的搭建得出了几点结论: 1、非 https 协议在 chrome 浏览器不支持打开音视频设备。 2、如果想要使各端都能通信，那么必须所有请求访问都使用 https 协议，证书可以在购买服务器平台上免费申请。 如果你正在找工作, 那么你需要一份 Android 高级开发面试宝典 以下是最终效果图(手机跟 WEB 互通需要所有 http 更换为 https 协议，该篇最终结果还未达到各端互通的条件，后续会更新补上) 搭建环境 服务器: 腾讯云 系统: centos app2app web2web 介绍搭建 apprtc 需要用到以下几个服务。 apprtcAppRTC 是用来创建和管理通话状态的房间服务器。 coturncoturn 是一种 TURN 内网穿透服务器（也就是中转服务器），该服务器用于 VOIP 或通用数据流的 NAT 穿越和数据转发。 collidercollider 它是用 go 语言实现的基于 WebSocket 的信令服务器。 为了建立一个 webrtc 的通信过程，一般是需要有如下通信信息: 1、会话控制信息，用来开始和结束通话，即开始视频、结束视频这些操作指令。 2、发生错误时用来相互通告的消息 3、元数据，如各自的音视频解码方式、带宽。 4、网络数据，对方的公网 IP、端口、内网 IP 及端口。 搭建 AppRTC 服务的基本步骤1、搭建 AppRTC 房间服务器 2、搭建 Coturn 穿透服务器 3、搭建 Collider 信令服务器 4、搭建 ICE 信息服务器 如何搭建 AppRTC1、install JDK1234yum install java-1.8.0-openjdk#查看 Java 版本java -version 2、install node.js123456789curl -sL https://rpm.nodesource.com/setup_10.x | bash -yum install -y nodejs# 确认是否成功node --versionnpm --version# 构建 apprtc 用到npm -g install grunt-cligrunt --version 3、安装Python和Python-webtest （python2.7）123yum -y install epel-releaseyum install python python-webtest python-pippip install --upgrade pip 4、安装google_appengine1234567891011wget https://storage.googleapis.com/appengine-sdks/featured/google_appengine_1.9.40.zipunzip google_appengine_1.9.40.zip#配置环境变量：在/etc/profile文件最后增加一行：vim /etc/profile#添加如下代码export google_appengine_path=/root/webrtc/google_appengineexport PATH=$PATH:$google_appengine_path#最后保存，使之生效source /etc/profile 5、安装 go12345678910yum install golang#查看是否安装成功go version #创建go工作目录mkdir -p /root/webrtc/goWorkspace/src#配置环境变量：在 vim /etc/profile 文件最后增加一行：export GOPATH=/root/webrtc/goWorkspace#保存source /etc/profile 6、安装libevent1234567#当前目录:root/webrtc/#https://github.com/coturn/coturn/wiki/CoturnConfigwget https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gztar xvf libevent-2.0.21-stable.tar.gzcd libevent-2.0.21-stable./configuremake install 7、安装 AppRTC1234567891011121314151617181920212223242526272829#当前目录:root/webrtc/git clone https://github.com/webrtc/apprtc.git#将collider的源码软连接到go的工作目录下ln -s /root/webrtc/apprtc/src/collider/collider $GOPATH/srcln -s /root/webrtc/apprtc/src/collider/collidermain $GOPATH/srcln -s /root/webrtc/apprtc/src/collider/collidertest $GOPATH/src#编译collidermaingo get collidermaingo install collidermain#go get collidermain: 被墙#报错: package golang.org/x/net/websocket: unrecognized import path \"golang.org/x/net/websocket\"#执行: #mkdir -p $GOPATH/src/golang.org/x/#cd $GOPATH/src/golang.org/x/#git clone https://github.com/golang/net.git net #go install net#再执行编译collidermain#修改房间服务器为我们前面的房间服务器:vim $GOPATH/src/collidermain/main.govar roomSrv = flag.String(“room-server”, “https://49.235.159.44:8080”, “The origin of the room server”)vim $GOPATH/src/collider/collider.go#修改放入自己私有证书,目前这里放入腾讯云申请的 证书测试 app -&gt; pc 通不了，固还是用自签名e = server.ListenAndServeTLS(“/root/key/chat.codecocoa.com.pem”, “/root/key/chat.codecocoa.com.key”)go get collidermaingo install collidermain 8、安装coturn123456789#目录:root/webrtc/#https://github.com/coturn/coturn/wiki/Downloadswget http://coturn.net/turnserver/v4.5.0.7/turnserver-4.5.0.7.tar.gztar xvfz turnserver-4.5.0.7.tar.gzcd turnserver-4.5.0.7#如果没有 openssl-devel 需要安装yum install openssl-devel./configure --prefix=./binmake install 9、配置并运行 coturn Nat 穿透服务器12345#内网：172.17.0.11 ：DevYk:用户 12345 密码 &amp; ctr+c 不会停止nohup turnserver -L 172.17.0.11 -a -u DevYK:12345 -v -f -r nort.gov &amp;#或者 作者用的该方案nohup turnserver -L 172.17.0.11 -a -u DevYK:12345 -v -f -r www.devyk.cn &amp; #netstat -ntulp 查看 5766，3478 端口是否启动 10、collider 信令服务器配置防火墙，允许访问8089端口（tcp，用于客户端和collider建立websocket信令通信） 1234567891011121314#创建自签名的数字证书#如果没有openssl,需要安装mkdir -p /certcd /cert# CA私钥openssl genrsa -out key.pem 2048 # 自签名证书openssl req -new -x509 -key key.pem -out cert.pem -days 1095#app 与 app 通信由于 ssl 问题需要将 tls =falsenohup $GOPATH/bin/collidermain -port=8089 -tls=true -room-server=\"https://49.235.159.44:8080\" &gt; /root/webrtc/collidermain.log 2&gt;&amp;1 &amp;#检查 8089 端口是否启动netstat -ntulp 11. apprtc 房间服务器配置防火墙，允许访问8080端口（tcp，此端口用于web访问） 配置文件修改（主要是配置apprtc对应的conturn和collider相关参数） 12#49.235.159.44 外网ipvim /root/webrtc/apprtc/src/app_engine/constants.py 1234567891011121314151617181920212223242526272829303132333435363738394041#ICE_SERVER_OVERRIDE = None# Enable by uncomment below and comment out above, then specify turn and stunICE_SERVER_OVERRIDE = [ { \"urls\": [ \"turn:49.235.159.44:3478?transport=udp\", \"turn:49.235.159.44:3478?transport=tcp\" ], \"username\": \"DevYK\", \"credential\": \"12345\" }, { \"urls\": [ \"stun:49.235.159.44:8089\" ] } ]#ICE_SERVER_OVERRIDE = None#pc 必须使用 https#ICE_SERVER_BASE_URL = 'https://49.235.159.44'#在 APP 上因为没有 SSL 证书，那么只能用 httpICE_SERVER_BASE_URL = 'http://49.235.159.44:8088'ICE_SERVER_URL_TEMPLATE = '%s/v1alpha/iceconfig?key=%s'ICE_SERVER_API_KEY = os.environ.get('ICE_SERVER_API_KEY')# Dictionary keys in the collider instance info constant.WSS_INSTANCE_HOST_KEY = '49.235.159.44:8089'WSS_INSTANCE_NAME_KEY = 'vm_name'WSS_INSTANCE_ZONE_KEY = 'zone'WSS_INSTANCES = [{ WSS_INSTANCE_HOST_KEY: '49.235.159.44:8089', WSS_INSTANCE_NAME_KEY: 'wsserver-std', WSS_INSTANCE_ZONE_KEY: 'us-central1-a'}#,{# WSS_INSTANCE_HOST_KEY: '49.235.159.44:8089',# WSS_INSTANCE_NAME_KEY: 'wsserver-std-2',# WSS_INSTANCE_ZONE_KEY: 'us-central1-f'#}] 12345678910111213#编译cd /root/webrtc/apprtcnpm installgrunt build#如果出现下面错误,使用 cnpm 编译/root/webrtc/apprtc/node_modules/mkdirp/lib/opts-arg.js ...#npm 安装出现问题 使用 cnpm 安装npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm installgrunt build 启动: 123456#172.31.247.136 : 内网ipnohup dev_appserver.py --host=172.17.0.11 --port 8080 /root/webrtc/apprtc/out/app_engine --skip_sdk_update_check &gt; /root/webrtc/apprtc.log 2&gt;&amp;1 &amp;#检查 8080 Python 是否起来netstat -ntulp 12、 配置 ICE Servicemkdir /root/webrtc/iceService vim ice.js 123456789101112131415161718192021222324252627var http = require('http');var crypto = require('crypto')var hmac = function(key, content) { var method = crypto.createHmac('sha1', key) method.setEncoding('base64') method.write(content) method.end() return method.read()}http.createServer(function(request, response) { //账户 var timestamp = Math.floor(Date.now() / 1000) var turn_username = timestamp + ':DevYK' //密码 var key = '12345' var password = hmac(key, turn_username) // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); console.log(turn_username); console.log(password); // 发送响应数据 \"ice服务器\" response.end('{\"iceServers\":[{\"username\":\"'+turn_username+'\",\"credential\":\"'+password+'\",\"urls\":[\"stun:49.235.159.44:3478\",\"turn:49.235.159.44:3478\"]}]}\\n'); }).listen(8088); // 终端打印如下信息 console.log('ICE Server running'); 启动 ICE REST API 服务 1234nohup node ice.js &amp;#检查 8088 服务是否启动netstat -ntulp 13、nginx 设置反向代理nginx 已存在进行配置11.1 配置反向代理 1234567891011121314151617181920212223242526272829303132333435363738394041events { worker_connections 1024; } http{ #apprtc 服务 upstream roomserver { server 49.235.159.44:8080; } server { listen 80; server_name 49.235.159.44; return 301 https://$server_name$request_uri; } server { root /root/webrtc/nginx-1.17.8/html; index index.php index.html index.htm; listen 443 ssl; #腾讯云证书 #ssl_certificate /root/ssl/1_www.devyk.cn_bundle.crt; #ssl_certificate_key /root/ssl/2_www.devyk.cn.key; #ssl_session_timeout 5m; #请按照以下协议配置 #ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 #ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #ssl_prefer_server_ciphers on; #自签名 ssl_certificate /cert/cert.pem; ssl_certificate_key /cert/key.pem; server_name 49.235.159.44; location / { proxy_pass http://roomserver$request_uri; proxy_set_header Host $host; } location ~ .php$ { fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; include fastcgi_params; } }} 11.1.1已安装但是没有配置 ssl 123#开启 nginx 服务 errornginx: [emerg] the \"ssl\" parameter requires ngx_http_ssl_module in /bin/conf/nginx.conf 解决: 1234567#切换到源码包：cd /nginx/nginx-1.17.9#查看nginx原有的模块/bin/sbin/nginx -V#在configure arguments:后面显示的原有的configure参数如下：--prefix=./bin 重新编译, 加入 --with-http_ssl_module 1234./configure --prefix=./bin --with-http_ssl_module#编译make ps: 这里千万别 make install 覆盖安装，因为之前还有 nginx 配置。 将之前的 nginx rm 替换为 objs/nginx 12345#在 nginx/1.17 模块下rm -rf bin/sbin/nginxcp objs/nginx bin/sbin/ 最后重启服务 1234#启动bin/sbin/nginx#重启bin/sbin/nginx -s reload nginx 未安装配置11.2 下载 nginx 12wget http://nginx.org/download/nginx-1.17.9.tar.gztar -zxvf nginx-1.17.9.tar.gz 11.2.1编译 nginx 123./configure --prefix=./bin --with-http_ssl_modulemake install 11.2.2 配置 nginx.conf 1vim /root/webrtc/nginx-1.17.8/bin/conf/nginx.conf 1234567891011121314151617181920212223242526272829303132333435#apprtc 服务 events { worker_connections 1024; } http{ upstream roomserver { server 49.235.159.44:8080; } server { listen 80; server_name www.devyk.cn; return 301 https://$server_name$request_uri; } server { root /root/nginx/nginx-1.17.8/html; index index.php index.html index.htm; listen 443 ssl; #腾讯云证书 #ssl_certificate /root/nginx/nginx-1.17.8-http-rtmp/ssl/rtc.crt; #ssl_certificate_key /root/nginx/nginx-1.17.8-http-rtmp/ssl/rtc.key; #自签名证书 ssl_certificate /cert/cert.pem; ssl_certificate_key /cert/key.pem; server_name 49.235.159.44; location / { proxy_pass http://roomserver$request_uri; proxy_set_header Host $host; } location ~ .php$ { fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; include fastcgi_params; } } } 11.2.3 启动 nginx 1234#启动bin/sbin/nginx#重启bin/sbin/nginx -s reload 搭建中遇见的问题 浏览器通话跨域问题 :pushState 123vim /root/webrtc/apprtc/out/app_engine/js/apprtc.debug.js#全局搜索 pushState 增加:roomLink=roomLink.substring(\"http\",\"https\"); Websocket open error： 123Messages: WebSocket open error: WebSocket error.WebSocket register error: WebSocket error. PC 上如果遇见这个问题，一般需要检查 apprtc 、 constants.py 、签名的配置信息。 自签名证书只能在浏览器上使用，不能用于浏览器与 Android 等端进行通信。 总结整个服务搭建下来，坑确实太多了。目前由于没有证书，所以只能用于 app2app 、web2web 测试了，等证书申请下来在来更新替换过程。 以上搭建只要按照文中步骤肯定是可以成功的，希望可以帮助到你。 参考 https://zhuanlan.zhihu.com/p/91289458 AppRTC(WebRTC)服务器搭建 关于我 Email: yang1001yk@gmail.com 个人博客: https://www.devyk.top GitHub: https://github.com/yangkun19921001 掘金博客: https://juejin.im/user/578259398ac2470061f3a3fb/posts 扫码关注我的公众号，让我们离得更进一些!","link":"/2020/06/04/webrtc-%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E6%90%AD%E5%BB%BA-AppRTC-%E6%9C%8D%E5%8A%A1/"},{"title":"必看的性能优化总结","text":"前言如果你已经有 2 - 3 年以上开发经验还不懂的怎么去优化自己的项目，那就有点说不过去了，下面是我自己总结的一套入门级别的 Android 性能优化。如果图片不清晰文末可以下载原始 xmind 图。 如果你正在找工作, 那么你需要一份 Android 高级开发面试宝典 1、 你对 APP 的启动有过研究吗? 有做过相关的启动优化吗?程序员: 之前做热修复的时候研究过 Application 的启动原理。项目中也做过一些启动优化。 面试官: 哦，你之前研究过热修复? (这个时候有可能就会深入的问问热修复的原理，这里咱们就不讨论热修复原理) 那你说说对启动方面都做了哪些优化? 程序员: 我发现程序在冷启动的时候，会有 1s 左右的白屏闪现，低版本是黑屏的现象，在这期间我通过翻阅系统主题源码，发现了系统 AppTheme 设置了一个 windowBackground ，由此推断就是这个属性捣的鬼，开始我是通过设置 windowIsTranslucent 透明属性，发现虽然没有了白屏，但是中间还是有一小段不可见，这个用户体验还是不好的。最后我观察了市面上大部分的 Android 软件在冷启动的时候都会有一个 Splash 的广告页，同时在增加一个倒数的计时器，最后才进入到登录页面或者主页面。我最后也是这样做的，原因是这样做的好处可以让用户先基于广告对本 APP 有一个基本认识，而且在倒数的时候也预留给咱们一些对插件和一些必须或者耗时的初始化做一些准备。 Ps：这里会让面试官感觉你是一个注重用户体验的 通过翻阅 Application 启动的源码，当我们点击桌面图标进入我们软件应用的时候，会由 AMS 通过 Socket 给 Zygote 发送一个 fork 子进程的消息，当 Zygote fork 子进程完成之后会通过反射启动 ActivityThread##main 函数，最后又由 AMS 通过 aidl 告诉 ActivityThread##H 来反射启动创建Application 实例，并且依次执行 attachBaseContext 、onCreate 生命周期，由此可见我们不能在这 2 个生命周期里做主线程耗时操作。 Ps: 这里会让面试官感觉你对 App 应用的启动流程研究的比较深，有过真实的翻阅底层源码，而并不是背诵答案。 知道了 attachBaseContext 、onCreate 在应用中最先启动，那么我们就可以通过 TreceView 等性能检测工具，来检测具体函数耗时时间，然后来对其做具体的优化。 项目不及时需要的代码通过异步加载。 将对一些使用率不高的初始化，做懒加载。 将对一些耗时任务通过开启一个 IntentService来处理。 还通过 redex 重排列 class 文件，将启动阶段需要用到的文件在 APK 文件中排布在一起，尽可能的利用 Linux 文件系统的 pagecache 机制，用最少的磁盘 IO 次数，读取尽可能多的启动阶段需要的文件，减少 IO 开销，从而达到提升启动性能的目的。 通过抖音发布的文章知晓在 5.0 低版本可以做 MultiDex 优化，在第一次启动的时候，直接加载没有经过 OPT 优化的原始 DEX，先使得 APP 能够正常启动。然后在后台启动一个单独进程，慢慢地做完 DEX 的 OPT 工作，尽可能避免影响到前台 APP 的正常使用。 Ps：1. 面试官这里会觉得你对启动优化确实了解的不错，有一定的启动优化经验。 在第五点面试官会觉得你比较关注该圈子的动态，发现好的解决方案，并能用在自己项目上。这一点是加分项! Application 启动完之后，AMS 会找出前台栈顶待启动的 Activity , 最后也是通过 AIDL 通知 ActivityThread#H 来进行对 Activity 的实例化并依次执行生命周期 onCreate、onStart、onRemuse 函数，那么这里由于 onCreate 生命周期中如果调用了 setContentView 函数，底层就会通过将 XML2View 那么这个过程肯定是耗时的。所以要精简 XML 布局代码，尽可能的使用 ViewStub、include 、merge 标签来优化布局。接着在 onResume 声明周期中会请求 JNI 接收 Vsync (垂直同步刷新的信号) 请求，16ms 之后如果接收到了刷新的消息，那么就会对 DecorView 进行 onMeasure-&gt;onLayout-&gt;onDraw 绘制。最后才是将 Activity 的根布局 DecorView 添加到 Window 并交于 SurfaceFlinger 显示。 所以这一步除了要精简 XML 布局，还有对自定义 View 的测量，布局，绘制等函数不能有耗时和导致 GC 的操作。最后也可以通过 TreaceView 工具来检测这三个声明周期耗时时间，从而进一步优化，达到极限。 这一步给面试官的感觉你对整个 Activity 的启动和 View 的绘制还有刷新机制都有深入的研究，那么此刻你肯定给面试官留了一个好印象，说明你平时对这些源码级别的研究比较广泛，透彻。 总结: 最后我基于以上的优化减少了 50% 启动时间。 面试官: 嗯，研究的挺深的，源码平时不少看吧。 程序员: 到这里，我知道这一关算是过了! 2、有做过相关的内存优化吗?程序员: 有做过，目前的项目内存优化还是挺多的，要不我先说一下优化内存有什么好处吧？咱们不能盲目的去优化！ 有的时候对于自己熟悉的领域，一定要主动出击，自己主导这场面试。 面试官: 可以。 Ps：这里大多数面试官会同意你的请求，除非遇见装B的。 程序员: 好处: 减少 OOM ，可以提高程序的稳定性。 减少卡顿，提高应用流畅性。 减少内存占用，提高应用后台存活性。 减少程序异常，降低应用 Crash 率, 提高稳定性。 那么我基于这四点，我的程序做了如下优化: 1.减少 OOM 在应用开发阶段我比较喜欢用 LeakCanary 这款性能检测工具，好处是它能实时的告诉我具体哪个类发现了内存泄漏(如果你对 LeakCanary 的原理了解的话，可以说一说它是怎么检测的)。 还有我们要明白为什么应用程序会发送 OOM ，又该怎么去避免它？ 发生 OOM 的场景是当申请 1M 的内存空间时，如果你要往该内存空间存入 2M 的数据，那么此时就会发生 OOM。 在应用程序中我们不仅要避免直接导致 OOM 的场景还要避免间接导致 OOM 的场景。间接的话也就是要避免内存泄漏的场景。 内存泄漏的场景是这个对象不再使用时，应用完整的执行最后的生命周期，但是由于某些原因，对象虽然已经不再使用，仍然会在内存中存在而导致 GC 不会去回收它，这就意味着发生了内存泄漏。(这里可以介绍下 GC 回收机制，回收算法，知识点尽量往外扩展而不脱离本题) 最后在说一下在实际开发中避免内存泄漏的场景: 资源型对象未关闭: Cursor,File 注册对象未销毁: 广播，回调监听 类的静态变量持有大数据对象 非静态内部类的静态实例 Handler 临时性内存泄漏: 使用静态 + 弱引用，退出即销毁 容器中的对象没清理造成的内存泄漏 WebView: 使用单独进程 其实这些都是基础，把它记下就行了。记得多了在实际开发中就有印象了。 2.减少卡顿 怎么减少卡顿? 那么我们可以从 2 个原理方面来探讨卡顿的根本原因，第一个原理方面是绘制原理，另一个就是刷新原理。 绘制原理: 刷新原理: View 的 requestLayout 和 ViewRootImpl##setView 最终都会调用 ViewRootImpl 的 requestLayout 方法，然后通过 scheduleTraversals 方法向 Choreographer 提交一个绘制任务，然后再通过 DisplayEventReceiver 向底层请求 vsync 垂直同步信号，当 vsync 信号来的时候，会通过 JNI 回调回来，在通过 Handler 往消息队列 post 一个异步任务，最终是 ViewRootImpl 去执行绘制任务，最后调用 performTraversals 方法，完成绘制。 详细流程可以参考下面流程图: 卡顿的根本原因: 从刷新原理来看卡顿的根本原理是有两个地方会造成掉帧: 一个是主线程有其它耗时操作，导致doFrame 没有机会在 vsync 信号发出之后 16 毫秒内调用； 还有一个就是当前doFrame方法耗时，绘制太久，下一个 vsync 信号来的时候这一帧还没画完，造成掉帧。 既然我们知道了卡顿的根本原因，那么我们就可以监控卡顿，从而可以对卡顿优化做到极致。我们可以从下面三个方面来监控应用程序卡顿: 基于 Looper 的 Printer 分发消息的时间差值来判断是否卡顿。 12345678910111213141516171819202122232425262728293031323334//1. 开启监听 Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\"));//2. 只要分发消息那么就会在之前和之后分别打印消息public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; ... for (;;) { Message msg = queue.next(); // might block ... //分发之前打印 final Printer logging = me.mLogging; if (logging != null) { logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } ... try { //分发消息 msg.target.dispatchMessage(msg); ... //分发之后打印 if (logging != null) { logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); } } } 基于 Choreographer 回调函数 postFrameCallback 来监控 基于开源框架 BlockCanary 来监控 基于开源框架 rabbit-client 来监控 怎么避免卡顿： 一定要避免在主线程中做耗时任务，总结一下 Android 中主线程的场景: UI 生命周期的控制 系统事件的处理 消息处理 界面布局 界面绘制 界面刷新 … 还有一个最重要的就是避免内存抖动，不要在短时间内频繁的内存分配和释放。 基于这几点去说卡顿肯定是没有问题的。 3.减少内存占用 可以从如下几个方面去展开说明: AutoBoxing(自动装箱): 能用小的坚决不用大的。 内存复用 使用最优的数据类型 枚举类型: 使用注解枚举限制替换 Enum 图片内存优化（这里可以从 Glide 等开源框架去说下它们是怎么设计的） 选择合适的位图格式 bitmap 内存复用，压缩 图片的多级缓存 基本数据类型如果不用修改的建议全部写成 static final,因为 它不需要进行初始化工作，直接打包到 dex 就可以直接使用，并不会在 类 中进行申请内存 字符串拼接别用 +=，使用 StringBuffer 或 StringBuilder 不要在 onMeause, onLayout, onDraw 中去刷新 UI 尽量使用 C++ 代码转换 YUV 格式，别用 Java 代码转换 RGB 等格式，真的很占用内存 4.减少程序异常 减少程序异常那么我们可以从稳定性和 Crash 来分别说明。 这个我们将在第四点会详细的介绍程序的稳定性和 Crash 。 如果说出这些，再实际开发中举例说明一下怎么解决的应该是没有问题的。 3、你在项目中有没有遇见卡顿问题？是怎么排查卡顿？又是怎么优化的?程序员: 有遇见, 比如在主线程中做耗时操作、频繁的创建对象和销毁对象导致 GC 回收频繁、布局的层级多等。 面试官: 嗯，那具体说说是怎么优化的。 程序员: 这里我们还是可以从显示原理和优化建议来展开说明，参考如下: 显示原理: 绘制原理: 刷新原理: View 的 requestLayout 和 ViewRootImpl##setView 最终都会调用 ViewRootImpl 的 requestLayout 方法，然后通过 scheduleTraversals 方法向 Choreographer 提交一个绘制任务，然后再通过 DisplayEventReceiver 向底层请求 vsync 垂直同步信号，当 vsync 信号来的时候，会通过 JNI 回调回来，在通过 Handler 往消息队列 post 一个异步任务，最终是 ViewRootImpl 去执行绘制任务，最后调用 performTraversals 方法，完成绘制。 详细流程可以参考下面流程图: 卡顿的根本原因: 从刷新原理来看卡顿的根本原理是有两个地方会造成掉帧: 一个是主线程有其它耗时操作，导致doFrame 没有机会在 vsync 信号发出之后 16 毫秒内调用； 还有一个就是当前 doFrame 方法耗时，绘制太久，下一个 vsync 信号来的时候这一帧还没画完，造成掉帧。 既然我们知道了卡顿的根本原因，那么我们就可以监控卡顿，从而可以对卡顿优化做到极致。我们可以从下面三个方面来监控应用程序卡顿: 基于 Looper 的 Printer 分发消息的时间差值来判断是否卡顿。 12345678910111213141516171819202122232425262728293031323334//1. 开启监听 Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\"));//2. 只要分发消息那么就会在之前和之后分别打印消息public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; ... for (;;) { Message msg = queue.next(); // might block ... //分发之前打印 final Printer logging = me.mLogging; if (logging != null) { logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } ... try { //分发消息 msg.target.dispatchMessage(msg); ... //分发之后打印 if (logging != null) { logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); } } } 基于 Choreographer 回调函数 postFrameCallback 来监控 基于开源框架 BlockCanary 来监控 基于开源框架 rabbit-client 来监控 怎么可以提高程序运行流畅 1.布局优化: 1.1 布局优化分析工具: 1.2 优化方案: 提升动画性能 尽量别用补间动画，改为属性动画，因为通过性能监控发现补间动画重绘非常频繁 使用硬件加速提高渲染速度，实现平滑的动画效果。 怎么避免卡顿： 一定要避免在主线程中做耗时任务，总结一下 Android 中主线程的场景: UI 生命周期的控制 系统事件的处理 消息处理 界面布局 界面绘制 界面刷新 … 基于这几点去说卡顿肯定是没有问题的。 4、怎么保证 APP 的稳定运行?程序员: 保证程序的稳定我们可以从内存、代码质量、Crash、ANR、后台存活等知识点来展开优化。 面试官: 那你具体说说你是怎么做的？ 程序员: 1.内存 可以从第二点内存优化来说明 2.代码质量 团队之前相互代码审查，保证了代码的质量，也可以学习到了其它同事码代码的思想。 使用 Link 扫描代码，查看是否有缺陷性。 3. Crash 通过实现 Thread.UncaughtExceptionHandler 接口来全局监控异常状态，发生 Crash 及时上传日志给后台，并且及时通过插件包修复。 Native 线上通过 Bugly 框架实时监控程序异常状况，线下局域网使用 Google 开源的 breakpad 框架。发生异常就搜集日志上传服务器(这里要注意的是日志上传的性能问题，后面省电模块会说明) 4. ANR 5. 后台存活 面试官: 嗯，你对知识点掌握的挺好。 说完这些，这一关也算是过了。 5、说说你在项目中网络优化?程序员: 有，这一点其实可以通过 OKHTTP 连接池和 Http 缓存来说一下(当然这里不会再展开分析 OKHTTP 源码了) 面试官: 那你具体说一下吧 程序员 说了这些之后，再说一下你当前使用网络框架它们做了哪些优化比如 OKHTTP(Socket 连接池、Http缓存、责任链)、Retrofit(动态代理)。说了这些一般这关也算是过了。 6、你在项目中有用过哪些存储方式? 对它们的性能有过优化吗？程序员: 主要用过 sp,File,SQLite 存储方式。其中对 sp 和 sqlite 做了优化。 面试官: 那你说说都做了哪些优化? 程序员: 这一块如果你使用过其它第三方的数据库，可以说说它们的原理和它们存取的方式。 7、你在项目中有做过自定义 View 吗？有对它做过什么优化？程序员: 有做过。比如重复绘制，还有大图长图有过优化。 面试官: 那具体说一说 程序员: 最后也是结合真实场景具体说一个。 8、你们项目的耗电量怎么样? 有做过优化吗?程序员: 在没有优化之前持续工作 30 分钟的耗电量是 8%, 优化后是 4%。 面试官: 那你说一说你是怎么优化的。 程序员: 因为我们产品是一款社交通信的软件，有音视频通话、GPS 定位上报、长连接的场景，所以优化起来确实有点困难。不过最后也还是优化了一半的电量下去。主要做了如下优化: 说出这些之后，在结合项目一个真实的优化点来说明一下。 9、有做过日志优化吗?程序员: 有优化，在之前没有考虑任何性能的情况下，我是直接有 log 就写入文件，尽管我开了线程池去写文件，只要软件在运行那么就会频繁的使 CPU 进行工作。这也间接的导致了耗电。 面试官: 那你具体说一下，最后怎么解决这个问题的? 程序员: 展开上面这些点说明之后，面试官一般不会为难你。 10、你们 APK 有多大？有做过 APK 体积相关的优化吗?程序员: 有过优化，在没有优化之前项目的包体积大小是 80M,优化之后是 50M. 面试官: 说一说是怎么优化的 程序员: 基于这几点优化方案，一般都能解决 APK 体积问题。最后再把自己项目 APK 体积优化步骤结合上面点说一下就行。 总结其实性能优化点都是息息相关的，比如卡顿会涉及内存、显示，启动也会涉及 APK dex 的影响。所以说性能优化不仅仅是单方面的优化，一定要掌握最基本的优化方案，才能更加深入探讨性能原理问题。 在这里也建立大家多看流行开源框架源码，比如 Glide (内存方面), OKhttp (网络连接方面) 优化的真的很极致。到这里性能优化方面的知识也就说完了，下来一定好好去消化。 所有 xmind 原图点击获得","link":"/2020/06/05/%E5%BF%85%E7%9C%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"title":"性能优化 (一) 启动优化","text":"性能优化系列APP 启动优化 UI 绘制优化 内存优化 图片压缩 长图优化 电量优化 Dex 加解密 动态替换 Application APP 稳定性之热修复原理探索 APP 持续运行之进程保活实现 ProGuard 对代码和资源压缩 APK 极限压缩 简介性能优化的目的不是为了优化而优化，而且为了以后不再优化, 给自己统一 一个标准。 这里也许会有人问 APP 启动还需要优化吗？启动又不是我们自己写的代码，难道 Google 工程师会犯这么低级的错吗？其实这还真不是 Google 的错，应该说是给我们开发者留了一个坑吧。应该有的同学知道是怎么一回事儿了，当我们在系统桌面任意点击一个 APP 是不是会发现启动的时候有一瞬间有白屏出现(以前老版本是黑屏) 那么我们怎么来优化这个黑白屏的问题勒，现在我们先来了解一下 Android 手机重开机到启动 APP 的过程吧。 APP 启动流程这里会设计到 Android 系统源码的知识，但并不会深入解析源码，我们只是了解一个过程，因为太深入我自己也懵。 系统的启动我在这里大致分为了 6 个步骤，下面以流程图为准 启动步骤 首先拿到一部 Android 系统的手机打开电源，引导芯片代码加载引导程序 BootLoader 到 RAM 中去执行。 BootLoader 把操作系统拉起来。 Linux 内核启动开始系统设置，找到一个 init.rc 文件启动初始化进程。 init 进程初始化和启动属性服务，之后开启 Zygote 进程。 Zygote 开始创建 JVM 并注册 JNI 方法，开启 SystemServer。 启动 Binder 线程池和 SystemServiceManager,并启动各种服务。 Launcher 启动App Appcation 启动 手机回到系统桌面, 通过 adb shell dumpsys window w |findstr / |findstr name= 来查看当前的进程和 Activity 名。 当点击桌面 APP 图标的时候会走 Launcher . java 的 onClick (View view) 方法，详细见下图。 startActivity(intent) 会开启一个 APP 进程 AcitivityThread main() 调用执行流程，见下图。 最后 ActivityThread main() 是通过反射来进行初始化的 ActivityThread.java 做为入口，详细解说 main() 函数，还是以一个动画来演示一下吧; 根据上面的动画，大家应该已经明白 ActivityThread.java main() 方法中 Appcation onCreate() 的是怎么被调用起来的吧。 注意: 不知道大家有没有注意 ActivityThread main() 中 Looper.prepareMainLooper(); 其实咱们为什么能够在 Main Thread 中创建 Handler 不会报错了吧，是因为 Activity 启动的时候在这里已经默认开启了 Looper。 APP 启动黑白屏问题终于到了正题了，下面我们就来说下启动黑白屏的问题，还是先来看一个 GIF 吧。 市面上 APP 黑白屏 1从上面的一段录屏我们可以发现市面上常见的 APP 启动有的是白屏有的是做了优化。黑屏只有在 Android 4.n 具体是哪个版本我也忘了。那么现在我们就以我现在的真实项目来优化一下启动。 真实项目中优化简介首先为什么会造成白屏勒我们来看一段源码 最后就是这个 windowBackground 搞的鬼，知道了是这个搞的鬼那么我们就可以来进行优化了。 优化方案 一1在自己的 AppTheme 中加入 windowBackground 优化方案 二设置 windowbackgroud 为透明的 1&lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; 但是： 1这 2 中方法会有一个问题，就是所有的 Activity 启动都会显示。 优化方案 三 单独做成一个 AppTheme.Launcher 12345&lt;style name=\"AppTheme.Launcher\"&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt; &lt;!--&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;--&gt; &lt;item name=\"android:windowBackground\"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 在清单文件中 启动 Activity 加入该 主题 12345678910&lt;activity android:name=\"com.t01.android.dida_login.mvp.ui.activity.LoginActivity\" android:configChanges=\"keyboardHidden|orientation|screenSize\" android:theme=\"@style/AppTheme.Launcher\" android:windowSoftInputMode=\"adjustUnspecified|stateHidden\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在启动 Activity 页面中加入 1setTheme(R.style.AppTheme_Launcher); 最后这样做只有启动的 UI 才能见到自己的样式 最后效果，因为我这里没有背景图，故弄了一个主题颜色，如果想要设置一张背景图片可以参考下面的示例，不然有可能会引起图片拉伸效果。 我这里启动时间大概在 500 ms ~ 800 ms 左右。 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item&gt; &lt;bitmap android:src=\"@mipmap/app_bg\" android:gravity=\"fill\"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 最后在清单 启动 Activity 的 Theme 中修改为 1&lt;item name=\"android:windowBackground\"&gt;@drawable/app_theme_bg&lt;/item&gt; 据说 QQ 的实现方法是(这里只做参考，感兴趣的同学可以自己试试。) 12&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;&lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt; 启动时间查看4.4 以前版本查看1adb shell am start -W packName/activity 全路径 4.4 版本以后查看方式通过关键字 Displayed 并筛选为 No Filters 12019-04-25 18:35:57.629 508-629/? I/ActivityManager: Displayed com.lingyi.autiovideo.lykj/com.t01.android.dida_login.mvp.ui.activity.LoginActivity: +844ms 工具分析代码执行Appcation 中查看耗时通过（如果有的同学还用 Log 打印系统时间来相减来查看 耗时的话，看完我这篇文章就可以换成下面方法了，不然就有点 LOW 了哈）12345//开始计时Debug.startMethodTracing(filePath); 中间为需要统计执行时间的代码//停止计时Debug.stopMethodTracing(); 还是通过一组动画来看我怎么操作的吧。（注意这里的时间是 微妙 微妙/10^6 = s 应该是这样，忘了） 这个工具可以很友好的提示每个函数具体在内部执行了多少时间，卡顿其实也可以用这个方法来进行监测 导出 trace 文件命令 1adb pull /storage/emulated/0/appcation_launcher_time.trace 我这里耗时还不算太大 大概在 0.2 - 0.3 s 左右。 Appcation 中优化方案(并不绝对，优化思路差不多) 开子线程 线程中没有创建 Handler、没有操作 UI 、对异步要求不高 懒加载 用到的时候在初始化，如网络，数据库，图片库，或一些三方库。 使用 IntentService onHandleIntent () 方法来进行初始化一些比较耗时的操作 总结最后启动优化可以配合上面的 3 点优化方案 + Appcation 优化方案 = 你自己最优方案。","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%80-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"},{"title":"音视频学习 (十一) Android 端 rtmp 推流","text":"前言咱们回顾了前面 2 篇文章，主要讲解了如何搭建 rtmp 直播服务器，和如何开发一款具有拉流功能的 Android 播放器。那么现在有了播放端和直播服务器还缺少推流端。该篇文章我们就一起来实现 Android 端的 rtmp 推流，想要实现 Android 端推流必须要经过如下几个阶段，见下图: 该篇文章主要完成上图黄颜色功能部分，下面就开始进入正题，代码编写了。 项目效果推流监控 软编码 硬编码 文章末尾会介绍软硬编解码。 音频采集Android SDK 提供了两套音频采集的 API ,分别是 MediaRecorder 、AudioRecord 。前者是一个上层 API ,它可以直接对手机麦克风录入的音频数据进行编码压缩(如 AMR/MP3) 等，并存储为文件；后者则更接近底层，能够更加自由灵活地控制，其可以让开发者得到内存中的 PCM 原始音频数据流。如果想做一个简单的录音机，输出音频文件则推荐使用 MediaRecorder ； 如果需要对音频做进一步的算法处理，或者需要采用第三方的编码库进行编码，又或者需要用到网络传输等场景中，那么只能使用 AudioRecord 或者 OpenSL ES ，其实 MediaRecorder 底层也是调用了 AudioRecord 与 Android Framework 层的 AudioFlinger 进行交互的。而我们该篇的场景更倾向于第二种实现方式，即使用 AudioRecord 来采集音频。 如果想要使用 AudioRecord 这个 API ,则需要在应用 AndroidManifest.xml 的配置文件中进行如下配置: 1&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\"&gt;&lt;/uses-permission&gt; 当然，如果你想把采集到的 PCM 原始数据，存储 sdcard 中，还需要额外添加写入权限: 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 接下来了解一下 AudioRecord 的工作流程。 1. 初始化 AudioRecord首先来看一下 AudioRecord 的配置参数，AudioRecord 是通过构造函数来配置参数的，其函数原型如下: 1public AudioRecord(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat,int bufferSizeInBytes) 上述参数所代表的函数及其在各种场景下应该传递的值的含义参考如下说明: audioSource: 该参数指的是音频采集的输入源，可选值以常量的形式定义在类 AudioSource （MediaRecorder 中的一个内部类）中，常用的值包过: DEFAULT(默认) VOICE_RECOGNITION (用于语音识别，等同于默认) MIC (由手机麦克风输入) VOICE_COMMUNICATION (用于 VOIP 应用场景) sampleRateInHz: 用于指定以多大的采样频率来采集音频，现在用的最多的兼容最好是 44100 (44.1KHZ)采样频率。 channelConfig: 该参数用于指定录音器采集几个声道的声音，可选值以常量的形式定义在 AudioFormat 类中，常用的值包括: CHANNEL_IN_MONO 单声道 (移动设备上目前推荐使用) CHANNEL_IN_STEREO 立体声 audioFormat: 采样格式，以常量的形式定义在 AudioFormat 类中，常用的值包括: ENCODING_PCM_16BIT (16bit 兼容大部分 Android 手机) ENCODING_PCM_8BIT (8bit) bufferSizeInBytes: 配置内部音频缓冲区的大小(配置的缓存值越小，延时就越低)，而具体的大小，有可能在不同的手机上会有不同的值，那么可以使用如下 API 进行确定缓冲大小: 1AudioRecord.getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat); 配置好之后，检查一下 AudioRecord 当前的状态是否可以进行录制，可以通过 AudioRecord##getState 来获取当前的状态: STATE_UNINITIALIZED 还没有初始化，或者初始化失败了 STATE_INITIALIZED 已经初始化成功了。 2. 开启采集创建好 AudioRecord 之后，就可以开启音频数据的采集了，可以通过调用下面的函数进行控制麦克风的采集： 1mAudioRecord.startRecording(); 3. 提取数据执行完上一步之后，需要开启一个子线程用于不断的从 AudioRecord 缓冲区读取 PCM 数据，调用如下函数进行读取数据: 1int read(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes); 4. 停止采集如果想要停止采集，那么只需要调用 AudioRecord 的 stop 方法来实现，最后可以通过一个变量先控制子线程停止读取数据，然后在调用 stop 停止最后释放 AudioRecord 实例。 12345678910public void stopEncode() { //停止的变量标记 mStopFlag = true; if(mAudioEncoder != null) { //停止采集 mAudioEncoder.stop(); //释放内存 mAudioEncoder = null; }} 视频采集视频画面的采集主要是使用各个平台提供的摄像头 API 来实现的，在为摄像头设置了合适的参数之后，将摄像头实时采集的视频帧渲染到屏幕上提供给用户预览，然后将该视频帧传递给编码通道，进行编码。 1. 权限配置1&lt;uses-permission android:name=\"android.permission.CAMERA\"&gt;&lt;/uses-permission&gt; 2. 打开摄像头2.1 检查摄像头123456789public static void checkCameraService(Context context) throws CameraDisabledException { // Check if device policy has disabled the camera. DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService( Context.DEVICE_POLICY_SERVICE); if (dpm.getCameraDisabled(null)) { throw new CameraDisabledException(); }} 2.2 检查摄像头的个数检查完摄像头服务后，还需要检查手机上摄像头的个数，如果个数为 0，则说明手机上没有摄像头，这样的话也是不能进行后续操作的。 123456789101112131415161718192021222324public static List&lt;CameraData&gt; getAllCamerasData(boolean isBackFirst) { ArrayList&lt;CameraData&gt; cameraDatas = new ArrayList&lt;&gt;(); Camera.CameraInfo cameraInfo = new Camera.CameraInfo(); int numberOfCameras = Camera.getNumberOfCameras(); for (int i = 0; i &lt; numberOfCameras; i++) { Camera.getCameraInfo(i, cameraInfo); if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) { CameraData cameraData = new CameraData(i, CameraData.FACING_FRONT); if(isBackFirst) { cameraDatas.add(cameraData); } else { cameraDatas.add(0, cameraData); } } else if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) { CameraData cameraData = new CameraData(i, CameraData.FACING_BACK); if(isBackFirst) { cameraDatas.add(0, cameraData); } else { cameraDatas.add(cameraData); } } } return cameraDatas;} 在上面的方法中，需要传入一个是否先开启背面摄像头的 boolean 变量，如果变量为 true，则把背面摄像头放在列表第一个，之后打开摄像头的时候，直接获取列表中第一个摄像头相关参数，然后进行打开。这样的设计使得切换摄像头也变得十分简单，切换摄像头时，先关闭当前摄像头，然后变化摄像头列表中的顺序，然后再打开摄像头即可，也就是每次打开摄像头都打开摄像头列表中第一个摄像头参数所指向的摄像头。 2.3 打开摄像头打开摄像头之前，先从摄像头列表中获取第一个摄像头参数，之后根据参数中的 CameraId 来打开摄像头，打开成功后改变相关状态。相关代码如下： 1234567891011121314151617181920212223public synchronized Camera openCamera() throws CameraHardwareException, CameraNotSupportException { CameraData cameraData = mCameraDatas.get(0); if(mCameraDevice != null &amp;&amp; mCameraData == cameraData) { return mCameraDevice; } if (mCameraDevice != null) { releaseCamera(); } try { Log.d(TAG, \"open camera \" + cameraData.cameraID); mCameraDevice = Camera.open(cameraData.cameraID); } catch (RuntimeException e) { Log.e(TAG, \"fail to connect Camera\"); throw new CameraHardwareException(e); } if(mCameraDevice == null) { throw new CameraNotSupportException(); } mCameraData = cameraData; mState = State.OPENED; return mCameraDevice;} 上面需要注意的是，在 Android 提供的 Camera 源码中，Camera.open(cameraData.cameraID) 抛出异常则说明Camera 不可用，否则说明 Camera 可用，但是在一些手机上 Camera.open(cameraData.cameraID) 不是抛出异常，而是返回 null。 3. 配置摄像头参数在给摄像头设置参数后，需要记录这些参数，以方便其他地方使用。比如记录当前摄像头是否有闪光点，从而可以决定 UI 界面上是否显示打开闪光灯按钮。在直播项目中使用 CameraData 来记录这些参数，CameraData 类如下所示： 12345678910111213141516171819202122232425public class CameraData { public static final int FACING_FRONT = 1; public static final int FACING_BACK = 2; public int cameraID; //camera的id public int cameraFacing; //区分前后摄像头 public int cameraWidth; //camera的采集宽度 public int cameraHeight; //camera的采集高度 public boolean hasLight; //camera是否有闪光灯 public int orientation; //camera旋转角度 public boolean supportTouchFocus; //camera是否支持手动对焦 public boolean touchFocusMode; //camera是否处在自动对焦模式 public CameraData(int id, int facing, int width, int height){ cameraID = id; cameraFacing = facing; cameraWidth = width; cameraHeight = height; } public CameraData(int id, int facing) { cameraID = id; cameraFacing = facing; }} 给摄像头设置参数的时候，有一点需要注意：设置的参数不生效会抛出异常，因此需要每个参数单独设置，这样就避免一个参数不生效后抛出异常，导致之后所有的参数都没有设置。 4. 摄像头开启预览设置预览界面有两种方式：1、通过 SurfaceView 显示；2、通过 GLSurfaceView 显示。当为 SurfaceView 显示时，需要传给 Camera 这个 SurfaceView 的 SurfaceHolder。当使用 GLSurfaceView 显示时，需要使用Renderer 进行渲染，先通过 OpenGL 生成纹理，通过生成纹理的纹理 id 生成 SurfaceTexture ，将SurfaceTexture 交给 Camera ，那么在 Render 中便可以使用这个纹理进行相应的渲染，最后通过GLSurfaceView 显示。 4.1 设置预览回调123456789public static void setPreviewFormat(Camera camera, Camera.Parameters parameters) { //设置预览回调的图片格式 try { parameters.setPreviewFormat(ImageFormat.NV21); camera.setParameters(parameters); } catch (Exception e) { e.printStackTrace(); }} 当设置预览好预览回调的图片格式后，需要设置预览回调的 Callback。 12345678910Camera.PreviewCallback myCallback = new Camera.PreviewCallback() { @Override public void onPreviewFrame(byte[] data, Camera camera) { //得到相应的图片数据 //Do something }};public static void setPreviewCallback(Camera camera, Camera.PreviewCallback callback) { camera.setPreviewCallback(callback);} Android 推荐的 PreViewFormat 是 NV21，在 PreviewCallback 中会返回 Preview 的 N21 图片。如果是软编的话，由于 H264 支持 I420 的图片格式，因此需要将 N21格式转为 I420 格式，然后交给 x264 编码库。如果是硬编的话，由于 Android 硬编编码器支持 I420(COLOR_FormatYUV420Planar) 和NV12(COLOR_FormatYUV420SemiPlanar)，因此可以将 N21 的图片转为 I420 或者 NV12 ，然后交给硬编编码器。 4.2 设置预览图像大小在摄像头相关处理中，一个比较重要的是 屏幕显示大小和摄像头预览大小比例不一致 的处理。在 Android 中，摄像头有一系列的 PreviewSize，我们需要从中选出适合的 PreviewSize 。选择合适的摄像头 PreviewSize 的代码如下所示： 123456789101112131415161718192021222324252627282930313233public static Camera.Size getOptimalPreviewSize(Camera camera, int width, int height) { Camera.Size optimalSize = null; double minHeightDiff = Double.MAX_VALUE; double minWidthDiff = Double.MAX_VALUE; List&lt;Camera.Size&gt; sizes = camera.getParameters().getSupportedPreviewSizes(); if (sizes == null) return null; //找到宽度差距最小的 for(Camera.Size size:sizes){ if (Math.abs(size.width - width) &lt; minWidthDiff) { minWidthDiff = Math.abs(size.width - width); } } //在宽度差距最小的里面，找到高度差距最小的 for(Camera.Size size:sizes){ if(Math.abs(size.width - width) == minWidthDiff) { if(Math.abs(size.height - height) &lt; minHeightDiff) { optimalSize = size; minHeightDiff = Math.abs(size.height - height); } } } return optimalSize;}public static void setPreviewSize(Camera camera, Camera.Size size, Camera.Parameters parameters) { try { parameters.setPreviewSize(size.width, size.height); camera.setParameters(parameters); } catch (Exception e) { e.printStackTrace(); }} 在设置好最适合的 PreviewSize 之后，将 size 信息存储在 CameraData 中。当选择了 SurfaceView 显示的方式，可以将 SurfaceView 放置在一个 LinearLayout 中，然后根据摄像头 PreviewSize 的比例改变 SurfaceView 的大小，从而使得两者比例一致，确保图像正常。当选择了GLSurfaceView 显示的时候，可以通过裁剪纹理，使得纹理的大小比例和 GLSurfaceView 的大小比例保持一致，从而确保图像显示正常。 4.3 图像旋转在 Android 中摄像头出来的图像需要进行一定的旋转，然后才能交给屏幕显示，而且如果应用支持屏幕旋转的话，也需要根据旋转的状况实时调整摄像头的角度。在 Android 中旋转摄像头图像同样有两种方法，一是通过摄像头的 setDisplayOrientation(result) 方法，一是通过 OpenGL 的矩阵进行旋转。下面是通过setDisplayOrientation(result) 方法进行旋转的代码： 1234567891011121314151617181920212223242526public static int getDisplayRotation(Activity activity) { int rotation = activity.getWindowManager().getDefaultDisplay().getRotation(); switch (rotation) { case Surface.ROTATION_0: return 0; case Surface.ROTATION_90: return 90; case Surface.ROTATION_180: return 180; case Surface.ROTATION_270: return 270; } return 0;}public static void setCameraDisplayOrientation(Activity activity, int cameraId, Camera camera) { // See android.hardware.Camera.setCameraDisplayOrientation for // documentation. Camera.CameraInfo info = new Camera.CameraInfo(); Camera.getCameraInfo(cameraId, info); int degrees = getDisplayRotation(activity); int result; if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) { result = (info.orientation + degrees) % 360; result = (360 - result) % 360; // compensate the mirror } else { // back-facing result = (info.orientation - degrees + 360) % 360; } camera.setDisplayOrientation(result);} 4.4 设置预览帧率通过 Camera.Parameters 中 getSupportedPreviewFpsRange() 可以获得摄像头支持的帧率变化范围，从中选取合适的设置给摄像头即可。相关的代码如下： 12345678910111213141516171819202122public static void setCameraFps(Camera camera, int fps) { Camera.Parameters params = camera.getParameters(); int[] range = adaptPreviewFps(fps, params.getSupportedPreviewFpsRange()); params.setPreviewFpsRange(range[0], range[1]); camera.setParameters(params);}private static int[] adaptPreviewFps(int expectedFps, List&lt;int[]&gt; fpsRanges) { expectedFps *= 1000; int[] closestRange = fpsRanges.get(0); int measure = Math.abs(closestRange[0] - expectedFps) + Math.abs(closestRange[1] - expectedFps); for (int[] range : fpsRanges) { if (range[0] &lt;= expectedFps &amp;&amp; range[1] &gt;= expectedFps) { int curMeasure = Math.abs(range[0] - expectedFps) + Math.abs(range[1] - expectedFps); if (curMeasure &lt; measure) { closestRange = range; measure = curMeasure; } } } return closestRange;} 4.5 设置相机对焦一般摄像头对焦的方式有两种：手动对焦和触摸对焦。下面的代码分别是设置自动对焦和触摸对焦的模式： 12345678910111213141516171819202122232425262728293031public static void setAutoFocusMode(Camera camera) { try { Camera.Parameters parameters = camera.getParameters(); List&lt;String&gt; focusModes = parameters.getSupportedFocusModes(); if (focusModes.size() &gt; 0 &amp;&amp; focusModes.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) { parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE); camera.setParameters(parameters); } else if (focusModes.size() &gt; 0) { parameters.setFocusMode(focusModes.get(0)); camera.setParameters(parameters); } } catch (Exception e) { e.printStackTrace(); }}public static void setTouchFocusMode(Camera camera) { try { Camera.Parameters parameters = camera.getParameters(); List&lt;String&gt; focusModes = parameters.getSupportedFocusModes(); if (focusModes.size() &gt; 0 &amp;&amp; focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) { parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO); camera.setParameters(parameters); } else if (focusModes.size() &gt; 0) { parameters.setFocusMode(focusModes.get(0)); camera.setParameters(parameters); } } catch (Exception e) { e.printStackTrace(); }} 对于自动对焦这样设置后就完成了工作，但是对于触摸对焦则需要设置对应的对焦区域。要准确地设置对焦区域，有三个步骤：一、得到当前点击的坐标位置；二、通过点击的坐标位置转换到摄像头预览界面坐标系统上的坐标；三、根据坐标生成对焦区域并且设置给摄像头。整个摄像头预览界面定义了如下的坐标系统，对焦区域也需要对应到这个坐标系统中。 如果摄像机预览界面是通过 SurfaceView 显示的则比较简单，由于要确保不变形，会将 SurfaceView 进行拉伸，从而使得 SurfaceView 和预览图像大小比例一致，因此整个 SurfaceView 相当于预览界面，只需要得到当前点击点在整个 SurfaceView 上对应的坐标，然后转化为相应的对焦区域即可。如果摄像机预览界面是通过GLSurfaceView 显示的则要复杂一些，由于纹理需要进行裁剪，才能使得显示不变形，这样的话，我们要还原出整个预览界面的大小，然后通过当前点击的位置换算成预览界面坐标系统上的坐标，然后得到相应的对焦区域，然后设置给摄像机。当设置好对焦区域后，通过调用 Camera 的 autoFocus() 方法即可完成触摸对焦。整个过程代码量较多，请自行阅读项目源码。 4.6 设置缩放当检测到手势缩放的时候，我们往往希望摄像头也能进行相应的缩放，其实这个实现还是比较简单的。首先需要加入缩放的手势识别，当识别到缩放的手势的时候，根据缩放的大小来对摄像头进行缩放。代码如下所示： 123456789101112131415161718192021222324252627282930313233343536/** * Handles the pinch-to-zoom gesture */private class ZoomGestureListener extends ScaleGestureDetector.SimpleOnScaleGestureListener { @Override public boolean onScale(ScaleGestureDetector detector) { if (!mIsFocusing) { float progress = 0; if (detector.getScaleFactor() &gt; 1.0f) { progress = CameraHolder.instance().cameraZoom(true); } else if (detector.getScaleFactor() &lt; 1.0f) { progress = CameraHolder.instance().cameraZoom(false); } else { return false; } if(mZoomListener != null) { mZoomListener.onZoomProgress(progress); } } return true; }}public float cameraZoom(boolean isBig) { if(mState != State.PREVIEW || mCameraDevice == null || mCameraData == null) { return -1; } Camera.Parameters params = mCameraDevice.getParameters(); if(isBig) { params.setZoom(Math.min(params.getZoom() + 1, params.getMaxZoom())); } else { params.setZoom(Math.max(params.getZoom() - 1, 0)); } mCameraDevice.setParameters(params); return (float) params.getZoom()/params.getMaxZoom();} 4.7 闪光灯操作一个摄像头可能有相应的闪光灯，也可能没有，因此在使用闪光灯功能的时候先要确认是否有相应的闪光灯。检测摄像头是否有闪光灯的代码如下： 12345678910111213public static boolean supportFlash(Camera camera){ Camera.Parameters params = camera.getParameters(); List&lt;String&gt; flashModes = params.getSupportedFlashModes(); if(flashModes == null) { return false; } for(String flashMode : flashModes) { if(Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode)) { return true; } } return false;} 切换闪光灯的代码如下： 123456789101112public static void switchLight(Camera camera, Camera.Parameters cameraParameters) { if (cameraParameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_OFF)) { cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH); } else { cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF); } try { camera.setParameters(cameraParameters); }catch (Exception e) { e.printStackTrace(); }} 4.8 开始预览当打开了摄像头，并且设置好了摄像头相关的参数后，便可以通过调用 Camera 的 startPreview() 方法开始预览。有一个需要说明，无论是 SurfaceView 还是 GLSurfaceView ，都可以设置 SurfaceHolder.Callback ，当界面开始显示的时候打开摄像头并且开始预览，当界面销毁的时候停止预览并且关闭摄像头，这样的话当程序退到后台，其他应用也能调用摄像头。 123456789101112131415161718192021private SurfaceHolder.Callback mSurfaceHolderCallback = new SurfaceHolder.Callback() { @Override public void surfaceDestroyed(SurfaceHolder holder) { Log.d(SopCastConstant.TAG, &quot;SurfaceView destroy&quot;); CameraHolder.instance().stopPreview(); CameraHolder.instance().releaseCamera(); } @TargetApi(Build.VERSION_CODES.GINGERBREAD) @Override public void surfaceCreated(SurfaceHolder holder) { Log.d(SopCastConstant.TAG, &quot;SurfaceView created&quot;); } @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { Log.d(SopCastConstant.TAG, &quot;SurfaceView width:&quot; + width + &quot; height:&quot; + height); CameraHolder.instance().openCamera(); CameraHolder.instance().startPreview(); }}; 5. 停止预览停止预览只需要释放掉相机资源即可: 123456789101112131415public synchronized void releaseCamera() { if (mState == State.PREVIEW) { stopPreview(); } if (mState != State.OPENED) { return; } if (mCameraDevice == null) { return; } mCameraDevice.release(); mCameraDevice = null; mCameraData = null; mState = State.INIT;} 音频编码AudioRecord 采集完之后需要对 PCM 数据进行实时的编码 (软编利用 libfaac 通过 NDK 交叉编译静态库、硬编使用 Android SDK MediaCodec 进行编码)。 软编语音软编这里们用主流的编码库 libfaac 进行编码 AAC 语音格式数据。 1. 编译 libfaac1.1 下载 libfaac1wget https://sourceforge.net/projects/faac/files/faac-src/faac-1.29/faac-1.29.9.2.tar.gz 1.2 编写交叉编译脚本123456789101112131415161718192021222324252627#!/bin/bash#打包地址PREFIX=`pwd`/android/armeabi-v7a#配置NDK 环境变量NDK_ROOT=$NDK_HOME#指定 CPUCPU=arm-linux-androideabi#指定 Android APIANDROID_API=17#编译工具链目录TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64FLAGS=\"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC\"CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabiexport CC=\"$CROSS_COMPILE-gcc --sysroot=$NDK_ROOT/platforms/android-17/arch-arm\"export CFLAGS=\"$FLAGS\"./configure \\--prefix=$PREFIX \\--host=arm-linux \\--with-pic \\--enable-shared=nomake cleanmake install 2. CMakeLists.txt 配置123456789101112131415161718192021222324252627282930313233cmake_minimum_required(VERSION 3.4.1)#语音编码器set(faac ${CMAKE_SOURCE_DIR}/faac)#加载 faac 头文件目录include_directories(${faac}/include)#指定 faac 静态库文件目录set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -L${faac}/libs/${CMAKE_ANDROID_ARCH_ABI}\")#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了file(GLOB Push_CPP ${ykpusher}/*.cpp)#添加自己编写 cpp 源文件生成动态库add_library(ykpusher SHARED ${Push_CPP})#找系统中 NDK log库find_library(log_lib log)#推流 sotarget_link_libraries( #播放 so ykpusher# # 写了此命令不用在乎添加 ffmpeg lib 顺序问题导致应用崩溃# -Wl,--start-group# avcodec avfilter avformat avutil swresample swscale# -Wl,--end-group# z #推流库 rtmp #视频编码 x264 #语音编码 faac #本地库 android ${log_lib} ) 3. 配置 faac 编码参数123456789101112131415161718192021222324252627282930313233//设置语音软编码参数void AudioEncoderChannel::setAudioEncoderInfo(int samplesHZ, int channel) { //如果已经初始化，需要释放 release(); //通道 默认单声道 mChannels = channel; //打开编码器 //3、一次最大能输入编码器的样本数量 也编码的数据的个数 (一个样本是16位 2字节) //4、最大可能的输出数据 编码后的最大字节数 mAudioCodec = faacEncOpen(samplesHZ, channel, &amp;mInputSamples, &amp;mMaxOutputBytes); if (!mAudioCodec) { if (mIPushCallback) { mIPushCallback-&gt;onError(THREAD_MAIN, FAAC_ENC_OPEN_ERROR); } return; } //设置编码器参数 faacEncConfigurationPtr config = faacEncGetCurrentConfiguration(mAudioCodec); //指定为 mpeg4 标准 config-&gt;mpegVersion = MPEG4; //lc 标准 config-&gt;aacObjectType = LOW; //16位 config-&gt;inputFormat = FAAC_INPUT_16BIT; // 编码出原始数据 既不是adts也不是adif config-&gt;outputFormat = 0; faacEncSetConfiguration(mAudioCodec, config); //输出缓冲区 编码后的数据 用这个缓冲区来保存 mBuffer = new u_char[mMaxOutputBytes]; //设置一个标志，用于开启编码 isStart = true;} 4. 配置 AAC 包头在发送 rtmp 音视频包的时候需要将语音包头第一个发送 12345678910111213141516171819202122232425262728293031323334/** * 音频头包数据 * @return */RTMPPacket *AudioEncoderChannel::getAudioTag() { if (!mAudioCodec) { setAudioEncoderInfo(FAAC_DEFAUTE_SAMPLE_RATE, FAAC_DEFAUTE_SAMPLE_CHANNEL); if (!mAudioCodec)return 0; } u_char *buf; u_long len; faacEncGetDecoderSpecificInfo(mAudioCodec, &amp;buf, &amp;len); int bodySize = 2 + len; RTMPPacket *packet = new RTMPPacket; RTMPPacket_Alloc(packet, bodySize); //双声道 packet-&gt;m_body[0] = 0xAF; if (mChannels == 1) { //单身道 packet-&gt;m_body[0] = 0xAE; } packet-&gt;m_body[1] = 0x00; //将包头数据 copy 到RTMPPacket 中 memcpy(&amp;packet-&gt;m_body[2], buf, len); //是否使用绝对时间戳 packet-&gt;m_hasAbsTimestamp = FALSE; //包大小 packet-&gt;m_nBodySize = bodySize; //包类型 packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO; //语音通道 packet-&gt;m_nChannel = 0x11; packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE; return packet;} 5. 开始实时编码12345678910111213141516171819202122232425262728void AudioEncoderChannel::encodeData(int8_t *data) { if (!mAudioCodec || !isStart)//不符合编码要求，退出 return; //返回编码后的数据字节长度 int bytelen = faacEncEncode(mAudioCodec, reinterpret_cast&lt;int32_t *&gt;(data), mInputSamples,mBuffer, mMaxOutputBytes); if (bytelen &gt; 0) { //开始打包 rtmp int bodySize = 2 + bytelen; RTMPPacket *packet = new RTMPPacket; RTMPPacket_Alloc(packet, bodySize); //双声道 packet-&gt;m_body[0] = 0xAF; if (mChannels == 1) { packet-&gt;m_body[0] = 0xAE; } //编码出的音频 都是 0x01 packet-&gt;m_body[1] = 0x01; memcpy(&amp;packet-&gt;m_body[2], mBuffer, bytelen); packet-&gt;m_hasAbsTimestamp = FALSE; packet-&gt;m_nBodySize = bodySize; packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO; packet-&gt;m_nChannel = 0x11; packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE; //发送 rtmp packet，回调给 RTMP send 模块 mAudioCallback(packet); }} 6. 释放编码器在不需要编码或者退出编码的时候需要主动释放编码器，释放 native 内存，可以通过如下函数来实现释放编码器的操作: 123456789101112void AudioEncoderChannel::release() { //退出编码的标志 isStart = false; //释放编码器 if (mAudioCodec) { //关闭编码器 faacEncClose(mAudioCodec); //释放缓冲区 DELETE(mBuffer); mAudioCodec = 0; }} 硬编软编码介绍完了下面利用 Android SDK 自带的 MediaCodec 函数进行对 PCM 编码为 AAC 的格式音频数据。使用 MediaCodec 编码 AAC 对 Android 系统是有要求的，必须是 4.1系统以上，即要求 Android 的版本代号在 Build.VERSION_CODES.JELLY_BEAN (16) 以上。MediaCodec 是 Android 系统提供的硬件编码器，它可以利用设备的硬件来完成编码，从而大大提高编码的效率，还可以降低电量的使用，但是其在兼容性方面不如软编号，因为 Android 设备的锁片化太严重，所以读者可以自己衡量在应用中是否使用 Android 平台的硬件编码特性。 1. 创建 &quot;audio/mp4a-latm&quot; 类型的硬编码器1mediaCodec = MediaCodec.createEncoderByType(configuration.mime); 2. 配置音频硬编码器12345678910111213141516171819202122232425262728public static MediaCodec getAudioMediaCodec(AudioConfiguration configuration){ MediaFormat format = MediaFormat.createAudioFormat(configuration.mime, configuration.frequency, configuration.channelCount); if(configuration.mime.equals(AudioConfiguration.DEFAULT_MIME)) { format.setInteger(MediaFormat.KEY_AAC_PROFILE, configuration.aacProfile); } //语音码率 format.setInteger(MediaFormat.KEY_BIT_RATE, configuration.maxBps * 1024); //语音采样率 44100 format.setInteger(MediaFormat.KEY_SAMPLE_RATE, configuration.frequency); int maxInputSize = AudioUtils.getRecordBufferSize(configuration); format.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize); format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, configuration.channelCount); MediaCodec mediaCodec = null; try { mediaCodec = MediaCodec.createEncoderByType(configuration.mime); //MediaCodec.CONFIGURE_FLAG_ENCODE 代表编码器，解码传 0 即可 mediaCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); } catch (Exception e) { e.printStackTrace(); if (mediaCodec != null) { mediaCodec.stop(); mediaCodec.release(); mediaCodec = null; } } return mediaCodec;} 3. 开启音频硬编码器1234void prepareEncoder() { mMediaCodec = AudioMediaCodec.getAudioMediaCodec(mAudioConfiguration); mMediaCodec.start();} 4. 拿到硬编码输入(PCM)输出(AAC) ByteBufferer到了这一步说明，音频编码器配置完成并且也成功开启了，现在就可以从 MediaCodec 实例中获取两个 buffer ，一个是输入 buffer 一个是输出 buffer , 输入 buffer 类似于 FFmpeg 中的 AVFrame 存放待编码的 PCM 数据，输出 buffer 类似于 FFmpeg 的 AVPacket 编码之后的 AAC 数据, 其代码如下: 1234//存放的是 PCM 数据ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers();//存放的是编码之后的 AAC 数据ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers(); 5. 开始 PCM 硬编码为 AAC到此，所有初始化方法已实现完毕，下面来看一下 MediaCodec 的工作原理如下图所示，左边 Client 元素代表要将 PCM 放到 inputBuffer 中的某个具体的 buffer 中去，右边的 Client 元素代表将编码之后的原始 AAC 数据从 outputBuffer 中的某个具体 buffer 中取出来，👈 左边的小方块代表各个 inputBuffer 元素，右边的小方块则代表各个 outputBuffer 元素。详细介绍可以看 MediaCodec 类介绍。 代表具体实现如下: 123456789101112131415161718192021222324252627 //input:PCM synchronized void offerEncoder(byte[] input) { if(mMediaCodec == null) { return; } ByteBuffer[] inputBuffers = mMediaCodec.getInputBuffers(); ByteBuffer[] outputBuffers = mMediaCodec.getOutputBuffers(); int inputBufferIndex = mMediaCodec.dequeueInputBuffer(12000); if (inputBufferIndex &gt;= 0) { ByteBuffer inputBuffer = inputBuffers[inputBufferIndex]; inputBuffer.clear(); inputBuffer.put(input); mMediaCodec.queueInputBuffer(inputBufferIndex, 0, input.length, 0, 0); } int outputBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, 12000); while (outputBufferIndex &gt;= 0) { ByteBuffer outputBuffer = outputBuffers[outputBufferIndex]; if(mListener != null) { //将 AAC 数据回调出去 mListener.onAudioEncode(outputBuffer, mBufferInfo); } //释放当前内部编码内存 mMediaCodec.releaseOutputBuffer(outputBufferIndex, false); outputBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, 0); } } 6. AAC 打包为 flv1234567891011121314151617181920212223@Overridepublic void onAudioData(ByteBuffer bb, MediaCodec.BufferInfo bi) { if (packetListener == null || !isHeaderWrite || !isKeyFrameWrite) { return; } bb.position(bi.offset); bb.limit(bi.offset + bi.size); byte[] audio = new byte[bi.size]; bb.get(audio); int size = AUDIO_HEADER_SIZE + audio.length; ByteBuffer buffer = ByteBuffer.allocate(size); FlvPackerHelper.writeAudioTag(buffer, audio, false, mAudioSampleSize); packetListener.onPacket(buffer.array(), AUDIO);}public static void writeAudioTag(ByteBuffer buffer, byte[] audioInfo, boolean isFirst, int audioSize) { //写入音频头信息 writeAudioHeader(buffer, isFirst, audioSize); //写入音频信息 buffer.put(audioInfo);} 7. 释放编码器在使用完 MediaCodec 编码器之后，就需要停止运行并释放编码器，代码如下: 1234567synchronized public void stop() { if (mMediaCodec != null) { mMediaCodec.stop(); mMediaCodec.release(); mMediaCodec = null; }} 视频编码Camera 采集完之后需要对 YUV 数据进行实时的编码 (软编利用 x264 通过 NDK 交叉编译静态库、硬编使用 Android SDK MediaCodec 进行编码)。 软编视频软编这里们用主流的编码库 x264 进行编码 H264 视频格式数据。 1. 交叉编译 x2641.1 下载 x2641234//方式 一git clone https://code.videolan.org/videolan/x264.git//方式 二wget ftp://ftp.videolan.org/pub/x264/snapshots/last_x264.tar.bz2 1.2 编写编译脚本在编写脚本之前需要在 configure 中添加一处代码 -Werror=implicit-function-declaration,如下所示: 交叉编译脚本如下: 12345678910111213141516171819202122232425262728293031323334#!/bin/bash#打包地址PREFIX=./android/armeabi-v7a#配置NDK 环境变量NDK_ROOT=$NDK_HOME#指定 CPUCPU=arm-linux-androideabi#指定 Android APIANDROID_API=17TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64FLAGS=\"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC\"#--disable-cli 不需要命令行工具#--enable-static 静态库./configure \\--prefix=$PREFIX \\--disable-cli \\--enable-static \\--enable-pic \\--host=arm-linux \\--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\--sysroot=$NDK_ROOT/platforms/android-17/arch-arm \\--extra-cflags=\"$FLAGS\"make cleanmake install 2. CMakeList.txt 配置12345678910111213141516171819202122232425262728293031323334353637383940cmake_minimum_required(VERSION 3.4.1)#视频编码器set(x264 ${CMAKE_SOURCE_DIR}/x264)#加载 x264 头文件目录include_directories(${x264}/include)#指定 x264 静态库文件目录set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -L${x264}/libs/${CMAKE_ANDROID_ARCH_ABI}\")#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了file(GLOB Player_CPP ${ykplayer}/*.cpp)file(GLOB Push_CPP ${ykpusher}/*.cpp)#添加自己编写 cpp 源文件生成动态库add_library(ykpusher SHARED ${Push_CPP})#找系统中 NDK log库find_library(log_lib log)#推流 sotarget_link_libraries( #播放 so ykpusher# # 写了此命令不用在乎添加 ffmpeg lib 顺序问题导致应用崩溃# -Wl,--start-group# avcodec avfilter avformat avutil swresample swscale# -Wl,--end-group# z #推流库 rtmp #视频编码 x264 #语音编码 faac #本地库 android ${log_lib} ) 3. 配置并打开 x264 编码器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void VideoEncoderChannel::setVideoEncoderInfo(int width, int height, int fps, int bit) { pthread_mutex_lock(&amp;mMutex); this-&gt;mWidth = width; this-&gt;mHeight = height; this-&gt;mFps = fps; this-&gt;mBit = bit; this-&gt;mY_Size = width * height; this-&gt;mUV_Size = mY_Size / 4; //如果编码器已经存在，需要释放 if (mVideoCodec || pic_in) { release(); } //打开x264编码器 //x264编码器的属性 x264_param_t param; //2： 最快 //3: 无延迟编码 x264_param_default_preset(&amp;param, x264_preset_names[0], x264_tune_names[7]); //base_line 3.2 编码规格 param.i_level_idc = 32; //输入数据格式 param.i_csp = X264_CSP_I420; param.i_width = width; param.i_height = height; //无b帧 param.i_bframe = 0; //参数i_rc_method表示码率控制，CQP(恒定质量)，CRF(恒定码率)，ABR(平均码率) param.rc.i_rc_method = X264_RC_ABR; //码率(比特率,单位Kbps) param.rc.i_bitrate = mBit; //瞬时最大码率 param.rc.i_vbv_max_bitrate = mBit * 1.2; //设置了i_vbv_max_bitrate必须设置此参数，码率控制区大小,单位kbps param.rc.i_vbv_buffer_size = mBit; //帧率 param.i_fps_num = fps; param.i_fps_den = 1; param.i_timebase_den = param.i_fps_num; param.i_timebase_num = param.i_fps_den;// param.pf_log = x264_log_default2; //用fps而不是时间戳来计算帧间距离 param.b_vfr_input = 0; //帧距离(关键帧) 2s一个关键帧 param.i_keyint_max = fps * 2; // 是否复制sps和pps放在每个关键帧的前面 该参数设置是让每个关键帧(I帧)都附带sps/pps。 param.b_repeat_headers = 1; //多线程 param.i_threads = 1; x264_param_apply_profile(&amp;param, \"baseline\"); //打开编码器 mVideoCodec = x264_encoder_open(&amp;param); pic_in = new x264_picture_t; x264_picture_alloc(pic_in, X264_CSP_I420, width, height); //相当于重启编码器 isStart = true; pthread_mutex_unlock(&amp;mMutex);} 4. 开始编码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160void VideoEncoderChannel::onEncoder() { while (isStart) { if (!mVideoCodec) { continue; } int8_t *data = 0; mVideoPackets.pop(data); if (!data) { LOGE(\"获取 YUV 数据错误\"); continue; } //copy Y 数据 memcpy(this-&gt;pic_in-&gt;img.plane[0], data, mY_Size); //拿到 UV 数据 for (int i = 0; i &lt; mUV_Size; ++i) { //拿到 u 数据 *(pic_in-&gt;img.plane[1] + i) = *(data + mY_Size + i * 2 + 1); //拿到 v 数据 *(pic_in-&gt;img.plane[2] + i) = *(data + mY_Size + i * 2); } //编码出来的数据 x264_nal_t *pp_nal; //编码出来的帧数量 int pi_nal = 0; x264_picture_t pic_out; //开始编码 int ret = x264_encoder_encode(mVideoCodec, &amp;pp_nal, &amp;pi_nal, pic_in, &amp;pic_out); if (!ret) { LOGE(\"编码失败\"); continue; } //如果是关键帧 int sps_len = 0; int pps_len = 0; uint8_t sps[100]; uint8_t pps[100]; for (int i = 0; i &lt; pi_nal; ++i) { if (pp_nal[i].i_type == NAL_SPS) { //排除掉 h264的间隔 00 00 00 01 sps_len = pp_nal[i].i_payload - 4; memcpy(sps, pp_nal[i].p_payload + 4, sps_len); } else if (pp_nal[i].i_type == NAL_PPS) { pps_len = pp_nal[i].i_payload - 4; memcpy(pps, pp_nal[i].p_payload + 4, pps_len); //pps肯定是跟着sps的 sendSpsPps(sps, pps, sps_len, pps_len); } else { //编码之后的 H264 数据 sendFrame(pp_nal[i].i_type, pp_nal[i].p_payload, pp_nal[i].i_payload, 0); } } }}/** * 发送 sps pps * @param sps 编码第一帧数据 * @param pps 编码第二帧数据 * @param sps_len 编码第一帧数据的长度 * @param pps_len 编码第二帧数据的长度 */void VideoEncoderChannel::sendSpsPps(uint8_t *sps, uint8_t *pps, int sps_len, int pps_len) { int bodySize = 13 + sps_len + 3 + pps_len; RTMPPacket *packet = new RTMPPacket; // RTMPPacket_Alloc(packet, bodySize); int i = 0; //固定头 packet-&gt;m_body[i++] = 0x17; //类型 packet-&gt;m_body[i++] = 0x00; //composition time 0x000000 packet-&gt;m_body[i++] = 0x00; packet-&gt;m_body[i++] = 0x00; packet-&gt;m_body[i++] = 0x00; //版本 packet-&gt;m_body[i++] = 0x01; //编码规格 packet-&gt;m_body[i++] = sps[1]; packet-&gt;m_body[i++] = sps[2]; packet-&gt;m_body[i++] = sps[3]; packet-&gt;m_body[i++] = 0xFF; //整个sps packet-&gt;m_body[i++] = 0xE1; //sps长度 packet-&gt;m_body[i++] = (sps_len &gt;&gt; 8) &amp; 0xff; packet-&gt;m_body[i++] = sps_len &amp; 0xff; memcpy(&amp;packet-&gt;m_body[i], sps, sps_len); i += sps_len; //pps packet-&gt;m_body[i++] = 0x01; packet-&gt;m_body[i++] = (pps_len &gt;&gt; 8) &amp; 0xff; packet-&gt;m_body[i++] = (pps_len) &amp; 0xff; memcpy(&amp;packet-&gt;m_body[i], pps, pps_len); //视频 packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO; packet-&gt;m_nBodySize = bodySize; //随意分配一个管道（尽量避开rtmp.c中使用的） packet-&gt;m_nChannel = 0x10; //sps pps没有时间戳 packet-&gt;m_nTimeStamp = 0; //不使用绝对时间 packet-&gt;m_hasAbsTimestamp = 0; packet-&gt;m_headerType = RTMP_PACKET_SIZE_MEDIUM; if (mVideoCallback &amp;&amp; isStart) mVideoCallback(packet);}/** * 发送视频帧 -- 关键帧 * @param type * @param payload * @param i_playload */void VideoEncoderChannel::sendFrame(int type, uint8_t *payload, int i_payload, long timestamp) { if (payload[2] == 0x00) { i_payload -= 4; payload += 4; } else { i_payload -= 3; payload += 3; } //看表 int bodySize = 9 + i_payload; RTMPPacket *packet = new RTMPPacket; // RTMPPacket_Alloc(packet, bodySize); packet-&gt;m_body[0] = 0x27; if (type == NAL_SLICE_IDR) { packet-&gt;m_body[0] = 0x17; LOGE(\"关键帧\"); } //类型 packet-&gt;m_body[1] = 0x01; //时间戳 packet-&gt;m_body[2] = 0x00; packet-&gt;m_body[3] = 0x00; packet-&gt;m_body[4] = 0x00; //数据长度 int 4个字节 packet-&gt;m_body[5] = (i_payload &gt;&gt; 24) &amp; 0xff; packet-&gt;m_body[6] = (i_payload &gt;&gt; 16) &amp; 0xff; packet-&gt;m_body[7] = (i_payload &gt;&gt; 8) &amp; 0xff; packet-&gt;m_body[8] = (i_payload) &amp; 0xff; //图片数据 memcpy(&amp;packet-&gt;m_body[9], payload, i_payload); packet-&gt;m_hasAbsTimestamp = 0; packet-&gt;m_nBodySize = bodySize; packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO; packet-&gt;m_nChannel = 0x10; packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE; if (mVideoCallback &amp;&amp; isStart) mVideoCallback(packet);//回调给 RTMP 模块} 5. 释放编码器当我们不需要编码的时候需要释放编码器，代码如下: 1x264_encoder_close(mVideoCodec); 硬编在 Android 4.3 系统以后，用 MediaCodec 编码视频成为了主流的使用场景，尽管 Android 的碎片化很严重，会导致一些兼容性问题，但是硬件编码器的性能以及速度是非常可观的，并且在 4.3 系统之后可以通过 Surface 来配置编码器的输入，大大降低了显存到内存的交换过程所使用的时间，从而使得整个应用的体验得到大大提升。由于输入和输出已经确定，因此接下来将直接编写 MediaCodec 编码视频帧的过程。 1. 创建 “video/avc” 类型的硬编码器1mediaCodec = MediaCodec.createEncoderByType(videoConfiguration.mime); 2. 配置视频编码器1234567891011121314151617181920212223242526272829303132public static MediaCodec getVideoMediaCodec(VideoConfiguration videoConfiguration) { int videoWidth = getVideoSize(videoConfiguration.width); int videoHeight = getVideoSize(videoConfiguration.height); MediaFormat format = MediaFormat.createVideoFormat(videoConfiguration.mime, videoWidth, videoHeight); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface); format.setInteger(MediaFormat.KEY_BIT_RATE, videoConfiguration.maxBps* 1024); int fps = videoConfiguration.fps; //设置摄像头预览帧率 if(BlackListHelper.deviceInFpsBlacklisted()) { SopCastLog.d(SopCastConstant.TAG, \"Device in fps setting black list, so set mediacodec fps 15\"); fps = 15; } format.setInteger(MediaFormat.KEY_FRAME_RATE, fps); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, videoConfiguration.ifi); format.setInteger(MediaFormat.KEY_BITRATE_MODE, MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_VBR); format.setInteger(MediaFormat.KEY_COMPLEXITY, MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_CBR); MediaCodec mediaCodec = null; try { mediaCodec = MediaCodec.createEncoderByType(videoConfiguration.mime); mediaCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); }catch (Exception e) { e.printStackTrace(); if (mediaCodec != null) { mediaCodec.stop(); mediaCodec.release(); mediaCodec = null; } } return mediaCodec;} 3. 开启视频编码器1mMediaCodec.start(); 4. 拿到编码之后的数据123456789101112131415161718192021222324252627private void drainEncoder() { ByteBuffer[] outBuffers = mMediaCodec.getOutputBuffers(); while (isStarted) { encodeLock.lock(); if(mMediaCodec != null) { int outBufferIndex = mMediaCodec.dequeueOutputBuffer(mBufferInfo, 12000); if (outBufferIndex &gt;= 0) { ByteBuffer bb = outBuffers[outBufferIndex]; if (mListener != null) { //将编码好的 H264 数据回调出去 mListener.onVideoEncode(bb, mBufferInfo); } mMediaCodec.releaseOutputBuffer(outBufferIndex, false); } else { try { // wait 10ms Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } encodeLock.unlock(); } else { encodeLock.unlock(); break; } }} 5. H264 打包为 flv123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 //接收 H264 数据 @Override public void onVideoData(ByteBuffer bb, MediaCodec.BufferInfo bi) { mAnnexbHelper.analyseVideoData(bb, bi); } /** * 将硬编得到的视频数据进行处理生成每一帧视频数据，然后传给flv打包器 * @param bb 硬编后的数据buffer * @param bi 硬编的BufferInfo */ public void analyseVideoData(ByteBuffer bb, MediaCodec.BufferInfo bi) { bb.position(bi.offset); bb.limit(bi.offset + bi.size); ArrayList&lt;byte[]&gt; frames = new ArrayList&lt;&gt;(); boolean isKeyFrame = false; while(bb.position() &lt; bi.offset + bi.size) { byte[] frame = annexbDemux(bb, bi); if(frame == null) { LogUtils.e(\"annexb not match.\"); break; } // ignore the nalu type aud(9) if (isAccessUnitDelimiter(frame)) { continue; } // for pps if(isPps(frame)) { mPps = frame; continue; } // for sps if(isSps(frame)) { mSps = frame; continue; } // for IDR frame if(isKeyFrame(frame)) { isKeyFrame = true; } else { isKeyFrame = false; } byte[] naluHeader = buildNaluHeader(frame.length); frames.add(naluHeader); frames.add(frame); } if (mPps != null &amp;&amp; mSps != null &amp;&amp; mListener != null &amp;&amp; mUploadPpsSps) { if(mListener != null) { mListener.onSpsPps(mSps, mPps); } mUploadPpsSps = false; } if(frames.size() == 0 || mListener == null) { return; } int size = 0; for (int i = 0; i &lt; frames.size(); i++) { byte[] frame = frames.get(i); size += frame.length; } byte[] data = new byte[size]; int currentSize = 0; for (int i = 0; i &lt; frames.size(); i++) { byte[] frame = frames.get(i); System.arraycopy(frame, 0, data, currentSize, frame.length); currentSize += frame.length; } if(mListener != null) { mListener.onVideo(data, isKeyFrame); } } 这个方法主要是从编码后的数据中解析得到NALU，然后判断NALU的类型，最后再把数据回调给 FlvPacker 去处理。 处理 spsPps: 1234567891011@Overridepublic void onSpsPps(byte[] sps, byte[] pps) { if (packetListener == null) { return; } //写入第一个视频信息 writeFirstVideoTag(sps, pps); //写入第一个音频信息 writeFirstAudioTag(); isHeaderWrite = true;} 处理视频帧: 12345678910111213141516171819@Overridepublic void onVideo(byte[] video, boolean isKeyFrame) { if (packetListener == null || !isHeaderWrite) { return; } int packetType = INTER_FRAME; if (isKeyFrame) { isKeyFrameWrite = true; packetType = KEY_FRAME; } //确保第一帧是关键帧，避免一开始出现灰色模糊界面 if (!isKeyFrameWrite) { return; } int size = VIDEO_HEADER_SIZE + video.length; ByteBuffer buffer = ByteBuffer.allocate(size); FlvPackerHelper.writeH264Packet(buffer, video, isKeyFrame); packetListener.onPacket(buffer.array(), packetType);} 6. 释放编码器,并释放 Surface12345678910111213141516171819202122232425262728//释放编码器private void releaseEncoder() { if (mMediaCodec != null) { mMediaCodec.signalEndOfInputStream(); mMediaCodec.stop(); mMediaCodec.release(); mMediaCodec = null; } if (mInputSurface != null) { mInputSurface.release(); mInputSurface = null; }}//释放 OpenGL ES 渲染，Surfacepublic void release() { EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface); EGL14.eglDestroyContext(mEGLDisplay, mEGLContext); EGL14.eglReleaseThread(); EGL14.eglTerminate(mEGLDisplay); mSurface.release(); mSurface = null; mEGLDisplay = null; mEGLContext = null; mEGLSurface = null;} rtmp 推流注: 实际项目 rtmp 需要先连接上才有后续操作。 rtmp 模块我们已在开发 播放器 的时候，将它和 ffmpeg 一并编译了。所以我们直接使用上次的静态库和头文件就可以了，如果对 rtmp 协议不了解的可以参考上一篇文章，里面也有介绍 搭建 RTMP 直播服务器。 到这里软编码和硬编码数据都已准备好了现在，需要发送给 rtmp 模块，也就是在 native 中，先看 java 发送出口: 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 打包之后的数据，和裸流数据 * * @param data * @param type */@Overridepublic void onData(byte[] data, int type) { if (type == RtmpPacker.FIRST_AUDIO || type == RtmpPacker.AUDIO) {//音频 AAC 数据,已打包 mPusherManager.pushAACData(data, data.length, type); } else if (type == RtmpPacker.FIRST_VIDEO || type == RtmpPacker.INTER_FRAME || type == RtmpPacker.KEY_FRAME) {//H264 视频数据,已打包 mPusherManager.pushH264(data, type, 0); } else if (type == RtmpPacker.PCM) { //PCM 裸流数据 mPusherManager.pushPCM(data); } else if (type == RtmpPacker.YUV) { //YUV 裸流数据 mPusherManager.pushYUV(data); }}/** * 发送 H264 数据 * * @param h264 */public native void pushH264(byte[] h264, int type, long timeStamp);/** * @param audio 直接推编码完成之后的音频流 * @param length * @param timestamp */public native void pushAACData(byte[] audio, int length, int timestamp);/** * 发送 PCM 原始数据 * * @param audioData */public native void native_pushAudio(byte[] audioData);/** * push 视频原始 nv21 * * @param data */public native void native_push_video(byte[] data); 1. Rtmp 链接Rtmp 底层是 TCP 协议，所以你可以使用 Java Socket 进行连接，也可以使用 c++ librtmp 库来进行连接，咱么这里就使用 librtmp 来进行连接。 123456789101112131415161718192021/** * 真正 rtmp 连接的函数 */void RTMPModel::onConnect() { ... //1. 初始化 RTMP_Init(rtmp); //2. 设置rtmp地址 int ret = RTMP_SetupURL(rtmp, this-&gt;url) //3. 确认写入 rtmp RTMP_EnableWrite(rtmp); //4. 开始链接 ret = RTMP_Connect(rtmp, 0); //5. 连接成功之后需要连接一个流 ret = RTMP_ConnectStream(rtmp, 0); ...} 2. Native 音频模块接收 AAC Flv 打包数据1234567891011121314151617/** * 直接推送 AAC 硬编码 * @param data */void AudioEncoderChannel::pushAAC(u_char *data, int dataLen, long timestamp) { RTMPPacket *packet = (RTMPPacket *) malloc(sizeof(RTMPPacket)); RTMPPacket_Alloc(packet, dataLen); RTMPPacket_Reset(packet); packet-&gt;m_nChannel = 0x05; //音频 memcpy(packet-&gt;m_body, data, dataLen); packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE; packet-&gt;m_hasAbsTimestamp = FALSE; packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO; packet-&gt;m_nBodySize = dataLen; if (mAudioCallback) mAudioCallback(packet); //发送给 rtmp 模块} 3. Native 视频模块接收 H264 Flv 打包数据1234567891011121314151617181920212223/** * * @param type 视频帧类型 * @param buf H264 * @param len H264 长度 */void VideoEncoderChannel::sendH264(int type, uint8_t *data, int dataLen, int timeStamp) { RTMPPacket *packet = (RTMPPacket *) malloc(sizeof(RTMPPacket)); RTMPPacket_Alloc(packet, dataLen); RTMPPacket_Reset(packet); packet-&gt;m_nChannel = 0x04; //视频 if (type == RTMP_PACKET_KEY_FRAME) { LOGE(\"视频关键帧\"); } memcpy(packet-&gt;m_body, data, dataLen); packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE; packet-&gt;m_hasAbsTimestamp = FALSE; packet-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO; packet-&gt;m_nBodySize = dataLen; mVideoCallback(packet);//发送给 rtmp 模块} 4. RTMP 发送数据4.1 将接收到的数据入发送队列12345678910//不管是软编码还是硬编码所有发送数据都需要入队列void callback(RTMPPacket *packet) { if (packet) { if (rtmpModel) { //设置时间戳 packet-&gt;m_nTimeStamp = RTMP_GetTime() - rtmpModel-&gt;mStartTime; rtmpModel-&gt;mPackets.push(packet); } }} 4.2 发送1234567891011121314151617181920212223242526272829/** * 真正推流的地方 */void RTMPModel::onPush() { RTMPPacket *packet = 0; while (isStart) { //从队列中获取发送的音视频数据 mPackets.pop(packet); if (!readyPushing) { releasePackets(packet); return; } if (!packet) { LOGE(\"获取失败\"); continue; } packet-&gt;m_nInfoField2 = rtmp-&gt;m_stream_id; int ret = RTMP_SendPacket(rtmp, packet, 1); if (!ret) { LOGE(\"发送失败\") if (pushCallback) { pushCallback-&gt;onError(THREAD_CHILD, RTMP_PUSHER_ERROR); } return; } } releasePackets(packet); release();//释放} 5. 关闭 RTMP当不需要发送音视频数据的时候需要关闭 rtmp 连接 123456789101112void RTMPModel::release() { isStart = false; readyPushing = false; if (rtmp) { RTMP_DeleteStream(rtmp); RTMP_Close(rtmp); RTMP_Free(rtmp); rtmp = 0; LOGE(\"释放 native 资源\"); } mPackets.clearQueue();} 简单谈谈软硬编解码1. 区别软编码: 使用 CPU 进行编码。硬编码: 使用 GPU 进行编码。 2. 比较软编码: 实现直接、简单，参数调整方便，升级容易，但 CPU 负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。硬编码: 性能高，低码率下通常质量低于软编码器，但部分产品在 GPU 硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。 3. 使用场景软编码: 适用短时间操作，如录制短视频等。 硬编码: 长时间编码或者对视频质量要求高(VOIP 实时通话)，可以推荐硬件编码 (前提是手机性能好)。 总结到这里 Android 端软编推流，硬编推流都分别实现了。在项目上可以根据实际情况来选择到底是硬编还是软编。 硬编我是基于来疯开源项目进行二次开发: Android 推流项目地址 Android 拉流项目地址 参考 来疯直播项目","link":"/2020/06/04/Android-%E5%8D%81%E4%B8%80-Android-%E7%AB%AF-rtmp-%E6%8E%A8%E6%B5%81/"},{"title":"性能优化 (九)  APK 安全优化之 Dex 加密解码 -下","text":"上一篇讲了 dex 加密解密 还没有看过的可以先去了解下 dex 怎么加解密，这篇就来带大家完成剩下的工作，dex 解密完成之后需要把代理 ProxyApplication 给删除掉，然后把我们自己的 Application 给添加到我们程序中。想要替换 ProxyApplication 可不是一件简单的事儿，首先必须的对 Application 启动方式很熟悉才能对它进行超作，下面由我来带着大家一起进入源码的世界吧。 Application 绑定过程APP 启动流程可以看我另外一篇文章性能优化(一)启动优化，今天主要从 ActivityThread =&gt; main() 开始，下面以一个流程图来说明一下: XML 中如何解析我们的 Application ActivityThread.java mian() -&gt; thread.attach() -&gt; attachApplication() -&gt; 接收 AMS 发过来的参数之后 sendMessage（H.BIND_APPLICATION）-&gt; 处理 BIND_APPLICATION -&gt; handleBindApplication() 在这里准备好 application - &gt; Application app = data.info.makeApplication() - &gt; mInitialApplication = app; LoadedApk.java 这个类就是 APK 在内存中的表示，可以得到如代码，资料，功能清单等信息 通过 mApplicationInfo.className 得到我们注册的全类名 app = mActivityThread.mInstrumentation.newApplication () 创建 application 接下来会使用 appContext.setOuterContext(app) mApplication = app 反射需要替换的内容 ContextImpl -&gt; mOuterContext(app) 通过 Application 的 attachBaseContext 回调参数获取 ActivityThread -&gt; mAllApplication(arrayList) 通过 ContextImpl 的 mMainThread 属性获取 LoadedApk -&gt; mApplication 通过 ContextImpl 的 mPackageInfo 属性获取 反射开始替换 Application123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 boolean isBindReal; Application delegate; private void bindRealApplicatin() throws Exception { if (isBindReal) { return; } if (TextUtils.isEmpty(app_name)) { return; } //得到attachBaseContext(context) 传入的上下文 ContextImpl Context baseContext = getBaseContext(); //创建用户真实的application (MyApplication) Class&lt;?&gt; delegateClass = Class.forName(app_name); delegate = (Application) delegateClass.newInstance(); //得到attach()方法 Method attach = Application.class.getDeclaredMethod(\"attach\", Context.class); attach.setAccessible(true); attach.invoke(delegate, baseContext);// ContextImpl----&gt;mOuterContext(app) 通过Application的attachBaseContext回调参数获取 Class&lt;?&gt; contextImplClass = Class.forName(\"android.app.ContextImpl\"); //获取mOuterContext属性 Field mOuterContextField = contextImplClass.getDeclaredField(\"mOuterContext\"); mOuterContextField.setAccessible(true); mOuterContextField.set(baseContext, delegate);// ActivityThread---&gt;mAllApplications(ArrayList) ContextImpl的mMainThread属性 Field mMainThreadField = contextImplClass.getDeclaredField(\"mMainThread\"); mMainThreadField.setAccessible(true); Object mMainThread = mMainThreadField.get(baseContext);// ActivityThread---&gt;&gt;mInitialApplication Class&lt;?&gt; activityThreadClass=Class.forName(\"android.app.ActivityThread\"); Field mInitialApplicationField = activityThreadClass.getDeclaredField(\"mInitialApplication\"); mInitialApplicationField.setAccessible(true); mInitialApplicationField.set(mMainThread,delegate);// ActivityThread---&gt;mAllApplications(ArrayList) ContextImpl的mMainThread属性 Field mAllApplicationsField = activityThreadClass.getDeclaredField(\"mAllApplications\"); mAllApplicationsField.setAccessible(true); ArrayList&lt;Application&gt; mAllApplications =(ArrayList&lt;Application&gt;) mAllApplicationsField.get(mMainThread); mAllApplications.remove(this); mAllApplications.add(delegate);// LoadedApk-------&gt;mApplication ContextImpl的mPackageInfo属性 Field mPackageInfoField = contextImplClass.getDeclaredField(\"mPackageInfo\"); mPackageInfoField.setAccessible(true); Object mPackageInfo=mPackageInfoField.get(baseContext); Class&lt;?&gt; loadedApkClass=Class.forName(\"android.app.LoadedApk\"); Field mApplicationField = loadedApkClass.getDeclaredField(\"mApplication\"); mApplicationField.setAccessible(true); mApplicationField.set(mPackageInfo,delegate); //修改ApplicationInfo className LooadedApk Field mApplicationInfoField = loadedApkClass.getDeclaredField(\"mApplicationInfo\"); mApplicationInfoField.setAccessible(true); ApplicationInfo mApplicationInfo = (ApplicationInfo)mApplicationInfoField.get(mPackageInfo); mApplicationInfo.className=app_name; delegate.onCreate(); isBindReal = true; } 现在签名打包完成，启动我们的 APK 看下 Log 12345678910111213142019-06-04 23:17:30.892 6064-6064/com.yk.dexdeapplication I/DevYK: provider onCreate:com.example.proxy_core.ProxyApplication@1ec3c702019-06-04 23:17:30.892 6064-6064/com.yk.dexdeapplication I/DevYK: provider onCreate:com.example.proxy_core.ProxyApplication@1ec3c702019-06-04 23:17:30.892 6064-6064/com.yk.dexdeapplication I/DevYK: provider onCreate:com.example.proxy_core.ProxyApplication2019-06-04 23:17:30.895 6064-6064/com.yk.dexdeapplication I/DevYK: MyApplication onCreate()2019-06-04 23:17:30.995 6064-6064/com.yk.dexdeapplication I/DevYK: activity:com.yk.dexdeapplication.App@300b5f62019-06-04 23:17:30.995 6064-6064/com.yk.dexdeapplication I/DevYK: activity:com.yk.dexdeapplication.App@300b5f62019-06-04 23:17:30.995 6064-6064/com.yk.dexdeapplication I/DevYK: activity:com.yk.dexdeapplication.App2019-06-04 23:17:31.001 6064-6064/com.yk.dexdeapplication I/DevYK: provider delete:com.example.proxy_core.ProxyApplication@1ec3c702019-06-04 23:17:31.021 6064-6064/com.yk.dexdeapplication I/DevYK: service:com.yk.dexdeapplication.App@300b5f62019-06-04 23:17:31.021 6064-6064/com.yk.dexdeapplication I/DevYK: service:com.yk.dexdeapplication.App@300b5f62019-06-04 23:17:31.021 6064-6064/com.yk.dexdeapplication I/DevYK: service:com.yk.dexdeapplication.App2019-06-04 23:17:31.022 6064-6064/com.yk.dexdeapplication I/DevYK: reciver:android.app.ReceiverRestrictedContext@9b922932019-06-04 23:17:31.022 6064-6064/com.yk.dexdeapplication I/DevYK: reciver:com.yk.dexdeapplication.App@300b5f62019-06-04 23:17:31.022 6064-6064/com.yk.dexdeapplication I/DevYK: reciver:com.yk.dexdeapplication.App 注意看 LOG 1MyApplication onCreate() 这里已经替换成我们自己的 MyApplication , 而且 Activity 和 Service 获取上下文也已经是我们替换成功的 Applicaton。但是…也许有的眼神比较好的已经看出问题了，为什么内容提供者 Context 还是代理的 Application 而且比我们自己的应用还要先执行，那么我们带着这个问题去看 Application onCreate 之前做了什么事儿。 我们点击 installlContentProviders(app,providers); 注意这里传进去的还是 代理 Context 重点在最后 注意看我 勾画 的圈里面的逻辑判断，判断当前应用的包名是否跟 XML 中的包名一致，如果一致我们就赋值，再次提醒下 这里的 context 是我们代理的 context ,那么我们怎么做勒，我们在代理中重写 PackageName 只要都不等 那么就会走 else 会根据包名创建一个 Context 12345678910111213141516171819202122232425/** * 让代码走入if中的第三段中 * @return */@Overridepublic String getPackageName() { if(!TextUtils.isEmpty(app_name)){ return \"\"; } return super.getPackageName();}@Overridepublic Context createPackageContext(String packageName, int flags) throws PackageManager.NameNotFoundException { if(TextUtils.isEmpty(app_name)){ return super.createPackageContext(packageName, flags); } try { bindRealApplicatin(); } catch (Exception e) { e.printStackTrace(); } return delegate;} 首先判断我们自己 XML 中的 app_name 是否为空 如果不为空，我们传入一个 空包 SDK 会判断是否跟 XML 中的 pck 一样，最后走 else 我们在重写 createPackageContext 传入我们自己应用的包名。会生成一个 Context 最后我们来验证一下： 12345678910111213142019-06-05 00:12:30.271 7570-7570/com.yk.dexdeapplication I/DevYK: MyApplication onCreate()2019-06-05 00:12:30.273 7570-7570/com.yk.dexdeapplication I/DevYK: provider onCreate:com.yk.dexdeapplication.App@1ec3c702019-06-05 00:12:30.273 7570-7570/com.yk.dexdeapplication I/DevYK: provider onCreate:com.yk.dexdeapplication.App@1ec3c702019-06-05 00:12:30.273 7570-7570/com.yk.dexdeapplication I/DevYK: provider onCreate:com.yk.dexdeapplication.App2019-06-05 00:12:30.381 7570-7570/com.yk.dexdeapplication I/DevYK: activity:com.yk.dexdeapplication.App@1ec3c702019-06-05 00:12:30.381 7570-7570/com.yk.dexdeapplication I/DevYK: activity:com.yk.dexdeapplication.App@1ec3c702019-06-05 00:12:30.381 7570-7570/com.yk.dexdeapplication I/DevYK: activity:com.yk.dexdeapplication.App2019-06-05 00:12:30.387 7570-7570/com.yk.dexdeapplication I/DevYK: provider delete:com.yk.dexdeapplication.App@1ec3c702019-06-05 00:12:30.406 7570-7570/com.yk.dexdeapplication I/DevYK: service:com.yk.dexdeapplication.App@1ec3c702019-06-05 00:12:30.406 7570-7570/com.yk.dexdeapplication I/DevYK: service:com.yk.dexdeapplication.App@1ec3c702019-06-05 00:12:30.406 7570-7570/com.yk.dexdeapplication I/DevYK: service:com.yk.dexdeapplication.App2019-06-05 00:12:30.408 7570-7570/com.yk.dexdeapplication I/DevYK: reciver:android.app.ReceiverRestrictedContext@b7a3b822019-06-05 00:12:30.408 7570-7570/com.yk.dexdeapplication I/DevYK: reciver:com.yk.dexdeapplication.App@1ec3c702019-06-05 00:12:30.408 7570-7570/com.yk.dexdeapplication I/DevYK: reciver:com.yk.dexdeapplication.App 日志中除了 BroadCase Context 是系统的以外，所有的 Context 都是我们替换的 Application Context。完美这解决。不过这里有一个隐藏 BUG ，据说面试题会问那么是什么勒？ 可以在广播中使用 context 在开启一个广播吗？ 我们其实可以带着这个问题看下源码 H -&gt; RECEIVER 消息 果然注册广播和绑定服务会抛一个异常。 总结到这里我们的加固已经讲完了，从 dex 分包 -&gt; 加密 -&gt; 对齐 &gt; 签名 - &gt; 打包压缩成 APK 。一套完整的流程和代码都已经写完了。跟市面上的加固流程原理都几乎一样。懂了原理再去使用第三方就轻车熟路了。 代码传送","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B9%9D-APK-%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96%E4%B9%8B-Dex-%E5%8A%A0%E5%AF%86%E8%A7%A3%E7%A0%81%E4%B8%8B/"},{"title":"性能优化 (二) UI 绘制优化","text":"CPU 与 GPU 工作流程介绍 CPU 的任务繁多，做逻辑计算外，还要做内存管理、显示操作，因此在实际运算的时候性能会大打折扣，在没有 GPU 的时代，不能显示复杂的图形，其运算速度远跟不上今天复杂三维游戏的要求。即使 CPU的工作频率超过 2GHz 或更高，对它绘制图形提高也不大。这时 GPU的设计就出来了 CPU GPU 架构分析 由图分析 CPU GPU : 黄色的 Control 为控制器，用于协调控制整个 CPU 的运行，包括取出指令、控制其它模块的运行等； 绿色的 ALU (Arithmetic Logic Unit) 是算术逻辑单元，用于进行数学、逻辑运行； 橙色的 Cache 和 DRAM 分别为缓存和 RAW，用于存储信息； 总结 从 CPU / GPU 结构图可以看出，CPU 的控制器较为复杂，而 ALU 数量较少。因此 CPU 擅长各种复杂的逻辑运算，但不擅长数据尤其是浮点运算。 简要执行流程 *栅格化概念: *栅格化是将向量图形格式表示的图像转换成位图来交于显示器 60 HZ 刷新频率由来12 fps: 由于人类眼睛的特殊生理结构，如果所看到的画面之帧率高于每秒约 10 - 12 帧的时候，就会认为是连贯的； 24 fps: 有声电影的拍摄及播放帧率均为 24 帧，对一般人而言可以接受； *30 fps: * 早期的高动态电子游戏，帧率少于每秒 30 帧的话就会显得不连贯，这是因为没有动态模糊使流畅度降低; *60 fps: * 在于手机交互过程中，如触摸和反馈 60 帧以下，肉眼是能感觉出来的。60 帧以上不能察觉变化。当低于 60 fps 时感觉画面有卡顿现象。 Android 系统每隔 16ms 发出 VSYNC 信号 (1000 ms / 60 = 16.66 ms) ，触发对 UI 进行渲染， 如果每次渲染都成功这样就能够达到流畅的画面所需要的 60 fps ，为了能够实现 60 fps ，这意味着计算渲染的大多数操作都必须在 16ms 内完成 卡顿原理分析介绍 当这一帧画面渲染时间操过 16 ms 的时候，垂直同步机制会让显示器硬件等待 GPU 完成栅格化渲染操作，这样会让这一帧画面，多停留了 16 ms,甚至更多，这样就造成了用户看起来画面停顿。 16 毫秒的时间主要被两件事情所占用 将 UI 对象转换为一系列多边形和纹理。 CPU 传递处理数据到 GPU 。所以很明显，我们要缩短这两部分的时间，也就是说需要尽量减少对象转换的次数，以及上传数据的次数。 如何减少这 2 件事的耗时，以满足在16ms 渲染完成 CPU 减少 xml 转换成对象的时间。 GPU 减少重复绘制的时间。 过渡绘制优化(主要减少 GPU 工作量)简介 ​ GPU 的绘制过程，就跟刷墙一样，一层一层的进行， 16 ms 刷一次，这样就会造成图层覆盖的现象，即无用的图层还是绘制在底层，造成不必要的浪费。 GPU 过渡绘制几种情况 自定义控件中 onDraw 方法做了过多重复绘制。 布局层次太深，重叠性太强。用户看不到区域也会渲染，导致耗时增加。 过渡绘制查看工具 *真彩色: * 没有过渡绘制 *浅蓝色: *过渡绘制一次 *浅绿色: *过渡绘制 二次 *粉红色: * 过渡绘制 三次 *大红色: * 过渡绘制 四次 工具查看 优化方案 减少背景重复（非业务需要，不要设置背景） 去掉单个 activity的主题设置，可以在 setContentView 之前 getWindow().setBackgroupDrawable(null); 去掉所有的 activity 主题中的属性 1&lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt; 使用裁剪来减少控件之间的重合部分（比如扑克牌） Android 7.0 之后系统做出了优化 invalidate() 不在执行测量和布局动作。 布局的优化(主要减少 CPU 工作量)常用工具 UI Automator Viewer (Android / SDK / tool / bin /uiautomator.bat) uiautomatorviewer 是 android SDK 自带的工具。通过截屏并分析 XML布局文件的方式，为用户提供控件信息查看服务。该工具位于 SDK 目录下的 tools\\bin 子目录下。可以看到，它是通过 bat 文件启动的。 monitor.bat (Android/sdk/tools/monitor.bat)。 官网介绍使用 Device Monitor 窗口中 Hierarchy view； 三个点也是代表着 View 的 Measure , Layout 和 Draw 。 绿: 表示该 View 的此项性能比该 View Tree 中超过 50% 的 View 都要快；例如,代表Measure 的是绿点,意味着这个视图的测量时间快于树中的视图对象的 50%。 黄: 表示该 View 的此项性能比该 View Tree 中超过 50% 的 View 都要慢； 红: 表示该 View 的此项性能是 View Tree 中最慢的； 总结 自定义中 如果有出现覆盖遮挡的视图，可以按照上一层的位置来进行 裁剪。 XML 中层次问题，能在一个平面显示的内容，尽量只用一个容器。 尽可能把相同的容器合并 merge。 能复用的代码，用 include 处理，可以减少 GPU 重复工作。","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%8C-UI-%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/"},{"title":"性能优化 (三) 内存优化","text":"我们为什么要优化内存 在 Android 中我们写的 .java 文件，最终会编译成 .class 文件, class 又由类装载器加载后，在 JVM 中会形成一份描述 class 结构的元信息对象，通过该元信息对象可以知道 class 的结构信息 (构造函数、属性、方法)等。JVM 会把描述类的数据从 class 文件加载到内存，Java 有一个很好的管理内存的机制，垃圾回收机制 GC 。为什么 Java 都给我们提供了垃圾回收机制，程序有时还会导致内存泄漏，内存溢出 OOM，甚至导致程序 Crash 。接下来我们就对实际开发中出现的这些内存问题，来进行优化。 JAVA 虚拟机我们先来大概了解一下 Java 虚拟机里面运行时的数据区域有哪些，如果想深入了解 Java 虚拟机 建议可以购买&lt;&lt;深入理解 Java 虚拟机&gt;&gt; 或者直接点击我这里的 PDF 版本 密码: jmnf 线程独占区程序计数器 相当于一个执行代码的指示器，用来确认下一行执行的地址 每个线程都有一个 没有 OOM 的区 虚拟机栈 我们平时说的栈就是这块区域 java 虚拟机规范中定义了 OutOfMemeory , stackoverflow 异常 本地方法栈 java 虚拟机规范中定义了 OutOfMemory ，stackoverflow 异常 注意 在 hotspotVM 中把虚拟机栈和本地方法栈合为了一个栈区 线程共享区方法区 ClassLoader 加载类信息 常量、静态变量 编译后的代码 会出现 OOM 运行时常量池 public static final 符号引用类、接口全名、方法名 java 堆 (本次需要优化的地方) 虚拟机能管理的最大的一块内存 GC 主战场 会出现 OOM 对象实例 数据的内容 JAVA GC 如何确定内存回收随着程序的运行，内存中的实例对象、变量等占据的内存越来越多，如果不及时进行回收，会降低程序运行效率，甚至引发系统异常。 目前虚拟机基本都是采用可达性分析算法，为什么不采用引用计数算法呢？下面就说说引用计数法是如果统计所有对象的引用计数的，再对比可达性分析算法是如何解决引用计数算法的不足。下面就来看下这 2 个算法： 引用计数算法每个对象有一个引用计数器，当对象被引用一次则计数器加一，当对象引用一次失效一次则计数器减一，对于计数器为 0 的时候就意味着是垃圾了，可以被 GC 回收。 下面通过一段代码来实际看下 1234567891011121314151617181920212223public class GCTest { private Object instace = null; public static void onGCtest() { //step 1 GCTest gcTest1 = new GCTest(); //step 2 GCTest gcTest2 = new GCTest(); //step 3 gcTest1.instace = gcTest2; //step 4 gcTest2.instace = gcTest1; //step 5 gcTest1 = null; //step 6 gcTest2 = null; } public static void main(String[] arg) { onGCtest(); }} 分析代码 123456//step 1 gcTest1 引用 + 1 = 1//step 2 gcTest2 引用 + 1 = 1//step 3 gcTest1 引用 + 1 = 2//step 4 gcTest2 引用 + 1 = 2//step 5 gcTest1 引用 - 1 = 1//step 6 gcTest2 引用 - 1 = 1 很明显现在 2 个对象都不能用了都为 null 了，但是 GC 确不能回收它们，因为它们本身的引用计数不为 0 。不能满足被回收的条件，尽管调用 System.gc() 也还是不能得到回收, 这就造成了 内存泄漏 。当然，现在虚拟机基本上都不采用此方式。 可达性分析算法 GC Roots 的对象作为起始点，向下搜索走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链，即从GC roots 到这个对象不可达，则证明对象不可用，可被回收。 可以作为 GC Roots 的对象 虚拟机栈正在运行使用的引用 静态属性 常量 JNI 引用的对象 GC 是需要 2 次扫描才回收对象，所以我们可以使用 finalize 去救活丢失的引用 12345@Override protected void finalize() throws Throwable { super.finalize(); instace = this; } 到了这里，相信大家已经能够弄明白这 2 个算法的区别了吧？反正对于对象之间循环引用的情况，引用计数算法无法回收这 2 个对象，而可达性是从 GC Roots 开始搜索，所以能够正确的回收。 不同引用类型的回收状态强引用1Object strongReference = new Object() 如果一个对象具有强引用，那垃圾回收器绝不会回收它，当内存空间不足， Java 虚拟机宁愿抛出 OOM 错误，使程序异常 Crash ,也不会靠随意回收具有强引用的对象来解决内存不足的问题.如果强引用对象不再使用时，需要弱化从而使 GC 能够回收，需要： 1strongReference = null; //等 GC 来回收 还有一种情况，如果： 123public void onStrongReference(){ Object strongReference = new Object()} 在 onStrongReference() 内部有一个强引用，这个引用保存在 java 栈 中，而真正的引用内容 （Object）保存在 java 堆中。当这个方法运行完成后，就会退出方法栈，则引用对象的引用数为 0 ，这个对象会被回收。 但是如果 mStrongReference 引用是全局时，就需要在不用这个对象时赋值为 null ,因为 强引用 不会被 GC 回收。 软引用 (SoftReference)如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收， java 虚拟机就会把这个软引用加入到与之关联的引用队列中。 注意: 软引用对象是在 jvm 内存不够的时候才会被回收，我们调用 System.gc() 方法只是起通知作用， JVM 什么时候扫描回收对象是 JVM 自己的状态决定的。就算扫描到了 str 这个对象也不会回收，只有内存不足才会回收。 弱引用 (WeakReference)弱引用与软引用的区别在于: 只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。 可见 weakReference 对象的生命周期基本由 GC 决定，一旦 GC 线程发现了弱引用就标记下来，第二次扫描到就直接回收了。 注意这里的 referenceQueuee 是装的被回收的对象。 虚引用 (PhantomReference)123456789@Testpublic void onPhantomReference()throws InterruptedException{ String str = new String(\"123456\"); ReferenceQueue queue = new ReferenceQueue(); // 创建虚引用，要求必须与一个引用队列关联 PhantomReference pr = new PhantomReference(str, queue); System.out.println(\"PhantomReference:\" + pr.get()); System.out.printf(\"ReferenceQueue:\" + queue.poll());} 虚引用顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于: 虚引用必须和引用队列 (ReferenceQueue) 联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 总结 引用类型 调用方式 GC 是否内存泄漏 强引用 直接调用 不回收 是 软引用 .get() 视内存情况回收 否 弱引用 .get() 回收 不可能 虚引用 null 任何时候都可能被回收，相当于没有引用一样 否 分析内存常用工具工具很多，掌握原理方法，工具随意挑选使用。 top/procrankmeinfoProcstatsDDMSMATFinder - ActivityLeakCanaryLeakInspector内存泄漏产生的原因: 一个长生命周期的对象持有一个短生命周期对象的引用，通俗点讲就是该回收的对象，因为引用问题没有被回收，最终会产生 OOM。 下面我们来利用 Profile 来检查项目是否有内存泄漏 怎么利用 profile 来查看项目中是否有内存泄漏 在 AS 中项目以 profile 运行 在 MEMORY 界面中选择要分析的一段内存，右键 export Allocations: 动态分配对象个数 Deallocation: 解除分配的对象个数 Total count: 对象的总数 Shalow Size: 对象本身占用的内存大小 Retained Size: GC 回收能收走的内存大小 转换 profile 文件格式 将 export 导出的 dprof 文件转换为 Mat 的 dprof 文件 cd /d 进入到 Android sdk/platform-tools/hprof-conv.exe 12//转换命令 hprof-conv -z src desD:\\Android\\AndroidDeveloper-sdk\\android-sdk-windows\\platform-tools&gt;hprof-conv -z D:\\temp_\\temp_6.hprof D:\\temp_\\memory6.hprod 下载 Mat 工具 打开 MemoryAnalyzer.exe 点击左上角 File 菜单中的 Open Heap Dupm 查看内存泄漏中的 GC Roots 强引用 这里我们得知是一个 ilsLoginListener 引用了 LoginView,我们来看下代码最后怎么解决的。 代码中我们找到了 LoginView 这个类，发现是一个单例中的回调引起的内存泄漏，下面怎么解决勒，请看第七小点。 2种解决单例中的内存泄漏 将引用置为 null 1234567891011/** * 销毁监听 */ public void unRemoveRegisterListener(){ mMessageController.unBindListener(); } public void unBindListener(){ if (listener != null){ listener = null; } } 使用弱引用 12345//将监听器放入弱引用中WeakReference&lt;IBinderServiceListener&gt; listenerWeakReference = new WeakReference&lt;&gt;(listener);//从弱引用中取出回调listenerWeakReference.get()； 通过第七小点就能完美的解决单例中回调引起的内存泄漏。 Android 中常见的内存泄漏经典案例及解决方法 单例 示例 : 123456789101112131415161718192021public class AppManager { private static AppManager sInstance; private CallBack mCallBack; private Context mContext; private AppManager(Context context) { this.mContext = context; } public static AppManager getInstance(Context context) { if (sInstance == null) { sInstance = new AppManager(context); } return sInstance; } public void addCallBack(CallBack call){ mCallBack = call； }} 通过上面的单列，如果 context 传入的是 Activity , Service 的 this，那么就会导致内存泄漏。 以 Activity 为例，当 Activity 调用 getInstance 传入 this ，那么 sInstance 就会持有 Activity 的引用，当 Activity 需要关闭的时候需要 回收的时候，发现 sInstance 还持有 没有用的 Activity 引用，导致 Activity 无法被 GC 回收，就会造成内存泄漏 addCallBack(CallBack call) 这样写看起来是没有毛病的。但是当这样调用在看一下勒。 1234567//在 Activity 中实现单例的回调AppManager.getInstance(getAppcationContext()).addCallBack(new CallBack(){ @Override public void onStart(){ }})； 这里的 new CallBack() 匿名内部类 默认持有外部的引用，造成 CallBack 释放不了，那么怎么解决了，请看下面解决方法 解决方法: getInstance(Context context) context 都传入 Appcation 级别的 Context,或者实在是需要传入 Activity 的引用就用 WeakReference 这种形式。 匿名内部类建议大家单独写一个文件或者 123public void addCallBack(CallBack call){ WeakReference&lt;CallBack&gt; mCallBack= new WeakReference&lt;CallBack&gt;(call)； } Handler 示例: 123456789//在 Activity 中实现 Handlerclass MyHandler extends Handler{ private Activity m; public MyHandler(Activity activity){ m=activity; }// class.....} 这里的 MyHandler 持有 activity 的引用，当 Activity 销毁的时候，导致 GC 不会回收造成 内存泄漏。 解决方法: 123456789101.使用静态内部类 + 弱引用2.在 Activity onDestoty() 中处理 removeCallbacksAndMessages() @Override protected void onDestroy() { super.onDestroy(); if(null != handler){ handler.removeCallbacksAndMessages(null); handler = null; } } 静态变量 示例: 123456789101112131415161718public class MainActivity extends AppCompatActivity { private static Police sPolice; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (sPolice != null) { sPolice = new Info(this); } }}class Police { public Police(Activity activity) { }} 这里 Police 持有 activity 的引用，会造成 activity 得不到释放，导致内存泄漏。 解决方法: 12//1. sPolice 在 onDestory（）中 sPolice = null;//2. 在 Police 构造函数中 将强引用 to 弱引用； 非静态内部类 参考 第二点 Handler 的处理方式 匿名内部类 示例: 1234567891011121314public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(){ @Override public void run() { super.run(); } }; }} 很多初学者都会像上面这样新建线程和异步任务，殊不知这样的写法非常地不友好，这种方式新建的子线程Thread和AsyncTask都是匿名内部类对象，默认就隐式的持有外部Activity的引用，导致Activity内存泄露。 解决方法: 12//静态内部类 + 弱引用//单独写一个文件 + onDestory = null; 未取消注册或回调 示例: 12345678910111213141516public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); registerReceiver(mReceiver, new IntentFilter()); } private BroadcastReceiver mReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO ------ } };} 在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用Retrofit + RxJava注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。 解决方法: 123456//Activity 中实现 onDestory（）反注册广播得到释放 @Override protected void onDestroy() { super.onDestroy(); this.unregisterReceiver(mReceiver); } 定时任务 示例: 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity { /**模拟计数*/ private int mCount = 1; private Timer mTimer; private TimerTask mTimerTask; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); mTimer.schedule(mTimerTask, 1000, 1000); } private void init() { mTimer = new Timer(); mTimerTask = new TimerTask() { @Override public void run() { MainActivity.this.runOnUiThread(new Runnable() { @Override public void run() { addCount(); } }); } }; } private void addCount() { mCount += 1; }} 当我们Activity销毁的时，有可能Timer还在继续等待执行TimerTask，它持有Activity 的引用不能被 GC 回收，因此当我们 Activity 销毁的时候要立即cancel掉Timer和TimerTask，以避免发生内存泄漏。 解决方法: 1234567891011121314151617//当 Activity 关闭的时候，停止一切正在进行中的定时任务，避免造成内存泄漏。 private void stopTimer() { if (mTimer != null) { mTimer.cancel(); mTimer = null; } if (mTimerTask != null) { mTimerTask.cancel(); mTimerTask = null; } } @Override protected void onDestroy() { super.onDestroy(); stopTimer(); } 资源未关闭 示例: 1ArrayList,HashMap,IO,File,SqLite,Cursor 等资源用完一定要记得 clear remove 等关闭一系列对资源的操作。 解决方法: 1用完即刻销毁 属性动画 示例: 1动画同样是一个耗时任务，比如在 Activity 中启动了属性动画 (ObjectAnimator) ，但是在销毁的时候，没有调用 cancle 方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用 Activity ，这就造成 Activity 无法正常释放。因此同样要在Activity 销毁的时候 cancel 掉属性动画，避免发生内存泄漏。 解决方法: 123456@Overrideprotected void onDestroy() { super.onDestroy(); //当关闭 Activity 的时候记得关闭动画的操作 mAnimator.cancel();} Android 源码或者第三方 SDK 示例: 1//如果在开发调试中遇见 Android 源码或者 第三方 SDK 持有了我们当前的 Activity 或者其它类，那么现在怎么办了。 解决方法: 1//当前是通过 Java 中的反射找到某个类或者成员，来进行手动 = null 的操作。 内存抖动什么是内存抖动内存频繁的分配与回收,(分配速度大于回收速度时) 最终产生 OOM 。 也许下面的录屏更能解释什么是内存泄漏 可以看出当我点击了一下 Button 内存就频繁的创建并回收（注意看垃圾桶）。 那么我们找出代码中具体那一块出现问题了勒，请看下面一段录屏 12345678910111213141516171819202122232425262728293031323334353637 mButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { imPrettySureSortingIsFree(); } });/** * 排序后打印二维数组，一行行打印 */ public void imPrettySureSortingIsFree() { int dimension = 300; int[][] lotsOfInts = new int[dimension][dimension]; Random randomGenerator = new Random(); for (int i = 0; i &lt; lotsOfInts.length; i++) { for (int j = 0; j &lt; lotsOfInts[i].length; j++) { lotsOfInts[i][j] = randomGenerator.nextInt(); } } for (int i = 0; i &lt; lotsOfInts.length; i++) { String rowAsStr = \"\"; //排序 int[] sorted = getSorted(lotsOfInts[i]); //拼接打印 for (int j = 0; j &lt; lotsOfInts[i].length; j++) { rowAsStr += sorted[j]; if (j &lt; (lotsOfInts[i].length - 1)) { rowAsStr += \", \"; } } Log.i(\"ricky\", \"Row \" + i + \": \" + rowAsStr); } } 最后我们之后是 onClick 中的 imPrettySureSortingIsFree() 函数里面的 rowAsStr += sorted[j]; 字符串拼接造成的 内存抖动 ，因为每次拼接一个 String 都会申请一块新的堆内存，那么怎么解决这个频繁开辟内存的问题了。其实在 Java 中有 2 个更好的 API 对 String 的操作很友好，相信应该有人猜到了吧。没错就是将 此处的 String 换成 StringBuffer 或者 StringBuilder，就能很完美的解决字符串拼接造成的内存抖动问题。 修改后 1234567891011121314151617181920212223242526272829303132/** * 打印二维数组，一行行打印 */public void imPrettySureSortingIsFree() { int dimension = 300; int[][] lotsOfInts = new int[dimension][dimension]; Random randomGenerator = new Random(); for(int i = 0; i &lt; lotsOfInts.length; i++) { for (int j = 0; j &lt; lotsOfInts[i].length; j++) { lotsOfInts[i][j] = randomGenerator.nextInt(); } } // 使用StringBuilder完成输出，我们只需要创建一个字符串即可， 不需要浪费过多的内存 StringBuilder sb = new StringBuilder(); String rowAsStr = \"\"; for(int i = 0; i &lt; lotsOfInts.length; i++) { // 清除上一行 sb.delete(0, rowAsStr.length()); //排序 int[] sorted = getSorted(lotsOfInts[i]); //拼接打印 for (int j = 0; j &lt; lotsOfInts[i].length; j++) { sb.append(sorted[j]); if(j &lt; (lotsOfInts[i].length - 1)){ sb.append(\", \"); } } rowAsStr = sb.toString(); Log.i(\"jason\", \"Row \" + i + \": \" + rowAsStr); }} 这里可以看见没有垃圾桶出现，说明内存抖动解决了。 注意: 实际开发中如果在 LogCat 中发现有这些 Log 说明也发生了 内存抖动 (Log 中出现 concurrent copying GC freed ….) 回收算法ps:我觉得这个只是为了应付面试，那么可以参考这里，我也只了解概念这里就不用在多写了，点击看这个帖子吧 标记清除算法 Mark-Sweep![](https://s1.ax1x.com/2018/08/25/PbAuX4.png 复制算法 Copying标记压缩算法 Mark-Compact分带收集算法总结 (只要养成这样的习惯，至少可以避免 90 % 以上不会造成内存异常) 数据类型: 不要使用比需求更占用空间的基本数据类型 循环尽量用 foreach ,少用 iterator, 自动装箱也尽量少用 数据结构与算法的解度处理 (数组，链表，栈树，树，图) 数据量千级以内可以使用 Sparse 数组 (Key为整数)，ArrayMap (Key 为对象) 虽然性能不如 HashMap ，但节约内存。 枚举优化 缺点: 每一个枚举值都是一个单例对象,在使用它时会增加额外的内存消耗,所以枚举相比与 Integer 和 String 会占用更多的内存 较多的使用 Enum 会增加 DEX 文件的大小,会造成运行时更多的 IO 开销,使我们的应用需要更多的空间 特别是分 Dex 多的大型 APP，枚举的初始化很容易导致 ANR 优化后的代码:可以直接限定传入的参数个数 1234567891011121314151617181920212223public class SHAPE { public static final int TYPE_0=0; public static final int TYPE_1=1; public static final int TYPE_2=2; public static final int TYPE_3=3; @IntDef(flag=true,value={TYPE_0,TYPE_1,TYPE_2,TYPE_3}) @Target({ElementType.PARAMETER,ElementType.METHOD,ElementType.FIELD}) @Retention(RetentionPolicy.SOURCE) public @interface Model{ } private @Model int value=TYPE_0; public void setShape(@Model int value){ this.value=value; } @Model public int getShape(){ return this.value; }} static , static final 的问题 static 会由编译器调用 clinit 方法进行初始化 static final 不需要进行初始化工作，打包在 dex 文件中可以直接调用，并不会在类初始化申请内存 基本数据类型的成员，可以全写成 static final 字符串的拼接尽量少用 += 重复申请内存问题 同一个方法多次调用，如递归函数 ，回调函数中 new 对象 不要在 onMeause() onLayout() ,onDraw() 中去刷新UI（requestLayout） 避免 GC 回收将来要重新使用的对象 (内存设计模式对象池 + LRU 算法) Activity 组件泄漏 非业务需要不要把 activity 的上下文做参数传递，可以传递 application 的上下文 非静态内部类和匿名内部内会持有 activity 引用（静态内部类 或者 单独写文件） 单例模式中回调持有 activity 引用（弱引用） handler.postDelayed() 问题 如果开启的线程需要传入参数，用弱引接收可解决问题 handler 记得清除 removeCallbacksAndMessages(null) Service 耗时操作尽量使用 IntentService,而不是 Service","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%89-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"},{"title":"性能优化 (五)  长图优化","text":"长图优化现在市面上 95 % 以上，APP 都有预览图片的功能，那么是怎么做的勒，今天我们就来仿照 微博 预览长图，来对长图优化。 怎么使用代码传送阵 project/build.gradle 123456allprojects { repositories { ... maven { url 'https://jitpack.io' } }} app/build.gradle 123dependencies { implementation 'com.github.yangkun19921001:long_picture_view:1.0.1' } xml 中直接使用 12345&lt;com.yk.big_picture_library.BigView android:id=\"@+id/bv_img\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; 代码中 12345BigView bigView=findViewById(R.id.bv_img);//加载路径bigView.setImage(BIG_IMAGE_PAHT);//加载 InputStreambigView.setImage(InputStream is) 效果对比微博长图效果 仿照微博预览长图效果 效果是不是很丝滑，原图是 12 M 压缩后不到 2 M ，加载前可以压缩下，我用的是我自己的另一个图片压缩开源项目利用哈夫曼算法对图片压缩。 内存使用状态 内存无泄漏，无抖动，无溢出 。这里在提一下如果对内存优化不了解的可以看下性能优化(三)… Java 堆内存: 5 - 6 M 之间 Native 占用内存: 25 M 左右 解决思路 粗略步骤: 沿着对角线缩放 加载屏幕能够看见的区域 复用上一个 bitmap 区域的内存 处理滑动 详细步骤 定义 Rect 图片需要加载的区域 定义图片复用 BitmapFactory.Options() 定义手势识别 GestureDetector 上下左右滑动的帮助类 定义一个滑动帮组类 Scroller 加载图片信息并不是加载真正的图片 开启内存复用功能 创建一个区域解码器，只解码一部分。 刷新 requestLayout 确定加载图片的区域，计算缩放比列 onDraw 绘制区域图片 将图片区域缩放得到 View 的大小 drawBitmap 绘制图片 处理滑动事件交给手势处理 随着手指滑动改变现实区域 Rect，判断头部底部界限 invalidate 不断重绘 onFling , computeScroll 处理惯性问题 invalidate 不断重绘","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%94-%E9%95%BF%E5%9B%BE%E4%BC%98%E5%8C%96/"},{"title":"性能优化 (七) 体积优化之混淆技术","text":"ProGuardProGuard 是什么？可以把 ProGuard 理解为是对代码和资源压缩的一个工具，它能够提供对 Java 类文件的压缩、优化、混淆，和预校验。压缩的步骤是检测并移除未使用的类、字段、方法和属性。优化的步骤是分析和优化方法的字节码。混淆的步骤是使用短的毫无意义的名称重命名剩余的类、字段和方法。压缩、优化、混淆使得代码更小，更高效。 AndroidStudio 怎么使用 ProGuard ？代码压缩要通过 ProGuard 启用代码压缩，请在 build.gradle 文件内相应的构建类型中添加 minifyEnabled true。 123456789android { ... buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } ProGuard 会移除所有 (并且只会移除) 未使用的代码。不过 , ProGuard 难以对许多情况进行正确分析，可能会移除应用真正需要的代码。比如需要反射、动态加载所引用的类等情况，可能因为ProGuard 移除或者混淆了这部分没使用的类，而导致错误。所以有时需要编写混淆优化配置文件。在 gradle 中的 proguardFiles 能够让我们传递File文件或者文件路径交给 proguard 来执行。 配置 ProGuard 规则现在我们开启了混淆，但是还没有配置混淆，我们可以在 build/intermediates/proguard-files/proguard-defaults.txt 来查看默认的配置，现在我们可以根据默认的配置来进行我们项目的配置。 分析默认配置文件 proguard-defaults.txt-3.4.0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139# This is a configuration file for ProGuard.# http://proguard.sourceforge.net/index.html#manual/usage.html## Starting with version 2.2 of the Android plugin for Gradle, this file is distributed together with# the plugin and unpacked at build-time. The files in $ANDROID_HOME are no longer maintained and# will be ignored by new version of the Android plugin for Gradle.# Optimizations can be turned on and off in the 'postProcessing' DSL block.# The configuration below is applied if optimizations are enabled.# Adding optimization introduces certain risks, since for example not all optimizations performed by# ProGuard works on all versions of Dalvik. The following flags turn off various optimizations# known to have issues, but the list may not be complete or up to date. (The \"arithmetic\"# optimization can be used if you are only targeting Android 2.0 or later.) Make sure you test# thoroughly if you go this route.####################### START ######################## 混淆时所采用的算法(谷歌推荐算法)-optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/*# 指定代码的压缩级别(在0~7之间，默认为5)-optimizationpasses 5# 提高优化步骤-allowaccessmodification# 包名不混合大小写-dontusemixedcaseclassnames# 不忽略非公共的库类-dontskipnonpubliclibraryclasses# 输出混淆日志-verbose# 保持 Google 原生服务需要的类不被混淆-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService-keep public class com.google.android.vending.licensing.ILicensingService-dontnote com.android.vending.licensing.ILicensingService-dontnote com.google.vending.licensing.ILicensingService-dontnote com.google.android.vending.licensing.ILicensingService# For native methods, see http://proguard.sourceforge.net/manual/examples.html#native# 混淆注意事项第二条，保持 native 方法不被混淆-keepclasseswithmembernames class * { native &lt;methods&gt;;}# Keep setters in Views so that animations can still work.# 保留自定义控件(继承自View)不被混淆-keepclassmembers public class * extends android.view.View { void set*(***); *** get*();}# We want to keep methods in Activity that could be used in the XML attribute onClick.# 保留在 Activity 中的方法参数是 view 的方法(避免布局文件里面 onClick 被影响)-keepclassmembers class * extends android.app.Activity { public void *(android.view.View);}# For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations# 保持枚举 enum 类不被混淆-keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String);}# 保持 Parcelable 序列化的类不被混淆(注：aidl 文件不能去混淆)-keepclassmembers class * implements android.os.Parcelable { public static final ** CREATOR;}# 保持R(资源)下的所有类及其方法不能被混淆-keepclassmembers class **.R$* { public static &lt;fields&gt;;}# Preserve annotated Javascript interface methods.-keepclassmembers class * { @android.webkit.JavascriptInterface &lt;methods&gt;;}# 支持库包含对较新版本版本的引用。# 不要警告那些情况下,这个应用程序链接到旧的# 平台版本。我们知道他们是安全的。-dontnote android.support.**-dontnote androidx.**-dontwarn android.support.**-dontwarn androidx.**# 此类已弃用,但仍保留向后兼容性。-dontwarn android.util.FloatMath# Support包规则# Understand the @Keep support annotation.-keep class android.support.annotation.Keep-keep class androidx.annotation.Keep-keep @android.support.annotation.Keep class * {*;}-keep @androidx.annotation.Keep class * {*;}# 保持 support Keep 类成员不被混淆-keepclasseswithmembers class * { @android.support.annotation.Keep &lt;methods&gt;;}# 保持 androidx Keep 类成员不被混淆-keepclasseswithmembers class * { @androidx.annotation.Keep &lt;methods&gt;;}# 保持 support Keep 类成员不被混淆-keepclasseswithmembers class * { @android.support.annotation.Keep &lt;fields&gt;;}# 保持 androidx Keep 类成员不被混淆-keepclasseswithmembers class * { @androidx.annotation.Keep &lt;fields&gt;;}# 不混淆所有类及其类成员中的使用注解的初始化方法-keepclasseswithmembers class * { @android.support.annotation.Keep &lt;init&gt;(...);}# 不混淆所有类及其类成员中的使用注解的初始化方法-keepclasseswithmembers class * { @androidx.annotation.Keep &lt;init&gt;(...);}# 排除 android.jar 和 org.apache.http.legacy.jar 之间重复-dontnote org.apache.http.**-dontnote android.net.http.**# 排除 android.jar 和核心-lambda-stubs.jar 之间重复。-dontnote java.lang.invoke.** 以上就是默认配置文件那么这样生成出来的 APK 到底是什么样的勒？下面放上一张图片来看下。 发现上面的 类 已经变成不易阅读的类了。下面我们就来单独分析下 Proguard 的配置 基本指令 指定代码的压缩级别(在0~7之间，默认为5) 1-optimizationpasses 5 是否使用大小写混合(windows大小写不敏感，建议加入) 1-dontusemixedcaseclassnames 是否混淆非公共的库的类 1-dontskipnonpubliclibraryclasses 是否混淆非公共的库的类的成员 1-dontskipnonpubliclibraryclassmembers 混淆时是否做预校验(Android不需要预校验，去掉可以加快混淆速度) 1-dontpreverify 混淆时是否记录日志(混淆后会生成映射文件) 1-verbose 指定外部模糊字典 1-obfuscationdictionary dictionary_path 指定 class 模糊字典 1-classobfuscationdictionary dictionary_path 指定 package 模糊字典 1-packageobfuscationdictionary dictionary_path 混淆时所采用的算法(谷歌推荐算法) 1-optimizations !code/simplification/arithmetic,!field/,!class/merging/,!code/allocation/variable 添加支持的jar(引入libs下的所有jar包) 1-libraryjars libs(*.jar;) 将文件来源重命名为 SourceFile”`字符串 1-renamesourcefileattribute SourceFile 保持注解不被混淆 123-keepattributes Annotation-keep class * extends java.lang.annotation.Annotation {*;}-keep interface * extends java.lang.annotation.Annotation { *; } 保持泛型不被混淆 1-keepattributes Signature-keep class * extends java.lang.annotation.Annotation {*;} 保持反射不被混淆 1-keepattributes EnclosingMethod 保持异常不被混淆 1-keepattributes Exceptions 保持内部类不被混淆 1-keepattributes InnerClasses 抛出异常时保留代码行号 1-keepattributes SourceFile,LineNumberTable keep 命令说明 指令 说明 -keep 保持类和类成员，防止被移除或者被重命名 -keepnames 保持类和类成员，防止被重命名 -keepclassmembers 保持类成员，防止被移除或者被重命名 -keepclassmembernames 保持类成员，防止被重命名 -keepclasseswithmembers 保持拥有该成员的类和成员，防止被移除或者被重命名 -keepclasseswithmembernames 保持拥有该成员的类和成员，防止被重命名 保持元素不参与混淆的规则的命令格式： 1234567891011121314151617181920[保持命令] [类] { [成员]}具体的类访问修饰符（public、protected、private）通配符*，匹配任意长度字符，但不含包名分隔符(.)通配符**，匹配任意长度字符，并且包含包名分隔符(.)extends，即可以指定类的基类implement，匹配实现了某接口的类$，内部类“成员”代表类成员相关的限定条件，它将最终定位到某些符合该限定条件的类成员。它的内容可以使用：&lt;init&gt; 匹配所有构造器&lt;fields&gt; 匹配所有域&lt;methods&gt; 匹配所有方法通配符*，匹配任意长度字符，但不含包名分隔符(.)通配符**，匹配任意长度字符，并且包含包名分隔符(.)通配符***，匹配任意参数类型…，匹配任意长度的任意类型参数。比如void test(…)就能匹配任意 void test(String a) 或者是 void test(int a, String b) 这些方法。访问修饰符（public、protected、private） 不混淆某个类 1-keep public class com.example.proxy_core.ProxyApplication { *; } 不混淆某个包所有的类 1-keep public class com.example.proxy_core.** { *; } 不混淆某个类的子类 1-keep public class * extends class com.example.proxy_core.ProxyApplication { *; } 不混淆所有类名中包含了 model的类及其成员 1-keep public class **.*model*.** {*;} 不混淆某个接口的实现 1-keep class * implements com.example.proxy_core.LoadCallBack { *; } 不混淆某个类的特定的方法 123-keepclassmembers class com.example.proxy_core.ProxyApplication { public void getVersion(java.lang.String);} 不混淆某个类的内部类 123-keep class com.example.proxy_core.ProxyApplication$* { *;} Proguard 注意事项 基本组件不被混淆 12345678-keep public class * extends android.app.Fragment-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference 保持 Google 原生服务需要的类不被混淆 12-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService Support 包规则 1234-dontwarn android.support.**-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.** 保持 native 方法不被混淆 123-keepclasseswithmembernames class * { native &lt;methods&gt;;} 保留自定义控件 ( 继承自 View ) 不被混淆 1234567-keep public class * extends android.view.View { *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); } 保留指定格式的构造方法不被混淆 1234-keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); } 保留在 Activity 中的方法参数是 view 的方法(避免布局文件里面 onClick 被影响) 123-keepclassmembers class * extends android.app.Activity { public void *(android.view.View);} 保持枚举 enum 类不被混淆 1234-keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String);} 保持 R (资源)下的所有类及其方法不能被混淆 1-keep class **.R$* { *; } 保持 Parcelable 序列化的类不被混淆(注：aidl 文件不能去混淆) 123-keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *;} 需要序列化和反序列化的类不能被混淆(注：Java 反射用到的类也不能被混淆) 1-keepnames class * implements java.io.Serializable 保持 Serializable 序列化的类成员不被混淆 1234567891011-keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();} 保持 Adapter 类不被混淆 1-keep public class * extends android.widget.BaseAdapter { *; } 保持 CusorAdapter 类不被混淆 1-keep public class * extends android.widget.CusorAdapter{ *; } 编写基础通用版本混淆规则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166# This is a configuration file for ProGuard.# http://proguard.sourceforge.net/index.html#manual/usage.html## Starting with version 2.2 of the Android plugin for Gradle, this file is distributed together with# the plugin and unpacked at build-time. The files in $ANDROID_HOME are no longer maintained and# will be ignored by new version of the Android plugin for Gradle.# Optimizations can be turned on and off in the 'postProcessing' DSL block.# The configuration below is applied if optimizations are enabled.# Adding optimization introduces certain risks, since for example not all optimizations performed by# ProGuard works on all versions of Dalvik. The following flags turn off various optimizations# known to have issues, but the list may not be complete or up to date. (The &quot;arithmetic&quot;# optimization can be used if you are only targeting Android 2.0 or later.) Make sure you test# thoroughly if you go this route.# --------------------------------------------基本指令区-------------------------------------------# 指定代码的压缩级别(在0~7之间，默认为5)-optimizationpasses 5# 是否使用大小写混合(windows大小写不敏感，建议加入)-dontusemixedcaseclassnames # 是否混淆非公共的库的类-dontskipnonpubliclibraryclasses# 是否混淆非公共的库的类的成员-dontskipnonpubliclibraryclassmembers# 混淆时是否做预校验(Android不需要预校验，去掉可以加快混淆速度)-dontpreverify# 混淆时是否记录日志(混淆后会生成映射文件)-verbose###################################### 如果有就添加 #############################################指定外部模糊字典-obfuscationdictionary dictionary1.txt#指定class模糊字典-classobfuscationdictionary dictionary1.txt#指定package模糊字典-packageobfuscationdictionary dictionary2.txt########################################################################################## 混淆时所采用的算法(谷歌推荐算法)-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*,!code/allocation/variable# 添加支持的jar(引入libs下的所有jar包)-libraryjars libs(*.jar;)# 将文件来源重命名为“SourceFile”字符串-renamesourcefileattribute SourceFile# 保持注解不被混淆-keepattributes *Annotation*-keep class * extends java.lang.annotation.Annotation {*;}# 保持泛型不被混淆-keepattributes Signature# 保持反射不被混淆-keepattributes EnclosingMethod# 保持异常不被混淆-keepattributes Exceptions# 保持内部类不被混淆-keepattributes Exceptions,InnerClasses# 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable# --------------------------------------------默认保留区--------------------------------------------## 保持基本组件不被混淆-keep public class * extends android.app.Fragment-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference# 保持 Google 原生服务需要的类不被混淆-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService# Support包规则-dontwarn android.support.**-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.**# 保持 native 方法不被混淆-keepclasseswithmembernames class * { native &lt;methods&gt;;}# 保留自定义控件(继承自View)不被混淆-keep public class * extends android.view.View { *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);}# 保留指定格式的构造方法不被混淆-keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);}# 保留在Activity中的方法参数是view的方法(避免布局文件里面onClick被影响)-keepclassmembers class * extends android.app.Activity { public void *(android.view.View);}# 保持枚举 enum 类不被混淆-keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String);}# 保持R(资源)下的所有类及其方法不能被混淆-keep class **.R$* { *; }# 保持 Parcelable 序列化的类不被混淆(注：aidl文件不能去混淆)-keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *;}# 需要序列化和反序列化的类不能被混淆(注：Java反射用到的类也不能被混淆)-keepnames class * implements java.io.Serializable# 保持 Serializable 序列化的类成员不被混淆-keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();}# 保持 BaseAdapter 类不被混淆-keep public class * extends android.widget.BaseAdapter { *; }# 保持 CusorAdapter 类不被混淆-keep public class * extends android.widget.CusorAdapter{ *; }# --------------------------------------------webView区--------------------------------------------## WebView处理，项目中没有使用到webView忽略即可# 保持Android与JavaScript进行交互的类不被混淆-keep class **.AndroidJavaScript { *; }-keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView,java.lang.String,android.graphics.Bitmap); public boolean *(android.webkit.WebView,java.lang.String);}-keepclassmembers class * extends android.webkit.WebChromeClient { public void *(android.webkit.WebView,java.lang.String);}# 网络请求相关-keep public class android.net.http.SslError# --------------------------------------------删除代码区--------------------------------------------## 删除代码中Log相关的代码-assumenosideeffects class android.util.Log { public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...);} 第三方需要的混淆规则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184################alipay###############-keep class com.alipay.android.app.IAlixPay{*;}-keep class com.alipay.android.app.IAlixPay$Stub{*;}-keep class com.alipay.android.app.IRemoteServiceCallback{*;}-keep class com.alipay.android.app.IRemoteServiceCallback$Stub{*;}-keep class com.alipay.sdk.app.PayTask{ public *;}-keep class com.alipay.sdk.app.AuthTask{ public *;}################retrofit###############-dontwarn retrofit2.**-keep class retrofit2.** { *; }-keepattributes Signature-keepattributes Exceptions################butterknife###############-keep class butterknife.** { *; }-dontwarn butterknife.internal.**-keep class **$$ViewBinder { *; }-keepclasseswithmembernames class * { @butterknife.* &lt;fields&gt;;}-keepclasseswithmembernames class * { @butterknife.* &lt;methods&gt;;}################gson###############-keepattributes Signature-keepattributes *Annotation*-keep class sun.misc.Unsafe { *; }-keep class com.google.gson.stream.** { *; }# Application classes that will be serialized/deserialized over Gson-keep class com.sunloto.shandong.bean.** { *; }################glide###############-keep public class * implements com.bumptech.glide.module.AppGlideModule-keep public class * implements com.bumptech.glide.module.LibraryGlideModule-keep class com.bumptech.glide.** { *; }-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** { **[] $VALUES; public *;}################okhttp###############-keepattributes Signature-keepattributes *Annotation*-keep class com.squareup.okhttp.** { *; }-keep interface com.squareup.okhttp.** { *; }-keep class okhttp3.** { *; }-keep interface okhttp3.** { *; }-dontwarn com.squareup.okhttp.**################androidEventBus###############-keep class org.simple.** { *; }-keep interface org.simple.** { *; }-keepclassmembers class * { @org.simple.eventbus.Subscriber &lt;methods&gt;;}-keepattributes *Annotation*################EventBus###############-keepclassmembers class * { @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;}-keep class org.greenrobot.eventbus.EventBus { *; }-keep enum org.greenrobot.eventbus.ThreadMode { *; }-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent { &lt;init&gt;(java.lang.Throwable);}################autolayout###############-keep class com.zhy.autolayout.** { *; }-keep interface com.zhy.autolayout.** { *; }################RxJava and RxAndroid###############-dontwarn org.mockito.**-dontwarn org.junit.**-dontwarn org.robolectric.**-keep class io.reactivex.** { *; }-keep interface io.reactivex.** { *; }-keepattributes Signature-keepattributes *Annotation*-keep class com.squareup.okhttp.** { *; }-dontwarn okio.**-keep interface com.squareup.okhttp.** { *; }-dontwarn com.squareup.okhttp.**-dontwarn io.reactivex.**-dontwarn retrofit.**-keep class retrofit.** { *; }-keepclasseswithmembers class * { @retrofit.http.* &lt;methods&gt;;}-keep class sun.misc.Unsafe { *; }-dontwarn java.lang.invoke.*-keep class io.reactivex.schedulers.Schedulers { public static &lt;methods&gt;;}-keep class io.reactivex.schedulers.ImmediateScheduler { public &lt;methods&gt;;}-keep class io.reactivex.schedulers.TestScheduler { public &lt;methods&gt;;}-keep class io.reactivex.schedulers.Schedulers { public static ** test();}-keepclassmembers class io.reactivex.internal.util.unsafe.*ArrayQueue*Field* { long producerIndex; long consumerIndex;}-keepclassmembers class io.reactivex.internal.util.unsafe.BaseLinkedQueueProducerNodeRef { long producerNode; long consumerNode;}-keepclassmembers class io.reactivex.internal.util.unsafe.BaseLinkedQueueProducerNodeRef { io.reactivex.internal.util.atomic.LinkedQueueNode producerNode;}-keepclassmembers class io.reactivex.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef { io.reactivex.internal.util.atomic.LinkedQueueNode consumerNode;}-dontwarn io.reactivex.internal.util.unsafe.**################espresso###############-keep class android.support.test.espresso.** { *; }-keep interface android.support.test.espresso.** { *; }################annotation###############-keep class android.support.annotation.** { *; }-keep interface android.support.annotation.** { *; }################RxLifeCycle#################-keep class com.trello.rxlifecycle2.** { *; }-keep interface com.trello.rxlifecycle2.** { *; }################RxPermissions#################-keep class com.tbruyelle.rxpermissions2.** { *; }-keep interface com.tbruyelle.rxpermissions2.** { *; }################RxCache#################-dontwarn io.rx_cache2.internal.**-keep class io.rx_cache2.internal.Record { *; }-keep class io.rx_cache2.Source { *; }-keep class io.victoralbertos.jolyglot.** { *; }-keep interface io.victoralbertos.jolyglot.** { *; }################RxErrorHandler################# -keep class me.jessyan.rxerrorhandler.** { *; } -keep interface me.jessyan.rxerrorhandler.** { *; }################Timber#################-dontwarn org.jetbrains.annotations.**################Canary#################-dontwarn com.squareup.haha.guava.**-dontwarn com.squareup.haha.perflib.**-dontwarn com.squareup.haha.trove.**-dontwarn com.squareup.leakcanary.**-keep class com.squareup.haha.** { *; }-keep class com.squareup.leakcanary.** { *; }# Marshmallow removed Notification.setLatestEventInfo()-dontwarn android.app.Notification 混淆后的代码错误栈恢复方法 把 outputs/mapping/debug/mapping.txt 文件保存 (保存了混淆前后的对应关系)。 使用工具 sdk/tools/groguard/bin/retrace.bat先配置 -keepattributes SourceFile,LineNumberTable再执行 retrace.bat -verbose mappint 文件 bug 文件 资源压缩资源压缩只与代码压缩协同工作。代码压缩器移除所有未使用的代码后，资源压缩器便可确定应用仍然使用的资源。这在您添加包含资源的代码库时体现得尤为明显 - 您必须移除未使用的库代码，使库资源变为未引用资源，才能通过资源压缩器将它们移除 要启用资源压缩，请在 build.gradle 文件中将 shrinkResources 属性设置为 true（在用于代码压缩的 minifyEnabled 旁边）。例如： 1234567891011android { ... buildTypes { release { shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } }} 如果您尚未使用代码压缩用途的 minifyEnabled 构建应用，请先尝试使用它，然后再启用 shrinkResources，因为您可能需要编辑 proguard-rules.pro 文件以保留动态创建或调用的类或方法，然后再开始移除资源。 移除未使用的备用资源 移除仅支持中文和英语 123456android { defaultConfig { ... resConfigs \"zh\",\"en\" }} 合并重复资源 默认情况下，Gradle 还会合并同名资源，例如可能位于不同资源文件夹中的同名可绘制对象。这一行为不受 shrinkResources 属性控制，也无法停用，因为在有多个资源匹配代码查询的名称时，有必要利用这一行为来避免错误。 只有在两个或更多个文件具有完全相同的资源名称、类型和限定符时，才会进行资源合并。Gradle 会在重复项中选择其视为最佳选择的文件（根据下述优先顺序），并只将这一个资源传递给 AAPT，以供在 APK 文件中分发。 Gradle 会在下列位置寻找重复资源： 与主源集关联的主资源，一般位于 src/main/res/ 中。 变体叠加，来自构建类型和构建风味。 库项目依赖项。 Gradle 会按以下级联优先顺序合并重复资源： 依赖项 → 主资源 → 构建风味 → 构建类型 例如，如果某个重复资源同时出现在主资源和构建风味中，Gradle 会选择构建风味中的重复资源。 如果完全相同的资源出现在同一源集中，Gradle 无法合并它们，并且会发出资源合并错误。如果您在 build.gradle 文件的 sourceSet 属性中定义了多个源集，则可能会发生这种情况，例如，如果 src/main/res/ 和 src/main/res2/ 包含完全相同的资源，就可能会发生这种情况。 排查资源压缩问题 当您压缩资源时，Gradle Console 会显示它从应用软件包中移除的资源的摘要。例如： 1:android:shrinkDebugResources Removed unused resources: Binary resource data reduced from 2570KB to 1711KB: Removed 33% :android:validateDebugSigning Gradle 还会在 &lt;module-name&gt;/build/outputs/mapping/release/（ProGuard 输出文件所在的文件夹）中创建一个名为 resources.txt 的诊断文件。该文件包括诸如哪些资源引用了其他资源以及使用或移除了哪些资源等详情。 感谢:压缩代码和资源","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83-%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96%E4%B9%8B%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/"},{"title":"性能优化 (六) 电量优化","text":"电量优化 - battery-historian简介现在基本上都是人手一部智能手机，你可以发现不管走在街上，公交地铁上，等等任何娱乐办公地方，随处可见有人正在低着头玩手机，有的还随身携带充电宝。由此可见，现在智能手机的电量有多么的不经用，当然我们是优化不了电池的，不过我们可以从 APP 中着手优化，我相信一线大厂也有自己电量分析工具，我相信只要是能够分析电量的工具，都是好工具 (^▽^)。那么该我们的主角上场了 Google 开源电量分析工具 battery-historian 下面就让我们一起来了解下 BatteryHistonian 吧！ Battery-HistorianBattery Historian 背景Battery Historian 是在运行 Android 5.0 Lollipop（API级别21）及更高版本的 Android 设备上检查电池相关信息和事件的工具，而设备未插入。它允许应用程序开发人员在时间线上可视化系统和应用程序级事件通过平移和缩放功能，可以轻松查看自设备上次完全充电以来的各种汇总统计信息，并选择一个应用程序并检查影响所选应用程序特定电池的指标。 它还允许对两个错误报告进行A / B比较，突出显示关键电池相关指标的差异 Battery Historian 安装Battery Historian 安装是一个复杂的工程，需要配置一大堆的环境。不过官方给咱们提供了 2 中安装方式，下面让我们一起来了解下吧。 快速安装 - 百度云 battery historian 源码及 JS 环境 ：https://pan.baidu.com/s/1D3Guq0WWhTSo7roBxFC-UA提取码：g1cx 使用方式： 解压在 GO 的 $GOPATH/目录 执行 5.2 -&gt; 5.4 步骤 IE 浏览器 或者 Google 浏览器输入 http://localhost:9999/ win10 源码安装 (推荐)源码安装虽然配置的环境很多，但是用起来还是比较稳定，下面就跟我的步伐来一起安装吧。 安装配置 GO 语言 科学上网下载 或者 使用我下载好的 提取码：nh8p 安装 注意更改路径 配置环境 系统变量中新建 GOROOT GOPATH 变量，然后配置 Path 环境变量 检查是否安装成功 在 cmd 命令行中输入 go version 查看是否成功安装及当前版本 python 安装 由于 historian.py 脚本是 python2 写的，所以需要安装 python2.7 环境。 下载安装: https://www.python.org/ 云盘提供安装: https://pan.baidu.com/s/103GXARgc4vIUFgFlVKnrNg 提取码：sm8p 官网下载 2.7 版本 安装 py 配置环境 检验 root 权限输入 python -V 显示版本号，就说明安装成功了 配置 JAVA 环境 这个就自己百度配置了哈。 配置 Git 环境 这个也自己百度吧，很简单。 下载 Battery Historian 源码 在 Git Bash 中输入命令 go get -d -u github.com/google/battery-historian/…（即下载到GOPATH配置目录下） 进入到$GOPATH/src/github.com/google/battery-historian目录下 运行 Battery Historian：输入命令行 go run setup.go 运行 Battery Historian.go 在 battery-historian 目录下执行 go run cmd/battery-historian/battery-historian.go 浏览器输入 http://localhost:9999 MAC 源码安装(推荐)安装步骤跟 win 一样，下面直接介绍 mac 下的 battery historian 需要的环境配置 Go 环境配置 vim .brash_profile 配置 go 环境 保存编辑的环境 1sorce .brash_profile Docker 安装docker 我这里就粗略的说下，因为在 win10 下安装 坑太多了。还有点不稳定，导致最后使用 源码安装。 准备工作 官网下载 Docker : https://docs.docker.com/engine/installation/ win 10 家庭版本缺少 Hyper-V 组件需升级企业版密码钥匙也可以百度: NPPR9-FWDCX-D2C8J-H872K-2YT43 安装 Docker for Windows Installer 安装步骤直接下一步，安装过程中会出现自动重启电脑。 命令输入运行 docker 1docker run --name=battery -d -p 9999:9999 bhaavan/battery-historian 验证: 在浏览器上输入 http://localhost:9999 注意： 如果 win10 企业版安装失败，可以看看官网提示 如果升级了企业版 那么 VMware 虚拟机用不了，下面给出解决办法。 关闭 Hyper-V 组件 1bcdedit /set hypervisorlaunchtype off 开启 1bcdedit /set hypervisorlaunchtype auto Battery Historian 使用及数据分析adb 对手机的操作 重置内部数据，相当于清空 1adb shell dumpsys batterystats --reset 获取完整的 wakelock 信息 1adb shell dumpsys batterystats --enable full-wake-history 拔掉 USB 等待一段时间建议长一点，现在随意使用 APP 获得电量报告 1234567// &gt; 6.0adb bugreport bugreport.zip// &lt;= 6.0adb bugreport &gt; bugreport.txt//导出adb pull /data/user_de/0/com.android.shell/files/bugreports/bugreport-ALP-AL00-HUAWEIALP-AL00-2020-03-25-16-39-20.zip [导出目录] 提交电量报告，并查看 数据参数详细说明 WakeLock 级别 PARTIAL_WAKE_LOCK: 保证 CPU 保持高性能运行，而屏幕和键盘背光（也可能是触摸按键的背光）关闭。一般情况下都会使用这个 WakeLock 。 ACQUIRE_CAUSES_WAKEUP: 这个WakeLock除了会使 CPU 高性能运行外还会导致屏幕亮起，即使屏幕原先处于关闭的状态下。 ON_AFTER_RELEASE: 如果释放 WakeLock 的时候屏幕处于亮着的状态，则在释放WakeLock 之后让屏幕再保持亮一小会。如果释放 WakeLock 的时候屏幕本身就没亮，则不会有动作。 API17 被弃用的 WakeLock：保持屏幕长亮 SCREEN_DIM_WAKE_LOCK：保证屏幕亮起，但是亮度可能比较低。同时键盘背光也可以不亮。 SCREEN_BRIGHT_WAKE_LOCK ：保证屏幕全亮，同时键盘背光也亮。 FULL_WAKE_LOCK：表现和SCREEN_BRIGHT_WAKE_LOCK 类似，但是区别在于这个等级的WakeLock使用的是最高亮度 &lt;!--￼7--&gt; 剩下参数由表格说明 参数 说明 CPU runing cpu 运行的状态, 是否被唤醒 Kernel only uptime 只有内核运行时间 Activity Manager Proc 活跃的用户进程 Mobile network type 网络类型 Mobile radio active 移动蜂窝信号 比 wiff 耗电 Crashes(logcat) Crashes(logcat) 某个时间点出现 crash 的应用 Doze 是否进入doze 模式 JobScheduler 异步作业调度,延迟操作，父类 Service SyncManager 同步操作 Temp White List 电量优化白名单 Phone call 是否打电话 GPS 是否使用 GPS Network connectivity 网络连接状态 (wifi、mobile是否连接) Mobile signal strength 移动信号强度 (great\\good\\moderate\\poor) Wifi scan 是否在扫描 wifi 信号 Wifi supplicant 是否有 wifi 请求 Wifi radio 是否正在通过 wifi 传输数据 Wifi running wifi 组件是否在工作(未传输数据) Wifi on wifi 组件是否在工作(未传输数据) Audio 音频是否开启 Camera 相机是否在工作 Video 是否在播放视频 Foreground process 前台进程 Package install 是否在进行包安装 Package active 包管理在工作 Battery level 电池当前电量 Temperature 电池温度 Logcat misc 是否在导出日志 Plugged 是否是充电状态 当前 APP Stats 分析当前 APP 电量详细信息 从上图可以看出 早上 11:00 - 下午 12: 00 这一个小时内电量下降的最快，耗电量最多的罪魁祸首就是 GPS 和 wakelock 在 APP Stats -&gt; Device estimated power 中可以查看在这一小时耗电时常，（由上图 Battery Level 得知电量变化过程是 69 - 61 ，1h 下降 8 ）APP 1h 耗电为 5.38 % 还是挺耗电的。 当前 APP 优化建议: GPS ：GPS 可以间断获取，或者使用第三方(高德、百度)它们提供省电模式定位，有 wiff 地方切换 wif 定位，少用 高精准定位模式。 网络连接: 有 wiff 地方建议切换 wiff wakelock : 尽量不要使用。 总结-优化方案1. 加入电量优化白名单 123456789101112131415161718192021222324252627/** * 加入电量白名单 * * @param activity * @param type 1: 启动 设置页面 2：触发系统对话框 */ public static void addWhite(Activity activity, int type) { if (activity == null)return; WeakReference&lt;Activity&gt; activityWeakReference = new WeakReference&lt;Activity&gt;(activity); PowerManager packageManager = (PowerManager) activityWeakReference.get().getApplication() .getSystemService(Context.POWER_SERVICE); //应用是否在 白名单中 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { if (!packageManager.isIgnoringBatteryOptimizations(activityWeakReference.get().getApplication().getPackageName())) { if (type == 1) { //方法1、启动一个 ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS Intent Intent intent = new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS); activityWeakReference.get().getApplication().startActivity(intent); } else { //方法2、触发系统对话框 Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse(\"package:\" + activityWeakReference.get().getApplication().getPackageName())); activityWeakReference.get().getApplication().startActivity(intent); } } } } 2. GPS 优化建议定位是 App 中常用的功能，但是定位不能千篇一律，不同的场景以及不同类型的 App 对定位更加需要个性化的区分。 选择合适的 Location ProviderAndroid系统支持多个 Location Provider： GPS_PROVIDER:GPS 定位，利用 GPS 芯片通过卫星获得自己的位置信息。定位精准度高，一般在 10 米左右，耗电量大；但是在室内，GPS 定位基本没用。 NETWORK_PROVIDER：网络定位，利用手机基站和 WIFI 节点的地址来大致定位位置，这种定位方式取决于服务器，即取决于将基站或 WIFI 节点信息翻译成位置信息的服务器的能力。 PASSIVE_PROVIDER:被动定位，就是用现成的，当其他应用使用定位更新了定位信息，系统会保存下来，该应用接收到消息后直接读取就可以了。比如如果系统中已经安装了百度地图，高德地图(室内可以实现精确定位)，你只要使用它们定位过后，再使用这种方法在你的程序肯定是可以拿到比较精确的定位信息。 使用 Criteria，设置合适的模式、功耗、海拔、速度等需求，系统会返回合适的 Location Provider。例如你的 App 只是需要一个粗略的定位那么就不需要使用 GPS 进行定位，既耗费电量，定位的耗时也久。 及时注销定位监听在获取到定位之后或者程序处于后台时，注销定位监听，此时监听GPS传感器相当于执行no-op（无操作指令），用户不会有感知但是却耗电。 123456//如果对定位要求不那么严格的话 可以在关闭屏幕的时候可以暂停 public void onPause() { super.onPause(); if(locationManager != null) locationManager.removeListener() } 多模块使用定位尽量复用多个模块使用定位，尽量复用上一次的结果，而不是都重新走定位的过程，节省电量损耗；例如：在应用启动的时候获取一次定位，保存结果，之后再用到定位的地方都直接去取。 3.网络切换建议 上传下载尽量用 WIFI1234//优化方案 二 ：网络数据切换 if (!BatteryUtils.isPlugged(getApplicationContext())){ //如果没有充电，提醒用户是否有可用 wiff } 4. WakeLock 亮屏，唤醒 CPU 建议 亮屏替换者 12345//在Activity中： getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);//或在布局中添加这个属性：android:keepScreenOn=\"true\" alarm 闹钟让 CPU 间断式工作 123456789101112131415161718192021222324252627/** * 开启一个闹钟 * @param context * @param action * @param requestId * @param interval */public static void startTimer(Context context,String action,int requestId,int interval) { Intent intent = new Intent(action); PendingIntent sender = PendingIntent.getBroadcast(context, requestId, intent, PendingIntent.FLAG_CANCEL_CURRENT); AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); Calendar calendar = Calendar.getInstance(); int second = calendar.get(Calendar.SECOND); //延迟一分钟执行 int delay = 60 - second + 1; calendar.add(Calendar.SECOND, delay); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { String format = new SimpleDateFormat(\"HH:mm:ss\", Locale.CHINA).format(calendar.getTimeInMillis()); Log.d(\"下次闹钟执行的时间--》\",\"delay: \" + delay +\", startMillis: \" +format); alarmManager.setWindow(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), 100, sender); } else { alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), interval, sender); }} 5. JobScheduler (Service 替代者。 8.0 以后 Google 推荐使用) 把工作任务放到合适的时间再去执行，比如充电时间，wifi 连接后 也可以把多个任务合并到一起，再选择时间去执行 1234567891011121314151617181920//需求 现在我需要在充电的状态下并且连接上 wiff 在上传 gps 数据//jobScheduler 会自动把数据添加到一个队列中//存入数据 @Override public int enqueue(JobInfo job, JobWorkItem work) { try { return mBinder.enqueue(job, work); } catch (RemoteException e) { return JobScheduler.RESULT_FAILURE; } }//在适当的时候取出所有数据 @Override public List&lt;JobInfo&gt; getAllPendingJobs() { try { return mBinder.getAllPendingJobs(); } catch (RemoteException e) { return null; } } 也许有的对这个 jobSchedler 合并任务执行还不是那么清晰，现在看一个录屏 在充电并且连接 wiff 的状态下发送数据（这里旋转屏幕是为了发送数据用的）。 先说一下演示流程 连接 wiff + 充电 正常发送数据 关闭 wiff 发送数据，在打开 wiff 合并发送数据 到这里 咱们电量优化讲的差不多了 最后实际优化了 2% 下去。也还是不错的了。 代码传送阵 总结","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%85%AD-%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/"},{"title":"性能优化 (十一) 稳定运行优化之热修复原理探索","text":"完整代码传送阵 热修复的由来 刚发布的版本出现了严重的 bug ,需要开发者去解决 bug，然后在测试打包重新发布，这会耗费大量的人力，物力，代价比较大。 如果当前的 bug 不影响用户使用也不会崩溃，但是了下个版本是大版本，那么两个版本之间间隔时间会很长，这样要等到下个大版本发布在修复 bug , 而之前版本的 bug 还存在，虽说不影响使用，但是是一个潜在的 bug。 版本升级率不高，并且需要长时间来完成版本迭代，前版本的 bug 就会一直影响不升级的用户。 有一些小但是很重要的功能需要在短时间内完成版本迭代，如果假日活动。 ..等等, 这里只是拿几个常见的举例说明。 热修复的效率 热修复框架对比 框架名称 所属公司 是否开源 修复方式 Dexposed alibaba 开源 实时修复 Andfix alibaba 开源 实时修复 Hotfix alibaba 暂未开源 实时修复 Qzone 超级补丁 QQ 空间 暂未开源 冷启动修复 QFix 手 Q 团队 开源 冷启动修复 Robust 美团 开源 实时修复 Nuwa 大众点评 开源 冷启动修复 RocooFix 百度金融 开源 冷启动修复 Aceso 美丽说蘑菇街 开源 实时修复 Amigo 饿了么 开源 冷启动修复 Tinker 微信 开源 冷启动修复 Sophix alibaba 未开源 实时修复 + 冷启动修复 代码修复（今日主题 - 类加载方式）底层替换方式 在已加载的类中直接替换原有方法，是在原有类的基础上进行修改，无法实现对原有类进行方法和字段的增减，这样会破坏原有类的结构。 不稳定。直接修改 JVM 方法实体的具体字段来实现的。Android 是开源的，不同的手机厂商开源对代码进行修改，所以像 Andfix 就会出现在部分机型上的修复失败的现象。 ClassLoader 类加载方式 APP 重新启动后，让 ClassLoader 去加载新的类。 class 暂未被加载到系统中，收到推送利用插桩原理让 ClassLoader 优先加载修复好的 dex 。 实现自己的热修复框架Dex 分包65536 限制 1com.android.dex.DexIndexOverflowException: method ID not in [0, 0xffff]: 65536 当应用程序报 65536 错误的根本原因是，应用的方法数量超过了最大数 65536 个，因为 DVM Bytecode 的限制， DVM 指令集的方法调用指令 invoke-kind 索引为 16 bits, 最多能引用 65535 个方法 LinearAlloc 限制 1INSTALL_FAILED_DEXOPT 在安装应用时可能会提示 上面的错误，产生的原因是 LinearAlloc 限制。 DVM 中的 LinearAlloc 是一个固定的缓存区，当方法数超出缓存区的大小时会报错。 解决 为了解决 65536 限制和 LinearAlloc 限制，从而产生了 Dex 分包机制。Dex 分包方案主要做的时在打包时将应用代码分成多个 Dex，将应用启动时必须用到的类和这些类的直接引用类放到主 Dex 中，其它代码放到次 Dex 中。当应用启动时先加载主 Dex，等到应用启动后再动态地加载次Dex，从而缓解了主 Dex 的 65536 限制和 LinearAlloc 限制 gradle 配置 123456789101112131415161718192021222324252627android { compileSdkVersion 26 defaultConfig { applicationId \"com.ykun.hotfix\" minSdkVersion 15 targetSdkVersion 26 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" // 开启分包 multiDexEnabled true // 设置分包配置文件 multiDexKeepFile file('multidex.keep') } dexOptions { javaMaxHeapSize \"4g\" preDexLibraries = false additionalParameters = [ // 配置multidex参数 '--multi-dex', // 多dex分包 '--set-max-idx-number=50000', // 每个包内方法数上限 '--main-dex-list=' + '/multidex.keep', // 打包到主classes.dex的文件列表 '--minimal-main-dex' ] }} 配置 multidex.keep 将指定的 class 放入 class.dex 中 格式： 1234//参考com/ykun/hotfix/BaseActivity.classcom/ykun/hotfix/BaseApplication.classcom/ykun/hotfix/MainActivity.class 效果 什么是插桩？ 源码： 1234567891011121314151617/**遍历需要找到需要加载的 class */ public Class findClass(String name, List&lt;Throwable&gt; suppressed) { for (Element element : dexElements) { DexFile dex = element.dexFile; if (dex != null) { Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) { return clazz; } } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } 插桩原理： 通过源码得知 findClass 是通过遍历 dexElements 来找到 class, 如果我们反射得到 DexPathList 的私有数组 dexElements，我们外部改变这个数组内部顺序索引，将修复好的 dex 放入 [0] 的位置，那么是不是能够优先使用修复好的 dex 勒？ 很明显，是成立的。下面开始撸代码吧。 代码实现 接收来至服务器发来的补丁包，如果修复包已经存在则删除，copy 到私有目录防止用户不小心删除。 1234567891011121314151617181920/**这里模拟已经下载好的 dex 补丁包*/ private void downloadPatch() { //1 从服务器下载dex文件 比如v1.1修复包文件（classes2.dex） File sourceFile = new File(Environment.getExternalStorageDirectory(), \"classes2.dex\"); // 目标路径：私有目录 //getDir(\"odex\", Context.MODE_PRIVATE) data/user/0/包名/app_odex File targetFile = new File(getDir(\"hotfix\", Context.MODE_PRIVATE).getAbsolutePath() + File.separator + \"classes2.dex\"); if (targetFile.exists()) { targetFile.delete(); } try { // 复制dex到私有目录 FileUtils.copyFile(sourceFile, targetFile); Toast.makeText(this, \"Bug 修复成功!\", Toast.LENGTH_SHORT).show(); FixDexUtils.loadFixedDex(this); } catch (IOException e) { e.printStackTrace(); } } 创建修复包的类加载器 DexClassLoader (通过源码得知是继承的 BaseDexClassLoader) 123456789101112131415161718192021/** * 创建类加载器 * * @param context * @param fileDir */private static void createDexClassLoader(Context context, File fileDir) { String optimizedDirectory = fileDir.getAbsolutePath() + File.separator + \"opt_dex\"; File fOpt = new File(optimizedDirectory); if (!fOpt.exists()) { fOpt.mkdirs(); } DexClassLoader classLoader; for (File dex : loadedDex) { //初始化类加载器 classLoader = new DexClassLoader(dex.getAbsolutePath(), optimizedDirectory, null, context.getClassLoader()); //热修复 hotFix(classLoader, context); }} 获取系统的 PathClassLoader 1PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader(); 获取修复包的 dexElements 12Object pathList = ReflectUtils.reflect(myClassLoader).field(\"pathList\").get();Object myDexElements = ReflectUtils.reflect(pathList).field(\"dexElements\").get(); 获取系统的 dexElements 12Object sysPathList = ReflectUtils.reflect(pathClassLoader).field(\"pathList\").get();Object sysDexElements = ReflectUtils.reflect(sysPathList).field(\"dexElements\").get(); 将系统的 dexElements 和 修复包的 dexElements merge 成新的 dexElements 12// 合并，这里利用插桩原理进行合并数组，将修复好的 class2.dex 放入第一位，优先加入就行了Object dexElements = ArrayUtils.combineArray(myDexElements, sysDexElements); 重新赋值给 DexPathList 的 dexElements 属性 12//重新赋值ReflectUtils.reflect(sysPathList).field(\"dexElements\", dexElements); 热修复未来发展如果 热修复 = “黑科技”？ 热修复不同于国内 APP 进程保活这种 “黑科技”，让 app 常驻后台，既耗电又占用内存，浪费很多手机资源。还有 APP 的推送服务，无节操地对用户进行信息轰炸。还有更无节操的全家桶 app。导致 Android手机卡顿不堪，这些所谓的 “黑科技” 都是为了手机厂商的利益而损害用户的体验。 而热修复是能够让开发者和用户双赢的。不仅厂商能快速迭代更新 app，使功能尽快上线，而且热更新过程用户无感知，节省大量更新时间，提高用户体验。更重要的能保证 app 的功能稳定，bug 能及时修复。 IOS 封杀了热修复功能，Android 的热修复也会被 sha 掉吗？ google 和 apple 公司在中国的地位不一样 Android 和 IOS 的开放性不同 热修复未来是十分乐观的，不仅不会受到封杀，反而会有很大发展空间","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%B8%80-%E7%A8%B3%E5%AE%9A%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96%E4%B9%8B%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"},{"title":"性能优化 (十) 稳定运行优化之进程保活实现","text":"简介现在只要是社交 APP 没有哪个开发者不想让自己的 APP 永久常驻的，想要永久常驻除非你们家的实力非常雄厚，APP 用户量非常大，那么厂商都会主动来找你，把你们家的 APP 加入白名单。否则永久常驻是不可能甚至都不给你权限后台运行。既然不能永久常驻，那么我们有没有一个办法可以使我们的 APP 不那么容易被系统杀死勒？或者说是杀死后能主动唤醒，显然是可以的，下面我们进入主题吧。 怎么使用 down 代码 https://github.com/yangkun19921001/KeepAlive.git ，将 live_library 放入自己工程 在 KeepAliveRuning onRuning 中实现需要保活的代码 12345678910111213public class KeepAliveRuning implements IKeepAliveRuning { /**这里实现 Socket / 推送 等一些保活组件*/ @Override public void onRuning() { //TODO-------------------------------------------- Log.e(\"runing?KeepAliveRuning\", \"true\"); } @Override public void onStop() { Log.e(\"runing?KeepAliveRuning\", \"false\"); }} 开启保活 123456789101112131415161718public void start() { //启动保活服务 KeepAliveManager.toKeepAlive( getApplication() , HIGH_POWER_CONSUMPTION, \"进程保活\", \"Process: System(哥们儿) 我不想被杀死\", R.mipmap.ic_launcher, new ForegroundNotification( //定义前台服务的通知点击事件 new ForegroundNotificationClickListener() { @Override public void foregroundNotificationClick(Context context, Intent intent) { Log.d(\"JOB--&gt;\", \" foregroundNotificationClick\"); } }) );} 停止保活 1KeepAliveManager.stopWork(getApplication()); 最终效果开启保活 我们应该知道正常的话点击手机回收垃圾桶后台的应用都会被 kill 掉，还有主动点击 AS Logcat 的进程停止运行的按钮，我们也会发现进程会自动起来并且 pid 跟上一次不一样了。要的就是这种效果，下面我们来了解下进程保活的知识吧. 长时间运行，不被杀死，如果被杀死双进程会启动死掉的进程 未开启保活 代码传送阵 进程优先级官网详细介绍 进程如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。 决定终止哪个进程时，Android 系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 的进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。 下面，我们介绍决定终止进程所用的规则。 进程生命周期Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。 重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）： 名称 概括 回收状态 前台进程 正在交互 只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们 可见进程 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程 可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 服务进程 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。 除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 后台进程 对用户不可见的 Activity 的进程 系统可能随时终止它们 空进程 不含任何活动应用组件的进程 最容易为杀死 LMK(LowMemoryKiller) 为什么引入 LMK ? 进程的启动分冷启动和热启动，当用户退出某一个进程的时候，并不会真正的将进程退出，而是将这个进程放到后台，以便下次启动的时候可以马上启动起来，这个过程名为热启动，这也是Android 的设计理念之一。这个机制会带来一个问题，每个进程都有自己独立的内存地址空间，随着应用打开数量的增多, 系统已使用的内存越来越大，就很有可能导致系统内存不足。为了解决这个问题，系统引入 LowmemoryKiller (简称 lmk ) 管理所有进程，根据一定策略来 kill 某个进程并释放占用的内存，保证系统的正常运行。 LMK 基本原理 所有应用进程都是从 zygote 孵化出来的，记录在 AMS 中mLruProcesses 列表中，由 AMS 进行统一管理，AMS 中会根据进程的状态更新进程对应的 oom_adj 值，这个值会通过文件传递到 kernel 中去，kernel 有个低内存回收机制，在内存达到一定阀值时会触发清理 oom_adj 值高的进程腾出更多的内存空间 LMK 杀进程标准 minfree : 存放6个数值，单位内存页面数 ( 一个页面 4kb ) 内存阈值 内存回收阈值 对应进程 18432 72 M .前台进程（foreground） 23040 90 M 可见进程（visible） 27648 108 M 次要服务（secondary server） 32256 126 M 后台进程（hidden） 36864 144 M 内容供应节点（content provider） 46080 180 M 空进程（empty） 当内存到 180 M的时候会将空进程进行回收，当内存到 144 M 的时候把空进程回收完以后开始对内容供应节点进行回收，并不是所有的内容供应节点都回收，而是通过判断它的优先级进行回收，优先级是用 oom_adj 的值来表示，值越大回收的几率越高 adj 查看: 1cat /sys/module/lowmemorykiller/parameters/adj 查看进程 adj 值： 1adb shell ps 值越低越不易被回收，0 代表就不会被回收。 内存阈值在不同的手机上不一样，一旦低于该值, Android 便开始按顺序关闭进程. 因此 Android 开始结束优先级最低的空进程，即当可用内存小于 180MB (46080) 进程保活方案Activity 提权 这里可见 oom_adj 为 0 是不会被回收的 后台 oom_adj 为 6 内存不足会被回收 锁屏 oom_adj 开启一像素 Activity 为 0 相当于可见进程，不易被回收 实现原理: 监控手机锁屏解锁事件，在屏幕锁屏时启动 1 个像素透明的 Activity ，在用户解锁时将 Activity 销毁掉，从而达到提高进程优先级的作用。 代码实现 创建 onePxActivity 12345678910111213141516171819202122@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //设定一像素的activity Window window = getWindow(); window.setGravity(Gravity.START | Gravity.TOP); WindowManager.LayoutParams params = window.getAttributes(); params.x = 0; params.y = 0; params.height = 1; params.width = 1; window.setAttributes(params); //在一像素activity里注册广播接受者 接受到广播结束掉一像素 br = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { finish(); } }; registerReceiver(br, new IntentFilter(\"finish activity\")); checkScreenOn(\"onCreate\");} 创建锁屏开屏广播接收 12345678910111213141516171819202122232425262728293031@Overridepublic void onReceive(final Context context, Intent intent) { if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) { //屏幕关闭的时候接受到广播 appIsForeground = IsForeground(context); try { Intent it = new Intent(context, OnePixelActivity.class); it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); it.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); context.startActivity(it); } catch (Exception e) { e.printStackTrace(); } //通知屏幕已关闭，开始播放无声音乐 context.sendBroadcast(new Intent(\"_ACTION_SCREEN_OFF\")); } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) { //屏幕打开的时候发送广播 结束一像素 context.sendBroadcast(new Intent(\"finish activity\")); if (!appIsForeground) { appIsForeground = false; try { Intent home = new Intent(Intent.ACTION_MAIN); home.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); home.addCategory(Intent.CATEGORY_HOME); context.getApplicationContext().startActivity(home); } catch (Exception e) { e.printStackTrace(); } } //通知屏幕已点亮，停止播放无声音乐 context.sendBroadcast(new Intent(\"_ACTION_SCREEN_ON\")); }} Service 提权创建一个前台服务用于提高 app 在按下 home 键之后的进程优先级 123456789101112131415161718private void startService(Context context) { try { Log.i(TAG, \"---》启动双进程保活服务\"); //启动本地服务 Intent localIntent = new Intent(context, LocalService.class); //启动守护进程 Intent guardIntent = new Intent(context, RemoteService.class); if (Build.VERSION.SDK_INT &gt;= 26) { startForegroundService(localIntent); startForegroundService(guardIntent); } else { startService(localIntent); startService(guardIntent); } } catch (Exception e) { Log.e(TAG, e.getMessage()); } } 注意如果开启 startForegroundService 前台服务，那么必须在 5 s内开启一个前台进程的服务通知栏,不会报 ANR 1startForeground(KeepAliveConfig.FOREGROUD_NOTIFICATION_ID, notification); 广播拉活(在 8.0 以下很受用)在发生特定系统事件时，系统会发出广播，通过在 AndroidManifest 中静态注册对应的广播监听器，即可在发生响应事件时拉活。但是从android 7.0 开始，对广播进行了限制，而且在 8.0 更加严格。 以静态广播的形式注册 12345&lt;receiver android:name=\".receive.NotificationClickReceiver\"&gt;&lt;intent-filter&gt;&lt;action android:name=\"CLICK_NOTIFICATION\"&gt;&lt;/action&gt;&lt;/intent-filter&gt;&lt;/receiver&gt; 全家桶 拉活有多个 app 在用户设备上安装，只要开启其中一个就可以将其他的app 也拉活。比如手机里装了手 Q、QQ 空间、兴趣部落等等，那么打开任意一个 app 后，其他的 app 也都会被唤醒。 Service 机制拉活将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活 只要 targetSdkVersion 不小于5，就默认是 START_STICKY。但是某些 ROM 系统不会拉活。并且经过测试，Service 第一次被异常杀死后很快被重启，第二次会比第一次慢，第三次又会比前一次慢，一旦在短时间内 Service 被杀死 4-5 次，则系统不再拉起。 账号同步拉活（只做了解，不靠谱）手机系统设置里会有 “帐户” 一项功能，任何第三方 APP 都可以通过此功能将数据在一定时间内同步到服务器中去。系统在将 APP 帐户同步时，会将未启动的 APP 进程拉活 JobScheduler 拉活(靠谱，8.0 官方推荐)JobScheduler 允许在特定状态与特定时间间隔周期执行任务。可以利用它的这个特点完成保活的功能,效果即开启一个定时器，与普通定时器不同的是其调度由系统完成。 注意 setPeriodic 方法在 7.0 以上如果设置小于 15 min 不起作用，可以使用setMinimumLatency 设置延时启动，并且轮询 1234567891011121314151617181920212223242526public static void startJob(Context context) { try { mJobScheduler = (JobScheduler) context.getSystemService( Context.JOB_SCHEDULER_SERVICE); JobInfo.Builder builder = new JobInfo.Builder(10, new ComponentName(context.getPackageName(), JobHandlerService.class.getName())).setPersisted(true); /** * I was having this problem and after review some blogs and the official documentation, * I realised that JobScheduler is having difference behavior on Android N(24 and 25). * JobScheduler works with a minimum periodic of 15 mins. * */ if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { //7.0以上延迟1s执行 builder.setMinimumLatency(KeepAliveConfig.JOB_TIME); } else { //每隔1s执行一次job builder.setPeriodic(KeepAliveConfig.JOB_TIME); } mJobScheduler.schedule(builder.build()); } catch (Exception e) { Log.e(\"startJob-&gt;\", e.getMessage()); }} 推送拉活根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送。 Native 拉活Native fork 子进程用于观察当前 app 主进程的存亡状态。对于 5.0以上成功率极低。 后台循环播放一条无声文件12345678910111213//如果选择流氓模式，就默认接收了耗电的缺点，但是保活效果很好。 if (mediaPlayer == null &amp;&amp; KeepAliveConfig.runMode == RunMode.HIGH_POWER_CONSUMPTION) { mediaPlayer = MediaPlayer.create(this, R.raw.novioce); mediaPlayer.setVolume(0f, 0f); mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { Log.i(TAG, \"循环播放音乐\"); play(); } }); play(); } 双进程守护 (靠谱)两个进程相互绑定 (bindService），如果有其中一个进程被杀，那么另外一个进程就会将被杀的进程重新拉起 总结进程保活就讲到这里了，最后我自己是结合里面最靠谱的（Activity + Service 提权 + Service 机制拉活 + JobScheduler 定时检测进程是否运行 + 后台播放无声文件 + 双进程守护），然后组成了一个 进程保活终极方案。","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81-%E6%8C%81%E7%BB%AD%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%AE%9E%E7%8E%B0/"},{"title":"性能优化 (八) APK 安全优化之 Dex 加密解密 - 上","text":"简介现在随意在应用市场下载一个 APK 文件然后反编译，95% 以上基本上都是经过混淆，加密，或第三方加固，那么今天我们就对 Dex 来进行加密解密。让反编译无法正常阅读项目源码。 加密后的结构 APK 分析 反编译效果 64 K 问题想要详细了解 64 k 的问题可以参考官网 随着 Android 平台的持续成长，Android 应用的大小也在增加。当您的应用及其引用的库达到特定大小时，您会遇到构建错误，指明您的应用已达到 Android 应用构建架构的极限。早期版本的构建系统按如下方式报告这一错误： 12Conversion to Dalvik format failed:Unable to execute dex: method ID not in [0, 0xffff]: 65536 较新版本的 Android 构建系统虽然显示的错误不同，但指示的是同一问题： 123trouble writing output:Too many field references: 131000; max is 65536.You may try using --multi-dex option. 这些错误状况都会显示下面这个数字：65,536。这个数字很重要，因为它代表的是单个 Dalvik Executable (DEX) 字节码文件内的代码可调用的引用总数。本节介绍如何通过启用被称为 Dalvik 可执行文件分包的应用配置来越过这一限制，使您的应用能够构建并读取 Dalvik 可执行文件分包 DEX 文件。 关于 64K 引用限制Android 5.0 之前版本的 Dalvik 可执行文件分包支持Android 5.0（API 级别 21）之前的平台版本使用 Dalvik 运行时来执行应用代码。默认情况下，Dalvik 限制应用的每个 APK 只能使用单个 classes.dex 字节码文件。要想绕过这一限制，您可以使用 Dalvik 可执行文件分包支持库，它会成为您的应用主要 DEX 文件的一部分，然后管理对其他 DEX 文件及其所包含代码的访问。 Android 5.0 及更高版本的 Dalvik 可执行文件分包支持Android 5.0（API 级别 21）及更高版本使用名为 ART 的运行时，后者原生支持从 APK 文件加载多个 DEX 文件。ART 在应用安装时执行预编译，扫描 classesN.dex 文件，并将它们编译成单个 .oat 文件，供 Android 设备执行。因此，如果您的 minSdkVersion 为 21 或更高值，则不需要 Dalvik 可执行文件分包支持库。 解决 64K 限制 如果您的 minSdkVersion 设置为 21 或更高值，您只需在模块级 build.gradle 文件中将 multiDexEnabled 设置为 true，如此处所示： 123456789android { defaultConfig { ... minSdkVersion 21 targetSdkVersion 28 multiDexEnabled true } ...} 但是，如果您的 minSdkVersion 设置为 20 或更低值，则您必须按如下方式使用 Dalvik 可执行文件分包支持库： 修改模块级 build.gradle 文件以启用 Dalvik 可执行文件分包，并将 Dalvik 可执行文件分包库添加为依赖项，如此处所示 12345678910111213android { defaultConfig { ... minSdkVersion 15 targetSdkVersion 28 multiDexEnabled true } ...}dependencies { compile 'com.android.support:multidex:1.0.3'} 当前 Application extends MultiDexApplication {…} 或者 MultiDex.install(this); 通过混淆 开启 ProGuard 移除未使用的代码，构建代码压缩。 减少第三方库的直接依赖，尽可能下载源码，需要什么就用什么没必要依赖整个项目。 Dex 加密与解密 *流程: * 拿到 APK 解压得到所有的 dex 文件。 通过 Tools 来进行加密，并把加密后的 dex 和代理应用 class.dex 合并，然后重新签名，对齐，打包。 当用户安装 APK 打开进入代理解密的 Application 时，反射得到 dexElements 并将解密后的 dex 替换 DexPathList 中的 dexElements . Dex 文件加载过程既然要查 Dex 加载过程，那么得先重那个 class 入手勒，既然不知道那么我们就先打印下 ClassLoader ; 下面就以一个流程图来详细了解下 Dex 加载过程吧 最后我们得知在 findClass(String name,List sup) 遍历 dexElements 找到 Class 并交给 Android 加载。 Dex 解密现在我们知道 dex 加载流程了 , 那么我们怎么进行来对 dex 解密勒，刚刚我们得知需要遍历 dexElements 来找到 Class 那么我们是不是可以在遍历之前 ，初始化 dexElements 的时候。反射得到 dexElements 将我们解密后的 dex 交给 dexElements 。下面我们就通过代码来进行解密 dex 并替换 DexPathList 中的 dexElements; 得到当前加密了的 APK 文件 并解压 123456//得到当前加密了的APK文件File apkFile=new File(getApplicationInfo().sourceDir);//把apk解压 app_name+\"_\"+app_version目录中的内容需要boot权限才能用File versionDir = getDir(app_name+\"_\"+app_version,MODE_PRIVATE);File appDir=new File(versionDir,\"app\");File dexDir=new File(appDir,\"dexDir\"); 得到我们需要加载的 Dex 文件 12345678910111213141516171819202122232425//把apk解压到appDirZip.unZip(apkFile,appDir);//获取目录下所有的文件File[] files=appDir.listFiles();for (File file : files) { String name=file.getName(); if(name.endsWith(\".dex\") &amp;&amp; !TextUtils.equals(name,\"classes.dex\")){ try{ AES.init(AES.DEFAULT_PWD); //读取文件内容 byte[] bytes=Utils.getBytes(file); //解密 byte[] decrypt=AES.decrypt(bytes); //写到指定的目录 FileOutputStream fos=new FileOutputStream(file); fos.write(decrypt); fos.flush(); fos.close(); dexFiles.add(file); }catch (Exception e){ e.printStackTrace(); } }} 把解密后的 dex 加载到系统 123456789101112131415161718192021private void loadDex(List&lt;File&gt; dexFiles, File versionDir) throws Exception{ //1.获取pathlist Field pathListField = Utils.findField(getClassLoader(), \"pathList\"); Object pathList = pathListField.get(getClassLoader()); //2.获取数组dexElements Field dexElementsField=Utils.findField(pathList,\"dexElements\"); Object[] dexElements=(Object[])dexElementsField.get(pathList); //3.反射到初始化dexElements的方法 Method makeDexElements=Utils.findMethod(pathList,\"makePathElements\",List.class,File.class,List.class); ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); Object[] addElements=(Object[])makeDexElements.invoke(pathList,dexFiles,versionDir,suppressedExceptions); //合并数组 Object[] newElements= (Object[])Array.newInstance(dexElements.getClass().getComponentType(),dexElements.length+addElements.length); System.arraycopy(dexElements,0,newElements,0,dexElements.length); System.arraycopy(addElements,0,newElements,dexElements.length,addElements.length); //替换classloader中的element数组 dexElementsField.set(pathList,newElements); } 解密已经完成了，下面来看看加密吧，这里为什么先说解密勒，因为 加密涉及到 签名，打包，对齐。所以留到最后讲。 Dex 加密 制作只包含解密代码的 dex 1234567891011121314151617181. sdk\\build-tools 中执行下面命令 会得到包含 dex 的 jardx --dex --output out.dex in.jar2. 通过 exec 执行File aarFile=new File(\"proxy_core/build/outputs/aar/proxy_core-debug.aar\"); File aarTemp=new File(\"proxy_tools/temp\"); Zip.unZip(aarFile,aarTemp); File classesJar=new File(aarTemp,\"classes.jar\"); File classesDex=new File(aarTemp,\"classes.dex\"); String absolutePath = classesDex.getAbsolutePath(); String absolutePath1 = classesJar.getAbsolutePath(); //dx --dex --output out.dex in.jar //dx --dex --output //D:\\Downloads\\android_space\\DexDEApplication\\proxy_tools\\temp\\classes.dex //D:\\Downloads\\android_space\\DexDEApplication\\proxy_tools\\temp\\classes.jar Process process=Runtime.getRuntime().exec(\"cmd /c dx --dex --output \"+classesDex.getAbsolutePath() +\" \"+classesJar.getAbsolutePath()); process.waitFor(); if(process.exitValue()!=0){ throw new RuntimeException(\"dex error\"); } 加密 apk 中的 dex 文件 12345678910111213141516171819202122 File apkFile=new File(\"app/build/outputs/apk/debug/app-debug.apk\"); File apkTemp=new File(\"app/build/outputs/apk/debug/temp\"); Zip.unZip(apkFile,apkTemp); //只要dex文件拿出来加密 File[] dexFiles=apkTemp.listFiles(new FilenameFilter() { @Override public boolean accept(File file, String s) { return s.endsWith(\".dex\"); } }); //AES加密了 AES.init(AES.DEFAULT_PWD); for (File dexFile : dexFiles) { byte[] bytes = Utils.getBytes(dexFile); byte[] encrypt = AES.encrypt(bytes); FileOutputStream fos=new FileOutputStream(new File(apkTemp, \"secret-\"+dexFile.getName())); fos.write(encrypt); fos.flush(); fos.close(); dexFile.delete();} 把 dex 放入 apk 加压目录，重新压成 apk 文件 123456File apkTemp=new File(\"app/build/outputs/apk/debug/temp\"); File aarTemp=new File(\"proxy_tools/temp\"); File classesDex=new File(aarTemp,\"classes.dex\"); classesDex.renameTo(new File(apkTemp,\"classes.dex\")); File unSignedApk=new File(\"app/build/outputs/apk/debug/app-unsigned.apk\"); Zip.zip(apkTemp,unSignedApk); 现在可以看下加密后的文件，和未加密的文件 未加密 apk: 加密后的 apk (app 项目里面的代码全部看不见了，现在只能看见代理 Application ) 打包对齐1234567891011121314//apk整理对齐工具 未压缩的数据开头均相对于文件开头部分执行特定的字节对齐，减少应用运行内存。zipalign -f 4 in.apk out.apk //比对 apk 是否对齐zipalign -c -v 4 output.apk//最后提示 Verification succesful 说明对齐成功了 236829 res/mipmap-xxxhdpi-v4/ic_launcher.png (OK - compressed) 245810 res/mipmap-xxxhdpi-v4/ic_launcher_round.png (OK - compressed) 260956 resources.arsc (OK - compressed) 317875 secret-classes.dex (OK - compressed) 2306140 secret-classes2.dex (OK - compressed) 2477544 secret-classes3.dex (OK - compressed)Verification succesful 签名打包 apksigner12//sdk\\build-tools\\24.0.3 以上，apk签名工具apksigner sign --ks jks文件地址 --ks-key-alias 别名 --ks-pass pass:jsk密码 --key-pass pass:别名密码 --out out.apk in.apk 总结其实原理就是把主要代码通过命令 dx 生成 dex 文件，然后把加密后的 dex 合并在代理 class.dex 中。这样虽然还是能看见代理中的代码，但是主要代码已经没有暴露出来了，就已经实现了我们想要的效果。如果封装的好的话（JNI 中实现主要解密代码），基本上就哈也看不见了。ClassLoader 还是很重要的，热修复跟热加载都是这原理。学到这里 DEX 加解密已经学习完了，如果想看自己试一试可以参考我的代码 代码传送阵","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%85%AB-APK-%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96%E4%B9%8B-Dex-%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"},{"title":"面向 Android 高级工程师的一份面试宝典","text":"前言疫情一过，我相信将会是面试求职的高峰时期，如果此时手里有份高质量的面试宝典，那么你将得心应手面对考官各种问题。虽然不敢保证你能应聘上心仪的职位，但是能保证看完这些内容你的收获将超乎你的想象! 此份面试宝典搜集各大网络平台(如果侵权，请您告知)，在此感谢他们的用心总结，才有这份足够全面的面试宝典！ 已托管 GitHub, 觉得对你有帮助的可以给个 star 内容点较丰富，建议找工作的小伙伴一定要慢慢细细品，我这里随意展示一下，保证不会让你失望!!! 面试准备 了解这些,自然无惧面试 解读大部分程序员在面试前很关心的一些问题 如果面试官问你“你有什么问题问我吗？”时，你该如何回答? 面试官问你优点/缺点时该如何回答（避免雷区）? 程序员简历就该这样写 非技术性问题 &amp; HR 问题 非技术问题 HR 提出的面试问题 Java Java 基础 Java 容器 List Vector ArrayList LinkedList CopyOnWriteArrayList Map HashMap ArrayMap(Android) LinedHashMap TreeMap Hashtable ConcurrentHashMap Cloneable SparseArray Set HashSet TreeSet Queue LinkedBlockingQueue ConcurrentLinkedQueue ArrayBlockingQueue PriorityBlockingQueue SynchronousQueue 容器面试题 Java 并发 一 Java 并发 二 Java 并发 三 Java 并发 四 JVM JVM 基础概念 Java内存区域-比较详细 JVM垃圾回收 类文件结构 类加载过程 类加载器 大白话带你认识JVM Java 进阶核心技术面试精讲(一) (ps: 需要购买) Java 进阶源码解析专题(二) （ps: 需要购买 ￥49） 面向对象 面向对象思想 设计模式 网络 计算机网络 HTTP Socket Android Android - 基础 Context Application Activity Service BroadcastReceiver ContentProvider fragment 动画 存储 View 接口 序列化 进程处理 内存 网络 多线程 应用无响应 屏幕适配 Android 版本新特性 Bitmap JNI Intent Lru 随机应变 其它 Android 中高级专题 - 原理 性能优化 图片 网络 异步 注入 Handler 数据库 屏幕适配 插件化 热修复 架构 组件化 路由 View Gradle 多渠道 性能监控 NDK 音视频 混合开发 疑难杂症 Android 高级 - SDK源码 窗口管理 显示系统 组件管理 包管理 资源管理 进程框架 通信框架 内存框架 虚拟机框架 走向大厂 Alibaba BaiDu Tencent ByteDance 美团 豌豆荚 蜻蜓 FM 新浪 网易 其它 操作系统 操作系统基础知识篇 Linux篇 算法 剑指 Offer 题解 Leetcode 题解 算法 工具 Git Docker 构建工具 正则表达式 编码实践 代码可读性 代码风格规范 感谢 2000+ start CommonDevKnowledge 70000+star CS-Notes 50000+star JavaGuide 7000+star AndroidInterview-Q-A Java 优秀文章 【干货合辑】备战金九银十招聘季，最后冲刺宝典奉上 慕课网-Java 源码及大厂真题解析 需要购买专栏 ￥49 Android面试2019年最新版 每日一道面试题 2.5K 【建议收藏】2020年中高级Android大厂面试秘籍，为你保驾护航金三银四，直通大厂（Android基础篇） https://github.com/sucese/android-open-source-project-analysis https://github.com/interviewandroid/AndroidInterView 关于我 Email: yang1001yk@gmail.com 个人博客 掘金 GitHub","link":"/2020/06/08/%E9%9D%A2%E5%90%91-Android-%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E4%B8%80%E4%BB%BD%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"},{"title":"性能优化 (十三) 稳定运行优化之捕获 Native Crash","text":"介绍现在 Android 日常开发中，多多少少会用到 so 动态库，特别是一些第三方的 so 比如（地图 SDK，音视频 SDK）还有自研 SDK，不知道大家有没有想过这样的一个问题，用户反馈我们的 APP 崩溃，这个时候后台也没有收到具体的日志，我们也不知道从哪里分析，这是最可怕的。如果有日志，一切就好办了，下面我们就来分析 Android 端怎么获取不同情况下的崩溃信息。 框架使用12345678//1. 配置 project/build.gradleallprojects { repositories { ... maven { url 'https://jitpack.io' } } } 12345//2. app/build.gradle dependencies { implementation 'com.github.yangkun19921001:YKCrash:1.0.1' } 123//3. application 中初始化//nativePath: 保存的 dmp 日志CrashUtils.initNativeCrash(getApplicationContext(), nativePath); 产生崩溃的原因哪些情况会崩溃 Java 崩溃； Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。 native 崩溃； 一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，，或者发生了程序主动 abort , 这些都会产生相应的 signal 信号，导致程序异常退出。 ANR； 死锁； IO 问题； 主线程耗时操作； 频繁大量 GC. breakpad 编译及使用(MAC)介绍这里推荐大家使用 Chromium 的 Breakpad, 为什么呢？因为它是目前 Native 崩溃捕获中最为成熟的方案，但是很多人都觉得 Breakpad 过于复杂。其实我认为 Native 崩溃捕获这件事儿就本来不容易。 如果你对 Native 崩溃机制的一些基本知识还不是很熟悉，可以看一下Android 平台 Native 代码的崩溃捕获机制及实现 1. 获取 breakpad 源码 官网获取 GitHub 下载 2. 执行安装 breakpad1231. cd breakpad 目录2. 直接命令窗口输入： ./configure &amp;&amp; make 执行完之后会生成 src/processor/minidump_stackwalk 文件，待会 dmp -&gt; txt 会用到这个文件。 *3. CMake *编译源码 build 配置 1234567891011121314151617181920212223242526272829apply plugin: 'com.android.library'android { ..... defaultConfig { .... externalNativeBuild { cmake { cppFlags \"-std=c++11\" } } ndk { abiFilters \"armeabi-v7a\", \"arm64-v8a\", \"x86\" } } .... externalNativeBuild { cmake { path \"src/main/cpp/CMakeLists.txt\" } }}dependencies { implementation fileTree(dir: 'libs', include: ['*.jar'])} 把 breakpad/src 源码导致 AS 中 CMake 配置好之后直接在 AS/Build/make break-build 之后就能生成动态 so 库了。 注意：下载的源码缺少 lss 目录，可以点击下载获取 *4. 编写初始化 breakpad *123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;jni.h&gt;#include &lt;android/log.h&gt;#include \"client/linux/handler/exception_handler.h\"#include \"client/linux/handler/minidump_descriptor.h\"#define LOG_TAG \"dodoodla_crash\"#define ALOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)#define ALOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define ALOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define ALOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define ALOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)bool DumpCallback(const google_breakpad::MinidumpDescriptor &amp;descriptor, void *context, bool succeeded) { ALOGD(\"===============crrrrash================\"); ALOGD(\"Dump path: %s\\n\", descriptor.path()); return succeeded;}/** java 代码中调用*/extern \"C\"JNIEXPORT void JNICALLJava_com_devyk_crash_1module_CrashUtils_initBreakpadNative(JNIEnv *env, jclass type, jstring path_) { const char *path = env-&gt;GetStringUTFChars(path_, 0); // TODO google_breakpad::MinidumpDescriptor descriptor(path); static google_breakpad::ExceptionHandler eh(descriptor, NULL, DumpCallback, NULL, true, -1); env-&gt;ReleaseStringUTFChars(path_, path);}JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } return JNI_VERSION_1_6;} 生成 dmp 文件并定位 crash1. 在 app 模块中故意编写崩溃代码123456789101112131415/** * 引起 crash */void Crash() { volatile int *a = (int *) (NULL); *a = 1;}extern \"C\"JNIEXPORT void JNICALLJava_com_devyk_ykcrash_MainActivity_testCrash(JNIEnv *env, jclass type) { // TODO Crash();} 2. init native crash 捕获12//配置 native 崩溃捕获CrashUtils.initCrash(String nativeCrashPath); 3. 制造 Crash 并生成 xxx.dmp 文件 这里看到了生成了的 xxx.dmp 文件，下面就需要将 dmp to txt 文件稍微我们能看的懂的。 4. dmp to txt 将 breakpad/src/processor/minidump_stackwalk copy 到一个单独的文件下 执行命令 to txt 12345//格式 ./minidump_stackwalk xxx.dmp &gt;xxx.txt//例子./minidump_stackwalk /Users/devyk/Data/Project/sample/tempFile/nativeCrash.dmp &gt;crashLog2.txt 查看 txt 文件到底是什么？ 12345678910111213141516171819202122232425262728293031Operating system: Android 0.0.0 Linux 4.9.148 #1 SMP PREEMPT Wed Jun 26 04:38:26 CST 2019 aarch64CPU: arm64 8 CPUsGPU: UNKNOWNCrash reason: SIGSEGV /SEGV_MAPERRCrash address: 0x0Process uptime: not available//crash 发生线程Thread 0 (crashed) //这里的 libcrash-lib.so + 0x5f0 很重要。告诉了我们在哪个 so 发生崩溃，在具体哪个位置发生崩溃。这里先记住 0x5f0 这个值。 0 libcrash-lib.so + 0x5f0 x0 = 0x00000078d4ac5380 x1 = 0x0000007fe01fd9d4 x2 = 0x0000007fe01fda00 x3 = 0x00000078d453ecb8 x4 = 0x0000000000000000 x5 = 0x00000078d4586b94 x6 = 0x0000000000000001 x7 = 0x0000000000000001 x8 = 0x0000000000000001 x9 = 0x0000000000000000 x10 = 0x0000000000430000 x11 = 0x00000078d49396d8 x12 = 0x000000795afcb630 x13 = 0x0ef1a811d0863271 x14 = 0x000000795aede000 x15 = 0xffffffffffffffff x16 = 0x00000078b8cb5fe8 x17 = 0x00000078b8ca55dc x18 = 0x0000000000000000 x19 = 0x00000078d4a15c00 x20 = 0x0000000000000000 x21 = 0x00000078d4a15c00 x22 = 0x0000007fe01fdc90 x23 = 0x00000079552cb12a x24 = 0x0000000000000000 x25 = 0x000000795b3125e0 x26 = 0x00000078d4a15ca0 x27 = 0x0000000000000000 x28 = 0x0000007fe01fd9d0 fp = 0x0000007fe01fd9a0 lr = 0x00000078b8ca5614 sp = 0x0000007fe01fd980 基于 dmp to txt 里面的 libcrash-lib.so + 0x5f0 信息，转换为具体哪个函数，哪行报的错。 根据 txt 提示的信息 aarch64 CPU: arm64 那么我们就在当前使用的 NDK 版本找到 /Users/devyk/Data/Android/NDK/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line 这个路径，使用下面的命令找到具体报错的地方 12345//1. 格式aarch64-linux-android-addr2line -f -C -e [根据 txt 信息拿到具体报错的 so] [根据 txt 文件信息拿到具体报错的值]//2. 示例/Users/devyk/Data/Android/NDK/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line -f -C -e /Users/devyk/Data/Project/sample/github_code/YKCrash/app/build/intermediates/transforms/mergeJniLibs/debug/0/lib/arm64-v8a/libcrash-lib.so 0x5f0 下面录像就是输入命令之后的效果。 根据上面录像我们拿到了重要信息如下： 1234//报错的函数Crash()//当前 cpp 报错的行数/Users/devyk/Data/Project/sample/github_code/YKCrash/app/src/main/cpp/crash.cpp:10 我们看下 cpp 10 行具体是什么。 这里不用想，肯定会 crash。 到这里我们已经捕获到了 native 层崩溃日志，相信大家已经会了。 总结在之前我是真不知道 breakpad 这个开源库，而且还是 Google 开源的。因为项目中用到 C++ 代码比较多，崩溃捕获是必须的。在不知道 breakpad 之前一直用的 腾讯 Bugly ，由于Bugly 只支持互联网环境，最后我也就止步了，为什么呢？因为公司开发出来的产品是给政府部分用的（政府部门有专门的网络属于局域网)。 最后我把 breakpad 编译及使用记录下来，以供后来使用者提供方便之路，并把它封装成了一个 crash_build_module 需要可以点击进行下载。 非常感谢 Android 开发高手课 - 张绍文 (Tinker负责人)","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%B8%89-%E7%A8%B3%E5%AE%9A%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96%E4%B9%8B%E6%8D%95%E8%8E%B7-Native-Crash/"},{"title":"性能优化 (四) 图片优化","text":"使用方式 在 project/build.gradle 上添加以下代码 123456allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 在 app/build.gradle 添加依赖 123dependencies { implementation 'com.github.yangkun19921001:LIBJPEG_SAMPLE:v1.0.1'} 压缩使用 1234//bitmap : 需要压缩的 bitmap//q : 压缩质量 建议 30 - 50//outputFilePath: 压缩之后存储的图片地址JpegUtils.native_Compress(Bitmap bitmap,int q,String outputFilePath); JEPG 是什么? 相信有一部分使用 iPhone 手机用微信发送图片的时候，明明图片大小只有 1M ，但清晰度比 Android 手机 5 M 图片大小的还要清晰，那么这是为什么呢 ？。 当时谷歌开发 Android 的时候，考虑了大部分手机的配置并没有那么高，所以对图片处理使用的是 Skia。当然这个库的底层还是用的 jpeg 图片压缩处理。但是为了能够适配低端的手机（这里的低端是指以前的硬件配置不高的手机，CPU 和内存在手机上都非常吃紧，性能差），由于哈夫曼算法比较吃 CPU 并且编解码慢，被迫用了其他的算法。所以 Skia 在进行图片处理在低版本中并没有开启哈弗曼算法。 那么，JEPG 到底是什么？JEPG (全称是 Joint Photographic Experts Group) 是一种常见的一种图像格式，为什么我在这里会提到 JEPG 呢？是因为开源了一个 C/C++ 库底层是基于哈夫曼算法对图片的压缩 (libjpeg)，下面我们就来着重了解下 libjpeg 这个库 libjpeg 简介libjpeg-turbo 是一个 JPEG 图像编解码器，它使用 SIMD 指令（MMX，SSE2，AVX2，NEON，AltiVec）来加速 x86，x86-64，ARM 和 PowerPC 系统上的基线 JPEG 压缩和解压缩，以及渐进式JPEG 压缩 x86 和 x86-64 系统。在这样的系统上，libjpeg-turbo 的速度通常是 libjpeg 的 2 - 6 倍，其他条件相同。在其他类型的系统上，凭借其高度优化的霍夫曼编码例程，libjpeg-turbo 仍然可以大大超过 libjpeg。在许多情况下，libjpeg-turbo 的性能可与专有的高速 JPEG 编解码器相媲美。 libjpeg-turbo 实现了传统的 libjpeg API 以及功能较弱但更直接的 TurboJPEG API 。 libjpeg-turbo 还具有色彩空间扩展，允许它从/解压缩到32位和大端像素缓冲区（RGBX，XBGR等），以及功能齐全的 Java 接口。 libjpeg-turbo 最初基于 libjpeg / SIMD，这是由 Miyasaka Masaru 开发的 libjpeg v6b 的 MMX 加速衍生物。 TigerVNC 和 VirtualGL 项目在 2009 年对编解码器进行了大量增强，并且在2010年初，libjpeg-turbo 分拆成一个独立项目，目标是为更广泛的用户提供高速 JPEG压缩/解压缩技术。开发人员。 现在我们大概了解到了 libjpeg 是一个对图像编解码库，现在我们需要准备环境去编译 libjpeg。 编译准备工作系统: Ubuntu 18.04 也可以使用我下载好的 提取码：biyt libjpeg: libjepg 2.0.2 cmake: cmake-3.14.4-Linux-x86_64.tar.gz ndk: android-ndk-r17c 开始发车准备编译 ubuntu 中下载 libjpeg 使用 wget 命令直接下载 1wget https://github.com/libjpeg-turbo/libjpeg-turbo/archive/2.0.2.tar.gz 解压 tar xvf 2.0.2.tar.gz [编译参考)(https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/BUILDING.md) ubuntu 中安装 cmake 删除原来的 apt-get autoremove cmake 使用 wget 命令直接下载 1wget https://github.com/Kitware/CMake/releases/download/v3.14.4/cmake-3.14.4.tar.gz 解压 tar zxvf cmake-3.14.3.tar.gz 创建软连接 mv cmake-3.14.3-Linux-x86_64 /opt/cmake-3.14.3 ln -sf /opt/cmake-3.14.3/bin/* /usr/bin/ 输入 cmake – version 如果有这样的显示代表安装成功 进入到 libjpeg 目录，生成 shell 脚本 vim build.sh 新建一个文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# lib-nameMY_LIBS_NAME=libjpeg-turbo_2.0.2# 源码目录MY_SOURCE_DIR=/home/yangkun/libjpeg-turbo-2.0.2MY_BUILD_DIR=yangkun# android-cmakeCMAKE_PATH=/opt/cmake-3.14.4/binexport PATH=${CMAKE_PATH}/bin:$PATHNDK_PATH=/home/yangkun//android-ndk-r17cBUILD_PLATFORM=linux-x86_64TOOLCHAIN_VERSION=4.9ANDROID_VERSION=24ANDROID_ARMV5_CFLAGS=\"-march=armv5te\"ANDROID_ARMV7_CFLAGS=\"-march=armv7-a -mfloat-abi=softfp -mfpu=neon\" # -mfpu=vfpv3-d16 -fexceptions -frttiANDROID_ARMV8_CFLAGS=\"-march=armv8-a\" # -mfloat-abi=softfp -mfpu=neon -fexceptions -frttiANDROID_X86_CFLAGS=\"-march=i386 -mtune=intel -mssse3 -mfpmath=sse -m32\"ANDROID_X86_64_CFLAGS=\"-march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel\"# params($1:arch,$2:arch_abi,$3:host,$4:compiler,$5:cflags,$6:processor)build_bin() { echo \"-------------------star build $2-------------------------\" ARCH=$1 # arm arm64 x86 x86_64 ANDROID_ARCH_ABI=$2 # armeabi armeabi-v7a x86 mips # 最终编译的安装目录 PREFIX=$(pwd)/dist/${MY_LIBS_NAME}/${ANDROID_ARCH_ABI}/ HOST=$3 COMPILER=$4 PROCESSOR=$6 SYSROOT=${NDK_PATH}/platforms/android-${ANDROID_VERSION}/arch-${ARCH} CFALGS=\"$5\" TOOLCHAIN=${NDK_PATH}/toolchains/${HOST}-${TOOLCHAIN_VERSION}/prebuilt/${BUILD_PLATFORM} # build 中间件 BUILD_DIR=./${MY_BUILD_DIR}/${ANDROID_ARCH_ABI} export CFLAGS=\"$5 -Os -D__ANDROID_API__=${ANDROID_VERSION} --sysroot=${SYSROOT} \\ -isystem ${NDK_PATH}/sysroot/usr/include \\ -isystem ${NDK_PATH}/sysroot/usr/include/${HOST} \" export LDFLAGS=-pie echo \"path==&gt;$PATH\" echo \"build_dir==&gt;$BUILD_DIR\" echo \"ARCH==&gt;$ARCH\" echo \"ANDROID_ARCH_ABI==&gt;$ANDROID_ARCH_ABI\" echo \"HOST==&gt;$HOST\" echo \"CFALGS==&gt;$CFALGS\" echo \"COMPILER==&gt;$COMPILER-gcc\" echo \"PROCESSOR==&gt;$PROCESSOR\" mkdir -p ${BUILD_DIR} #创建当前arch_abi的编译目录,比如:binary/armeabi-v7a cd ${BUILD_DIR} #此处 进了当前arch_abi的2级编译目录#运行时创建临时编译链文件toolchain.cmakecat &gt;toolchain.cmake &lt;&lt; EOF set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_SYSTEM_PROCESSOR $6)set(CMAKE_C_COMPILER ${TOOLCHAIN}/bin/${COMPILER}-gcc)set(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN}/${COMPILER})EOF cmake -G\"Unix Makefiles\" \\ -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \\ -DCMAKE_POSITION_INDEPENDENT_CODE=1 \\ -DCMAKE_INSTALL_PREFIX=${PREFIX} \\ -DWITH_JPEG8=1 \\ ${MY_SOURCE_DIR} make clean make make install #从当前arch_abi编译目录跳出，对应上面的cd ${BUILD_DIR},以便function多次执行 cd ../../ echo \"-------------------$2 build end-------------------------\"}# build armeabibuild_bin arm armeabi arm-linux-androideabi arm-linux-androideabi \"$ANDROID_ARMV5_CFLAGS\" arm#build armeabi-v7abuild_bin arm armeabi-v7a arm-linux-androideabi arm-linux-androideabi \"$ANDROID_ARMV7_CFLAGS\" arm#build arm64-v8abuild_bin arm64 arm64-v8a aarch64-linux-android aarch64-linux-android \"$ANDROID_ARMV8_CFLAGS\" aarch64#build x86build_bin x86 x86 x86 i686-linux-android \"$ANDROID_X86_CFLAGS\" i386#build x86_64build_bin x86_64 x86_64 x86_64 x86_64-linux-android \"$ANDROID_X86_64_CFLAGS\" x86_64 1 !/bin/bashndk所在目录NDK_PATH=$NDK_HOME 编译环境这里是 linuxBUILD_PLATFORM=linux-x86_64 编译工具链版本TOOLCHAIN_VERSION=4.9 最低兼容ANDROID_VERSION=14 源码目录 这里是当前脚本所在目录MY_SOURCE_DIR=$(pwd) 生成目标文件目录PREFIX=$(pwd)/android 目标平台HOST=arm-linux-androideabi SYSROOT=${NDK_PATH}/platforms/android-${ANDROID_VERSION}/arch-arm armera-v7平台export CFLAGS=”-march=armv7-a -mfloat-abi=softfp -fprefetch-loop-arrays \\ -D__ANDROID_API__=${ANDROID_VERSION} --sysroot=${SYSROOT} \\ -isystem ${NDK_PATH}/sysroot/usr/include \\ -isystem ${NDK_PATH}/sysroot/usr/include/${HOST}&quot; export LDFLAGS=-pieTOOLCHAIN=${NDK_PATH}/toolchains/${HOST}-${TOOLCHAIN_VERSION}/prebuilt/${BUILD_PLATFORM} cat &lt;toolchain.cmake set(CMAKE_SYSTEM_NAME Linux) set(CMAKE_SYSTEM_PROCESSOR arm) set(CMAKE_C_COMPILER ${TOOLCHAIN}/bin/${HOST}-gcc) set(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN}/${HOST}) EOF cmake -G”Unix Makefiles” -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \\ -DCMAKE_POSITION_INDEPENDENT_CODE=1 \\ -DCMAKE_INSTALL_PREFIX=${PREFIX} \\ ${MY_SOURCE_DIR} make clean make make install 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125 2. 如果编译遇见 权限问题 ![](https://user-gold-cdn.xitu.io/2019/5/19/16ad0568e451867d?w=816&amp;h=673&amp;f=jpeg&amp;s=216141) 给它一个 可执行文件的权限 chmod +x build.sh3. 继续执行 ![](https://user-gold-cdn.xitu.io/2019/5/19/16ad0565d2e01fea)4. 编译完成 ![](https://user-gold-cdn.xitu.io/2019/5/19/16ad055fc25cbb9b?w=800&amp;h=600&amp;f=jpeg&amp;s=210778) 这里我们发现 已经有我们需要的 静态库 .a 和 动态库 .so5. 在 AndroidStudio 中创建一个简单的项目 用于测试是否压缩成功 1. 结构目录 ![](https://user-gold-cdn.xitu.io/2019/5/19/16ad0578463b6131?w=829&amp;h=866&amp;f=jpeg&amp;s=83392) 标红的都是重要的文件，include 头文件和 libs/armeabi-v7a 是我们刚刚编译出来的文件 下面我们就来运行一下看看压缩效果 2. 压缩主要代码 **jni 代码** ```c++ #include &lt;jni.h&gt; #include &lt;string&gt; #include &quot;../include/jpeglib.h&quot; #include &lt;malloc.h&gt; #include &lt;android/bitmap.h&gt; void write_JPEG_file(uint8_t *data, int w, int h, jint q, const char *path) { // 3.1、创建jpeg压缩对象 jpeg_compress_struct jcs; //错误回调 jpeg_error_mgr error; jcs.err = jpeg_std_error(&amp;error); //创建压缩对象 jpeg_create_compress(&amp;jcs); // 3.2、指定存储文件 write binary FILE *f = fopen(path, &quot;wb&quot;); jpeg_stdio_dest(&amp;jcs, f); // 3.3、设置压缩参数 jcs.image_width = w; jcs.image_height = h; //bgr jcs.input_components = 3; jcs.in_color_space = JCS_RGB; jpeg_set_defaults(&amp;jcs); //开启哈夫曼功能 jcs.optimize_coding = true; jpeg_set_quality(&amp;jcs, q, 1); // 3.4、开始压缩 jpeg_start_compress(&amp;jcs, 1); // 3.5、循环写入每一行数据 int row_stride = w * 3;//一行的字节数 JSAMPROW row[1]; while (jcs.next_scanline &lt; jcs.image_height) { //取一行数据 uint8_t *pixels = data + jcs.next_scanline * row_stride; row[0] = pixels; jpeg_write_scanlines(&amp;jcs, row, 1); } // 3.6、压缩完成 jpeg_finish_compress(&amp;jcs); // 3.7、释放jpeg对象 fclose(f); jpeg_destroy_compress(&amp;jcs); } extern &quot;C&quot; JNIEXPORT void JNICALL Java_com_yk_libjpeg_1sample_libjpeg_JpegUtils_native_1Compress__Landroid_graphics_Bitmap_2ILjava_lang_String_2( JNIEnv *env, jclass type, jobject bitmap, jint q, jstring path_) { const char *path = env-&gt;GetStringUTFChars(path_, 0); //从bitmap获取argb数据 AndroidBitmapInfo info;//info=new 对象(); //获取里面的信息 AndroidBitmap_getInfo(env, bitmap, &amp;info);// void method(list) //得到图片中的像素信息 uint8_t *pixels;//uint8_t char java byte *pixels可以当byte[] AndroidBitmap_lockPixels(env, bitmap, (void **) &amp;pixels); //jpeg argb中去掉他的a ===&gt;rgb int w = info.width; int h = info.height; int color; //开一块内存用来存入rgb信息 uint8_t *data = (uint8_t *) malloc(w * h * 3);//data中可以存放图片的所有内容 uint8_t *temp = data; uint8_t r, g, b;//byte //循环取图片的每一个像素 for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { color = *(int *) pixels;//0-3字节 color4 个字节 一个点 //取出rgb r = (color &gt;&gt; 16) &amp; 0xFF;// #00rrggbb 16 0000rr 8 00rrgg g = (color &gt;&gt; 8) &amp; 0xFF; b = color &amp; 0xFF; //存放，以前的主流格式jpeg bgr *data = b; *(data + 1) = g; *(data + 2) = r; data += 3; //指针跳过4个字节 pixels += 4; } } //把得到的新的图片的信息存入一个新文件 中 write_JPEG_file(temp, w, h, q, path); //释放内存 free(temp); AndroidBitmap_unlockPixels(env, bitmap); env-&gt;ReleaseStringUTFChars(path_, path); } 123456789101112131415**调用代码** ```javapublic class JpegUtils { static { System.loadLibrary(&quot;jpeg-yk&quot;); } /** * A native method that is implemented by the 'native-lib' native library, * which is packaged with this application. */ public native static void native_Compress(Bitmap bitmap, int q, String path);} 1234567891011121314151617## 效果1. 开始压缩 ```java public void click(View view) { File input = new File(Environment.getExternalStorageDirectory(), &quot;/girl.jpg&quot;); ImageView preImg = findViewById(R.id.pre); mNextImg = findViewById(R.id.next); inputBitmap = BitmapFactory.decodeFile(input.getAbsolutePath()); preImg.setImageBitmap(inputBitmap); JpegUtils .native_Compress(inputBitmap, 10, Environment.getExternalStorageDirectory() + &quot;/girl4.jpg&quot;); Toast.makeText(this, &quot;执行完成&quot;, Toast.LENGTH_SHORT).show(); String filePath = Environment.getExternalStorageDirectory() + &quot;/girl4.jpg&quot;; mNextImg.setImageBitmap(BitmapFactory.decodeFile(filePath)); } 动画效果 压缩效果: 压缩质量在 10 的时候用压缩出来的质量也还是挺好了，只有周围有点点模糊，但是建议压缩质量在 30 -50 之间。 压缩率: 大约压缩后的图片大小是原图的缩小 6 倍的样子。 资料更多代码信息请移步 GitHub提供 libjpeg 编译脚本libjpeg 编译的源码和动态/静态库 在 dist 目录 提取码：b0cs计划图片优化计划出三篇文章 libjpeg 编译及使用 长图巨图优化 bitmap 内存管理 三级缓存","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%9B-%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/"},{"title":"性能优化 (十二) 体积优化之极限瘦身","text":"简介随着项目的不断迭代，代码量跟资源文件不断增多。那么就会出现打包后的 APK 文件越来越大，如果突然有一天你们老板或领导叫你优化 APK 大小，你还不知道怎么优化那就有点说不过去了，这篇文章咱们就来一起分析并优化 APK 体积大小吧。 分析 APK 资源占用注意 这里面是在 GitHub 找了一个人气比较高的开源项目，需要的话自己可以点击下载，自己动手尝试一番. 分析工具直接用的 AS Build/Analyze APK 从上面图中得出 assets &gt; classes.dex &gt; res &gt; lib 其中资源文件占用最大。 下面我们就来看看怎么减小 APK 大小吧， 优化 APK 体积八大步1. 将图片转换为 webp 格式Webp 概念WebP 是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自视频编码格式 VP8。WebP 最初在2010年发布，目标是减少文件大小，但达到 和 JEPG 格式相同的图片质量，希望能够减少图片档在网络上的发送时间。2011年11月8日，Google 开始让 WebP 支持无损压缩和透明色的功能。 根据 Google 较早的测试，WebP 的无损压缩比网络上找到的 PNG 档少了 45％ 的文件大小，即使这些 PNG 档在使用 PNGCRUSH 和 PNGOUT 处理过，WebP 还是可以减少 28％ 的文件大小。就目前而言，Webp 可以让图片大小平均减少 70% 。WebP 是未来图片格式的发展趋势。 PNG / JPG to Webp 点击图片或者文件夹右键选择 Convert to Webp 格式，将 png / jpg 图片压缩为 webp 格式图片. 最后我们只减少了不到 200 kb 左右，有可能项目图片资源本来就没有多大，只是太多小图片导致的。 应用场景及优势 客户端软件，内嵌了基于 Chromium 的 webview，这类浏览器中应用的网页是可以完全使用WebP 格式，提升加载渲染速度，不考虑兼容。 用 node-webkit 开发的程序，用 WebP 可以减少文件包的体积。 移动应用 或 网页游戏 ,界面需要大量图片,可以嵌入 WebP 的解码包，能够节省用户流量，提升访问速度优势： 对于 PNG 图片，WebP 比 PNG 小了45%。 2. 去除多语言在 app/build.gradle 添加 12345678android{ ... defaultConfig{ ... //只保留英语 resConfigs \"en\" }} 这里我们发现减少了大概 200 kb 3. 去除不必要 so 库通过反编译 Android 微信版本 得知，微信也只适配了 armeabi-v7a 架构，那么我们删掉其它库的支持吧。 12345678910android{ ... defaultConfig{ ... ndk { //设置支持的SO库架构 abiFilters \"armeabi-v7a\" }}} 又优化了差不多 600 kb ,继续。 4. 去除无用资源 Link 检查（谨慎删除）概念Lint 是 Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码结构 / 质量问题，同时提供一些解决方案，而且这个过程不需要我们手写测试用例。代码迭代版本一多，很容易会遗留一些无用的代码、资源文件，我们可以使用 Lint 进行清除。 优化 发现我们 link 大概优化了 700 kb继续。 注意因为 link 是检查有没有引用来做的判断是否使用了资源，那么如果是这种方式勒，所以在删除的时候一定要谨慎。 12//动态获取资源 id , 未直接使用 R.xx.xx ，则这个 id 代表的资源会被认为没有使用过(类似不能混淆反射类)int indetifier =getResources().getIdentifier(\"img_bubble_receive\", \"drawable\", getPackageName()); getResources().getDrawable(indetifier); 5. 开启混淆如果有不了解 混淆 是什么的可以建议去看下我上一遍文章 性能优化 (十一) ProGuard 对代码和资源压缩 优化了 1.7M 继续。 6.移除无用资源 shinkResource 开启 shinkResource = true 12345678910111213buildTypes { release { minifyEnabled true shrinkResources = true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } debug { shrinkResources = true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' }} 这个有可能 link 删除了无用资源，所以没有在优化了 7.开启删除无用资源 (严格模式和普通模式) - 这个我这里就不可测试，你们下来可以测试下效果普通模式也就是自定义模式如果您有想要保留或舍弃的特定资源，请在您的项目中创建一个包含 &lt;resources&gt; 标记的 XML 文件，并在 tools:keep 属性中指定每个要保留的资源，在 tools:discard 属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。您可以使用星号字符作为通配符。 例如： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:keep=\"@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*\" tools:discard=\"@layout/unused2\" /&gt; 将该文件保存在项目资源中，例如，保存在 res/raw/keep.xml。构建不会将该文件打包到 APK 之中。 指定要舍弃的资源可能看似愚蠢，因为您本可将它们删除，但在使用构建变体时，这样做可能很有用。例如，如果您明知给定资源表面上会在代码中使用（并因此不会被压缩器移除），但实际不会用于给定构建变体，就可以将所有资源放入公用项目目录，然后为每个构建变体创建一个不同的 keep.xml 文件。构建工具也可能无法根据需要正确识别资源，这是因为编译器会添加内联资源 ID，而资源分析器可能不知道真正引用的资源和恰巧具有相同值的代码中的整数值之间的差别。 严格模式正常情况下，资源压缩器可准确判定系统是否使用了资源。不过，如果您的代码调用 Resources.getIdentifier()（或您的任何库进行了这一调用 - AppCompat 库会执行该调用），这就表示您的代码将根据动态生成的字符串查询资源名称。当您执行这一调用时，默认情况下资源压缩器会采取防御性行为，将所有具有匹配名称格式的资源标记为可能已使用，无法移除。 例如，以下代码会使所有带 img_ 前缀的资源标记为已使用。 12String name = String.format(\"img_%1d\", angle + 1);res = getResources().getIdentifier(name, \"drawable\", getPackageName()); 资源压缩器还会浏览代码以及各种 res/raw/ 资源中的所有字符串常量，寻找格式类似于 file:///android_res/drawable//ic_plus_anim_016.png 的资源网址。如果它找到与其类似的字符串，或找到其他看似可用来构建与其类似的网址的字符串，则不会将它们移除。 这些是默认情况下启用的安全压缩模式的示例。但您可以停用这一“有备无患”处理方式，并指定资源压缩器只保留其确定已使用的资源。要执行此操作，请在 keep.xml 文件中将 shrinkMode 设置为 strict，如下所示： 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:shrinkMode=\"strict\" /&gt; 如果您确已启用严格压缩模式，并且代码也引用了包含动态生成字符串的资源（如上所示），则必须利用 tools:keep 属性手动保留这些资源。 8. AndResGuard 微信资源压缩方案什么是 AndResGuardAndResGuard 是一个缩小 APK 大小的工具，它的原理类似 Java Proguard ，但是只针对资源。它会将原本冗长的资源路径变短，例如将 res/drawable/wechat 变为 r/d/a。 为什么使用 AndResGuard在以往的开发中，我们通常只混淆了代码，资源文件却暴露在他人面前，res 文件夹下所有文件名的可读性过强。 使用后的效果 AndResGuard 的配置 项目根目录下 build.gradle 中，添加插件的依赖： 123dependencies { classpath 'com.tencent.mm:AndResGuard-gradle-plugin:1.2.16' } 在 app 目录下，创建 and_res_guard.gradle 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364apply plugin: 'AndResGuard'andResGuard { mappingFile = null use7zip = true useSign = true keepRoot = false compressFilePattern = [ \"*.png\", \"*.jpg\", \"*.jpeg\", \"*.gif\", \"resources.arsc\" ] whiteList = [ // your icon \"R.drawable.icon\", // for fabric \"R.string.com.crashlytics.*\", // for umeng update \"R.string.tb_*\", \"R.layout.tb_*\", \"R.drawable.tb_*\", \"R.drawable.u1*\", \"R.drawable.u2*\", \"R.color.tb_*\", // umeng share for sina \"R.drawable.sina*\", // for google-services.json \"R.string.google_app_id\", \"R.string.gcm_defaultSenderId\", \"R.string.default_web_client_id\", \"R.string.ga_trackingId\", \"R.string.firebase_database_url\", \"R.string.google_api_key\", \"R.string.google_crash_reporting_api_key\", //友盟 \"R.string.umeng*\", \"R.string.UM*\", \"R.layout.umeng*\", \"R.drawable.umeng*\", \"R.id.umeng*\", \"R.anim.umeng*\", \"R.color.umeng*\", \"R.style.*UM*\", \"R.style.umeng*\", //融云 \"R.drawable.u*\", \"R.drawable.rc_*\", \"R.string.rc_*\", \"R.layout.rc_*\", \"R.color.rc_*\", \"R.id.rc_*\", \"R.style.rc_*\", \"R.dimen.rc_*\", \"R.array.rc_*\" ] sevenzip { artifact = 'com.tencent.mm:SevenZip:1.2.10' }} 在 app 模块下的 build.gradle 文件添加 1apply from: 'and_res_guard.gradle' 打包完之后效果图 资源压缩了大概 1M 总结 项目体积越大，资源越多，效果就越明显。 使用 Link 删除资源的话，一定要谨慎，提前做好备份。 咱们这里因为项目本身只有 10 M 多，最后优化了 4.5 M 下去。也还是很不容易的。","link":"/2020/06/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8D%81%E4%BA%8C-%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96%E4%B9%8B%E6%9E%81%E9%99%90%E7%98%A6%E8%BA%AB/"},{"title":"音视频学习 (七) 音频渲染","text":"前言在讲解音频渲染之前，需要对音频的基础知识有所了解，所以该篇分为基础概念和AudioTrack 以及 OpenSL ES Demo 实例讲解，这样有助于更好的理解 Android 中音频渲染。 音频的基础概念涉及的知识点比较多，该篇文章的上半部分会详细的介绍，后续文章基本上都会涉及音频的开发，有了基础对于后面的内容就更容易上手了。 音频的基础知识声音的物理性质 声音是波 说到声音我相信只要听力正常的人都听见过声音，那么声音是如何产生的呢？记得初中物理课本上的描述 - 声音是由物体的振动而产生的。其实声音是一种压力波，当敲打某个物体或演奏某个乐器时，它们的振动都会引起空气有节奏的振动，使周围的空气产生疏密变化，形成疏密相间的纵波，由此就产生了声波，这种现象会一直延续到振动消失为止。 声波的三要素 声波的三要素是频率、振幅、和波形，频率代表音阶的高低，振幅代表响度，波形代表音色。 声音的传播介质 声音的传播介质很广，它可以通过空气、液体和固体进行传播；而且介质不同，传播的速度也不同，比如声音在空气中的传播速度为 340m/s , 在蒸馏水中的传播速度为 1497 m/s , 而在铁棒中的传播速度则可以高达 5200 m/s ；不过，声音在真空中时无法传播的。 回声 当我们在高山或者空旷地带高声大喊的时候，经常会听到回声，之所以会有回声是因为声音在传播过程中遇到障碍物会反弹回来，再次被我们听到。 但是，若两种声音传到我们的耳朵里的时差小于 80 毫秒，我们就无法区分开这两种声音了，其实在日常生活中，人耳也在收集回声，只不过由于嘈杂的外接环境以及回声的分贝比较低，所以我们的耳朵分辨不出这样的声音，或者说是大脑能接收到但分辨不出。 共鸣 自然界中有光能，水能，生活中有机械能，电能，其实声音也可以产生能量，例如两个频率相同的物体，敲打其中一个物体时另一个物体也会振动发生。这种现象称为共鸣，共鸣证明了声音传播可以带动另一个物体振动，也就是说，声音的传播过程也是一种能量的传播过程。 数字音频上一小节我们主要介绍了声音的物理现象以及声音中常见的概念，也会后续的讲解统一了术语，本节主要介绍数字音频概念。 为了将模拟信号数字化，本节将分为 3 个概念对数字音频进行讲解，分别是采样、量化和编码。首先要对模拟信号进行采样，所谓采样就是在时间轴上对信号进行数字化。根据奈奎斯特定理（也称采样定理），按比声音最高频率高 2 倍以上的频率对声音进行采样，对于高质量的音频信号，其频率范围在 20Hz ~ 20kHz ，所以采样频率一般为 44.1kHz ,这样就保证采样声音达到 20kHz 也能被数字化，从而使得经过数字化处理之后，人耳听到的声音质量不会被降低。而所谓的 44.1 kHz 就是代表 1 s 会采样 44100 次。 那么，具体的每个采样又该如何表示呢？这就涉及到将要讲解的第二个概念: 量化。量化是指在幅度轴上对信号进行数字化，比如用 16 bit 的二进制信号来表示声音的一个采样，而 16 bit 所表示的范围是 [-32768 , 32767] , 共有 65536 个可能取值，因此最终模拟的音频信号在幅度上也分为了 65536 层。 既然每一个分量都是一个采样，那么这么多的采样该如何进行存储呢？这就涉及将要讲解的第三个概念: 编码。所谓编码，就是按照一定的格式记录采样和量化后的数字数据，比如顺序存储或压缩存储等等。 这里涉及了很多中格式，通常所说的音频的裸数据就是 PCM (Pulse Code Modulation) 数据。描述一段 PCM 数据一般需要以下几个概念：量化格式(sampleFormat)、采样率（sampleRate）、声道数 (channel) 。以 CD 的音质为例：量化格式为 16 bit （2 byte）,采样率 44100 ，声道数为 2 ，这些信息就描述了 CD 的音质。而对于声音的格式，还有一个概念用来描述它的大小，称为数据比特率，即 1s 时间内的比特数目，它用于衡量音频数据单位时间内的容量大小。而对于 CD 音质的数据，比特率为多少呢？ 计算如下: 144100 * 16 * 2 = 1378.125 kbps 那么在一分钟里，这类 CD 音质的数据需要占据多大的存储空间呢？计算如下: 11378.125 * 60 / 8 / 1024 = 10.09 MB 当然，如果 sampleFormat 更加精确 (比如用 4 个字节来描述一个采样)，或者 sampleRate 更加密集 (比如 48kHz 的采样率)， 那么所占的存储空间就会更大，同时能够描述的声音细节就会越精确。存储的这段二进制数据即表示将模拟信号转为数字信号了，以后就可以对这段二进制数据进行存储，播放，复制，或者进行其它操作。 音频编码上面提到了 CD 音质的数据采样格式，曾计算出每分钟需要的存储空间约为 10.09 MB ,如果仅仅是将其存储在光盘或者硬盘中，可能是可以接受的，但是若要在网络中实时在线传输的话，那么这个数据量可能就太大了，所以必须对其进行压缩编码。压缩编码的基本指标之一就是压缩比，压缩比通常小于 1 。压缩算法包括有损压缩和无损压缩。无所压缩是指解压后的数据可以完全复原。在常用的压缩格式中，用的较多的是有损压缩，有损压缩是指解压后的数据不能完全恢复，会丢失一部分信息，压缩比越小，丢失的信息就比越多，信号还原后的失真就会越大。根据不同的应用场景 (包括存储设备、传输网络环境、播放设备等)，可以选用不同的压缩编码算法，如 PCM 、WAV、AAC 、MP3 、Ogg 等。 WAV 编码 WAV 编码就是在 PCM 数据格式的前面加了 44 个字节，分别用来存储 PCM 的采样率、声道数、数据格式等信息。 特点: 音质好，大量软件支持。 场景: 多媒体开发的中间文件、保存音乐和音效素材。 MP3 编码 MP3 具有不错的压缩比，使用 LAME 编码 （MP3 编码格式的一种实现）的中高码率的 MP3 文件，听感上非常接近源 WAV 文件，当然在不同的应用场景下，应该调整合适的参数以达到最好的效果。 特点: 音质在 128 Kbit/s 以上表现还不错，压缩比比较高，大量软件和硬件都支持，兼容性好。 场景: 高比特率下对兼容性有要求的音乐欣赏。 AAC 编码 AAC 是新一代的音频有损压缩技术，它通过一些附加的编码技术(比如 PS 、SBR) 等，衍生出了 LC-AAC 、HE-AAC 、HE-AAC v2 三种主要的编码格式。LC-AAC 是比较传统的 AAC ,相对而言，其主要应用于中高码率场景的编码 (&gt;=80Kbit/s) ; HE-AAC 相当于 AAC + SBR 主要应用于中低码率的编码 （&lt;= 80Kbit/s）; 而新推出的 HE-AAC v2 相当于 AAC + SBR + PS 主要用于低码率场景的编码 (&lt;= 48Kbit/s) 。事实上大部分编码器都设置为 &lt;= 48Kbit/s 自动启用 PS 技术，而 &gt; 48Kbit/s 则不加 PS ，相当于普通的 HE-AAC。 特点: 在小于 128Kbit/s 的码率下表现优异，并且多用于视频中的音频编码。 场景: 128 Kbit/s 以下的音频编码，多用于视频中音频轨的编码。 Ogg 编码 Ogg 是一种非常有潜力的编码，在各种码率下都有比较优秀的表现，尤其是在中低码率场景下。Ogg 除了音质好之外，还是完全免费的，这为 Ogg 获得更多的支持打好了基础，Ogg 有着非常出色的算法，可以用更小的码率达到更好的音质，128 Kbit/s 的 Ogg 比 192kbit/s 甚至更高码率的 MP3 还要出色。但是目前因为还没有媒体服务软件的支持，因此基于 Ogg 的数字广播还无法实现。Ogg 目前受支持的情况还不够好，无论是软件上的还是硬件上的支持，都无法和 MP3 相提并论。 特点: 可以用比 MP3 更小的码率实现比 MP3 更好的音质，高中低码率下均有良好的表现，兼容性不够好，流媒体特性不支持。 场景: 语言聊天的音频消息场景。 Android 平台下的音频渲染音频基础概念上面讲完了，下面我们实现 Android 下的音频渲染，为实现音视频播放器打下一个基础，音视频采集视频录制的时候在讲解。 [PCM 文件 - 链接:https://pan.baidu.com/s/1ISS7bHMrFAentLB6o4kiBA 密码:5z1n](链接:https://pan.baidu.com/s/1ISS7bHMrFAentLB6o4kiBA 密码:5z1n) AudioTrack 的使用由于 AudioTrack 是 Android SDK 层提供的最底层的 音频播放 API,因此只允许输入裸数据 PCM 。和 MediaPlayer 相比，对于一个压缩的音频文件(比如 MP3 、AAC 等文件)，它只需要自行实现解码操作和缓冲区控制。因为这里只涉及 AudioTrack 的音频渲染端，编解码我们后面在讲解，所以本小节只介绍如何使用 AudioTrack 渲染音频 PCM 裸数据。 配置 AudioTrack 12public AudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode) streamType：Android 手机提供了多重音频管理策略，当系统又多个进程需要播放音频的时候，管理策略会决定最终的呈现效果，该参数的可选值将以常量的形式定义在类 AudioManager 中，主要包括以下内容: 123456789101112/**电话铃声 */public static final int STREAM_VOICE_CALL = AudioSystem.STREAM_VOICE_CALL;/** 系统铃声 */public static final int STREAM_SYSTEM = AudioSystem.STREAM_SYSTEM;/** 铃声*/public static final int STREAM_RING = AudioSystem.STREAM_RING;/** 音乐声 */public static final int STREAM_MUSIC = AudioSystem.STREAM_MUSIC;/** 警告声 */public static final int STREAM_ALARM = AudioSystem.STREAM_ALARM;/** 通知声 */public static final int STREAM_NOTIFICATION = AudioSystem.STREAM_NOTIFICATION; sampleRateInHz：采样率，即播放的音频每秒钟会有没少次采样，可选用的采样频率列表为: 8000 , 16000 , 22050 , 24000 ,32000 , 44100 , 48000 等，大家可以根据自己的应用场景进行合理的选择。 channelConfig: 声道数的配置，可选值以常量的形式配置在类 AudioFormat 中，常用的是 CHANNEL_IN_MONO (单声道)、CHANNEL_IN_STEREO (双声道) ，因为现在大多数手机的麦克风都是伪立体声采集，为了性能考虑，建议使用单声道进行采集。 audioFormat: 该参数是用来配置 “数据位宽” 的，即采样格式，可选值以常量的形式定义在类 AudioFormat 中，分别为 ENCODING_PCM_16BIT (兼容所有手机)、ENCODING_PCM_8BIT ， bufferSizeInBytes: 配置内部的音频缓冲区的大小， AudioTrack 类提供了一个帮助开发者确定的 bufferSizeInBytes 的函数，其原型具体如下: 1static public int getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat) 在实际开发中，强烈建议由该函数计算出需要传入的缓冲区大小，而不是手动计算。 mode: AudioTrack 提供了两种播放模式，可选的值以常量的形式定义在类 AudioTrack 中，一个是 MODE_STATIC , 需要一次性将所有的数据都写入播放缓冲区中，简单高效，通常用于播放铃声、系统提醒的音频片段；另一个是 MODE_STREAM ，需要按照一定的时间间隔不断地写入音频数据，理论上它可以应用于任何音频播放的场景。 Play 123//当前播放实例是否初始化成功，如果处于初始化成功的状态并且未播放的状态，那么就调用 playif (null != mAudioTrack &amp;&amp; mAudioTrack.getState() != AudioTrack.STATE_UNINITIALIZED &amp;&amp; mAudioTrack.getPlayState() != PLAYSTATE_PLAYING) mAudioTrack.play(); 销毁资源 12345678public void release() { Log.d(TAG, \"==release===\"); mStatus = Status.STATUS_NO_READY; if (mAudioTrack != null) { mAudioTrack.release(); mAudioTrack = null; }} 具体实例请移步 AudioPlay 项目的 AudioTracker 部分，需要把项目中 raw 目录下的 pcm 文件放入 sdcard 跟目录中。 OpenSL ES 的使用OpenSL ES 官方文档 OpenSL ES 全称(Open Sound Library for Embedded System) ,即嵌入式音频加速标准。OpenSL ES 是无授权费、跨平台、针对嵌入式系统精心优化的硬件音频加速 API ，它能为嵌入式移动多媒体设备上的本地应用程序开发者提供了标准化、高性能、低响应时间的音频功能实现方法，同时还实现了软/硬音频性能的直接跨平台部署，不仅降低了执行难度，而且还促进了高级音频市场的发展。 上图描述了 OpenSL ES 的架构，在 Android 中，High Level Audio Libs 是音频 Java 层 API 输入输出，属于高级 API , 相对来说，OpenSL ES 则是比价低层级的 API, 属于 C 语言 API 。在开发中，一般会直接使用高级 API , 除非遇到性能瓶颈，如语音实时聊天、3D Audio 、某些 Effects 等，开发者可以直接通过 C/C++ 开发基于 OpenSL ES 音频的应用。 在使用 OpenSL ES 的 API 之前，需要引入 OpenSL ES 的头文件，代码如下: 1234// 这是标准的OpenSL ES库#include &lt;SLES/OpenSLES.h&gt;// 这里是针对安卓的扩展，如果要垮平台则需要注意#include &lt;SLES/OpenSLES_Android.h&gt; 创建引擎并获取引擎接口 1234567891011121314151617181920212223void createEngine() { // 音频的播放，就涉及到了，OpenLSES // TODO 第一大步：创建引擎并获取引擎接口 // 1.1创建引擎对象：SLObjectItf engineObject SLresult result = slCreateEngine(&amp;engineObj, 0, NULL, 0, NULL, NULL); if (SL_RESULT_SUCCESS != result) { return; } // 1.2 初始化引擎 result = (*engineObj) -&gt;Realize(engineObj, SL_BOOLEAN_FALSE); if (SL_BOOLEAN_FALSE != result) { return; } // 1.3 获取引擎接口 SLEngineItf engineInterface result = (*engineObj) -&gt;GetInterface(engineObj, SL_IID_ENGINE, &amp;engine); if (SL_RESULT_SUCCESS != result) { return; } } 设置混音器 12345678910111213// TODO 第二大步 设置混音器 // 2.1 创建混音器：SLObjectItf outputMixObject result = (*engine)-&gt;CreateOutputMix(engine, &amp;outputMixObj, 0, 0, 0); if (SL_RESULT_SUCCESS != result) { return; } // 2.2 初始化 混音器 result = (*outputMixObj)-&gt;Realize(outputMixObj, SL_BOOLEAN_FALSE); if (SL_BOOLEAN_FALSE != result) { return; } 创建播放器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// TODO 第三大步 创建播放器 // 3.1 配置输入声音信息 // 创建buffer缓冲类型的队列 2个队列 SLDataLocator_AndroidSimpleBufferQueue locBufq = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 2}; // pcm数据格式 // SL_DATAFORMAT_PCM：数据格式为pcm格式 // 2：双声道 // SL_SAMPLINGRATE_44_1：采样率为44100（44.1赫兹 应用最广的，兼容性最好的） // SL_PCMSAMPLEFORMAT_FIXED_16：采样格式为16bit （16位）(2个字节) // SL_PCMSAMPLEFORMAT_FIXED_16：数据大小为16bit （16位）（2个字节） // SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT：左右声道（双声道） （双声道 立体声的效果） // SL_BYTEORDER_LITTLEENDIAN：小端模式 SLDataFormat_PCM formatPcm = {SL_DATAFORMAT_PCM, (SLuint32) mChannels, mSampleRate, (SLuint32) mSampleFormat, (SLuint32) mSampleFormat, mChannels == 2 ? 0 : SL_SPEAKER_FRONT_CENTER, SL_BYTEORDER_LITTLEENDIAN}; /* * Enable Fast Audio when possible: once we set the same rate to be the native, fast audio path * will be triggered */ if (mSampleRate) { formatPcm.samplesPerSec = mSampleRate; } // 数据源 将上述配置信息放到这个数据源中 SLDataSource audioSrc = {&amp;locBufq, &amp;formatPcm}; // 3.2 配置音轨（输出） // 设置混音器 SLDataLocator_OutputMix locOutpuMix = {SL_DATALOCATOR_OUTPUTMIX, mAudioEngine-&gt;outputMixObj}; SLDataSink audioSink = {&amp;locOutpuMix, nullptr}; /* * create audio player: * fast audio does not support when SL_IID_EFFECTSEND is required, skip it * for fast audio case */ // 需要的接口 操作队列的接口 const SLInterfaceID ids[3] = {SL_IID_BUFFERQUEUE, SL_IID_VOLUME, SL_IID_EFFECTSEND}; const SLboolean req[3] = {SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE}; // 3.3 创建播放器 result = (*mAudioEngine-&gt;engine)-&gt;CreateAudioPlayer(mAudioEngine-&gt;engine, &amp;mPlayerObj, &amp;audioSrc, &amp;audioSink, mSampleRate ? 2 : 3, ids, req); if (result != SL_RESULT_SUCCESS) { LOGE(\"CreateAudioPlayer failed: %d\", result); return false; } // 3.4 初始化播放器：mPlayerObj result = (*mPlayerObj)-&gt;Realize(mPlayerObj, SL_BOOLEAN_FALSE); if (result != SL_RESULT_SUCCESS) { LOGE(\"mPlayerObj Realize failed: %d\", result); return false; }// 3.5 获取播放器接口：SLPlayItf mPlayerObj result = (*mPlayerObj)-&gt;GetInterface(mPlayerObj, SL_IID_PLAY, &amp;mPlayer); if (result != SL_RESULT_SUCCESS) { LOGE(\"mPlayerObj GetInterface failed: %d\", result); return false; } 设置播放回调函数 12345678910111213141516171819202122232425262728// TODO 第四大步：设置播放回调函数 // 4.1 获取播放器队列接口：SLAndroidSimpleBufferQueueItf mBufferQueue result = (*mPlayerObj)-&gt;GetInterface(mPlayerObj, SL_IID_BUFFERQUEUE, &amp;mBufferQueue); if (result != SL_RESULT_SUCCESS) { LOGE(\"mPlayerObj GetInterface failed: %d\", result); return false; }// 4.2 设置回调 void playerCallback(SLAndroidSimpleBufferQueueItf bq, void *context) result = (*mBufferQueue)-&gt;RegisterCallback(mBufferQueue, playerCallback, this); if (result != SL_RESULT_SUCCESS) { LOGE(\"mPlayerObj RegisterCallback failed: %d\", result); return false; } mEffectSend = nullptr; if (mSampleRate == 0) { result = (*mPlayerObj)-&gt;GetInterface(mPlayerObj, SL_IID_EFFECTSEND, &amp;mEffectSend); if (result != SL_RESULT_SUCCESS) { LOGE(\"mPlayerObj GetInterface failed: %d\", result); return false; } } result = (*mPlayerObj)-&gt;GetInterface(mPlayerObj, SL_IID_VOLUME, &amp;mVolume); if (result != SL_RESULT_SUCCESS) { LOGE(\"mPlayerObj GetInterface failed: %d\", result); return false; } 设置播放器状态 123456// TODO 第五大步：设置播放器状态为播放状态result = (*mPlayer)-&gt;SetPlayState(mPlayer, SL_PLAYSTATE_PLAYING);if (result != SL_RESULT_SUCCESS) { LOGE(\"mPlayerObj SetPlayState failed: %d\", result); return false;} 手动激活回调函数 12345678910111213141516171819void OpenSLAudioPlay::enqueueSample(void *data, size_t length) { // 必须等待一帧音频播放完毕后才可以 Enqueue 第二帧音频 pthread_mutex_lock(&amp;mMutex); if (mBufSize &lt; length) { mBufSize = length; if (mBuffers[0]) { delete[] mBuffers[0]; } if (mBuffers[1]) { delete[] mBuffers[1]; } mBuffers[0] = new uint8_t[mBufSize]; mBuffers[1] = new uint8_t[mBufSize]; } memcpy(mBuffers[mIndex], data, length); // TODO 第六步：手动激活回调函数 (*mBufferQueue)-&gt;Enqueue(mBufferQueue, mBuffers[mIndex], length); mIndex = 1 - mIndex;} 释放资源 1234567891011121314extern \"C\"JNIEXPORT void JNICALLJava_com_devyk_audioplay_AudioPlayActivity_nativeStopPcm(JNIEnv *env, jclass type) { isPlaying = false; if (slAudioPlayer) { slAudioPlayer-&gt;release(); delete slAudioPlayer; slAudioPlayer = nullptr; } if (pcmFile) { fclose(pcmFile); pcmFile = nullptr; }} 完整的代码请参考仓库中 OpenSL ES部分。注意：需要把 raw 中的 pcm 文件放入 sdcard 根目录下。 总结该篇文章主要介绍了音频的一些基础知识和使用 AudioTrack 以及 OpenSL ES 来渲染裸流音频数据。大家可以根据我的源代码中在加深理解。 最后的页面效果: 感谢 音视频开发进阶指南-展晓凯 https://www.jianshu.com/p/5513a181580f","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E9%9F%B3%E9%A2%91%E6%B8%B2%E6%9F%93/"},{"title":"音视频学习 (九) FFmpeg + librtmp 实现拉流播放器","text":"前言现在一个 APP 玩的花样是越来越多了几乎都离不开音频、视频、图片等数据显示，该篇就介绍其中的音视频播放，音视频播放可以用已经成熟开源的播放器，(推荐一个不错的播放器开源项目GSYVideoPlayer)。如果用已开源的播放器就没有太大的学习意义了，该篇文章会介绍从 0~1 开发一款 Android 播放器流程和实例代码编写。 开发一款播放器你首先要具备的知识有: FFmpeg RTMP 混合交叉编译 C/C++ 基础 NDK、JNI 音视频解码、同步 学完之后我们的播放器大概效果如下: 效果看起来有点卡，这跟实际网络环境有关，此播放器已具备 rtmp/http/URL/File 等协议播放。 RTMP 与 FFmpeg 混合编译RTMP介绍: RTMP 是 Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash/AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media Server/red5 等。RTMP 与 HTTP 一样，都属于 TCP/IP 四层模型的应用层。 下载: 1git clone https://github.com/yixia/librtmp.git 脚本编写: 123456789101112131415161718#!/bin/bash#配置NDK 环境变量NDK_ROOT=$NDK_HOME#指定 CPUCPU=arm-linux-androideabi#指定 Android APIANDROID_API=17TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64export XCFLAGS=\"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API\"export XLDFLAGS=\"--sysroot=${NDK_ROOT}/platforms/android-17/arch-arm \"export CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-make install SYS=android prefix=`pwd`/result CRYPTO= SHARED= XDEF=-DNO_SSL 如果出现如下效果就证明编译成功了: 混合编译上一篇文章咱们编译了 FFmpeg 静态库，那么该小节咱们要把 librtmp 集成到 FFmpeg 中编译，首先我们需要到 configure 脚本中把 librtmp 模块注释掉，如下: 修改 FFmpeg 编译脚本: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/bash#NDK_ROOT 变量指向ndk目录NDK_ROOT=$NDK_HOME#TOOLCHAIN 变量指向ndk中的交叉编译gcc所在的目录TOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64#指定android api版本ANDROID_API=17#此变量用于编译完成之后的库与头文件存放在哪个目录PREFIX=./android/armeabi-v7a#rtmp路径RTMP=/root/android/librtmp/result#执行configure脚本，用于生成makefile#--prefix : 安装目录#--enable-small : 优化大小#--disable-programs : 不编译ffmpeg程序(命令行工具)，我们是需要获得静态(动态)库。#--disable-avdevice : 关闭avdevice模块，此模块在android中无用#--disable-encoders : 关闭所有编码器 (播放不需要编码)#--disable-muxers : 关闭所有复用器(封装器)，不需要生成mp4这样的文件，所以关闭#--disable-filters :关闭视频滤镜#--enable-cross-compile : 开启交叉编译#--cross-prefix: gcc的前缀 xxx/xxx/xxx-gcc 则给xxx/xxx/xxx-#disable-shared enable-static 不写也可以，默认就是这样的。#--sysroot: #--extra-cflags: 会传给gcc的参数#--arch --target-os : 必须要给./configure \\--prefix=$PREFIX \\--enable-small \\--disable-programs \\--disable-avdevice \\--disable-encoders \\--disable-muxers \\--disable-filters \\--enable-librtmp \\--enable-cross-compile \\--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\--disable-shared \\--enable-static \\--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-arm \\--extra-cflags=\"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC -I$RTMP/include\" \\--extra-ldflags=\"-L$RTMP/lib\" \\--extra-libs=\"-lrtmp\" \\--arch=arm \\--target-os=android#上面运行脚本生成makefile之后，使用make执行脚本make cleanmakemake install 如果出现如下，证明开始编译了: 如果出现如下，证明编译成功了: 可以从上图中看到静态库和头文件库都已经编译成功了，下面我们就进入编写代码环节了。 播放器开发流程图想要实现一个网络/本地播放器，我们必须知道它的流程，如下图所示: 项目准备 创建一个新的 Android 项目并导入各自库 CmakeLists.txt 编译脚本编写 12345678910111213141516171819202122232425262728293031323334353637383940cmake_minimum_required(VERSION 3.4.1)#定义 ffmpeg、rtmp 、yk_player 目录set(FFMPEG ${CMAKE_SOURCE_DIR}/ffmpeg)set(RTMP ${CMAKE_SOURCE_DIR}/librtmp)set(YK_PLAYER ${CMAKE_SOURCE_DIR}/player)#指定 ffmpeg 头文件目录include_directories(${FFMPEG}/include)#指定 ffmpeg 静态库文件目录set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -L${FFMPEG}/libs/${CMAKE_ANDROID_ARCH_ABI}\")#指定 rtmp 静态库文件目录set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -L${RTMP}/libs/${CMAKE_ANDROID_ARCH_ABI}\")#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了file(GLOB ALL_CPP ${YK_PLAYER}/*.cpp)#添加自己编写 cpp 源文件生成动态库add_library(YK_PLAYER SHARED ${ALL_CPP})#找系统中 NDK log库find_library(log_lib log)#最后才开始链接库target_link_libraries( YK_PLAYER # 写了此命令不用在乎添加 ffmpeg lib 顺序问题导致应用崩溃 -Wl,--start-group avcodec avfilter avformat avutil swresample swscale -Wl,--end-group z rtmp android #音频播放 OpenSLES ${log_lib} ) 定义 native 函数 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 当前 ffmpeg 版本 */ public native String getFFmpegVersion(); /** * 设置 surface * @param surface */ public native void setSurfaceNative(Surface surface); /** * 做一些准备工作 * @param mDataSource 播放气质 */ public native void prepareNative(String mDataSource); /** * 准备工作完成，开始播放 */ public native void startNative(); /** * 如果点击停止播放，那么就调用该函数进行恢复播放 */ public native void restartNative(); /** * 停止播放 */ public native void stopNative(); /** * 释放资源 */ public native void releaseNative(); /** * 是否正在播放 * @return */ public native boolean isPlayerNative(); 解封装根据之前我们的流程图得知在调用设置数据源了之后，ffmpeg 就开始解封装 (可以理解为收到快递包裹，我们需要把包裹打开看看里面是什么，然后拿出来进行归类放置)，这里就是把一个数据源分解成经过编码的音频数据、视频数据、字幕等，下面通过 FFmpeg API 来进行分解数据，代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * 该函数是真正的解封装，是在子线程开启并调用的。 */void YKPlayer::prepare_() { LOGD(\"第一步 打开流媒体地址\"); //1. 打开流媒体地址(文件路径、直播地址) // 可以初始为NULL，如果初始为NULL，当执行avformat_open_input函数时，内部会自动申请avformat_alloc_context，这里干脆手动申请 // 封装了媒体流的格式信息 formatContext = avformat_alloc_context(); //字典: 键值对 AVDictionary *dictionary = 0; av_dict_set(&amp;dictionary, \"timeout\", \"5000000\", 0);//单位是微妙 /** * * @param AVFormatContext: 传入一个 format 上下文是一个二级指针 * @param const char *url: 播放源 * @param ff_const59 AVInputFormat *fmt: 输入的封住格式，一般让 ffmpeg 自己去检测，所以给了一个 0 * @param AVDictionary **options: 字典参数 */ int result = avformat_open_input(&amp;formatContext, data_source, 0, &amp;dictionary); //result -13--&gt; 没有读写权限 //result -99--&gt; 第三个参数写 NULl LOGD(\"avformat_open_input--&gt; %d，%s\", result, data_source); //释放字典 av_dict_free(&amp;dictionary); if (result) {//0 on success true // 你的文件路径，或，你的文件损坏了，需要告诉用户 // 把错误信息，告诉给Java层去（回调给Java） if (pCallback) { pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_CAN_NOT_OPEN_URL); } return; } //第二步 查找媒体中的音视频流的信息 LOGD(\"第二步 查找媒体中的音视频流的信息\"); result = avformat_find_stream_info(formatContext, 0); if (result &lt; 0) { if (pCallback) { pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_CAN_NOT_FIND_STREAMS); return; } } //第三步 根据流信息，流的个数，循环查找，音频流 视频流 LOGD(\"第三步 根据流信息，流的个数，循环查找，音频流 视频流\"); //nb_streams = 流的个数 for (int stream_index = 0; stream_index &lt; formatContext-&gt;nb_streams; ++stream_index) { //第四步 获取媒体流 音视频 LOGD(\"第四步 获取媒体流 音视频\"); AVStream *stream = formatContext-&gt;streams[stream_index]; //第五步 从 stream 流中获取解码这段流的参数信息，区分到底是 音频还是视频 LOGD(\"第五步 从 stream 流中获取解码这段流的参数信息，区分到底是 音频还是视频\"); AVCodecParameters *codecParameters = stream-&gt;codecpar; //第六步 通过流的编解码参数中的编解码 ID ,来获取当前流的解码器 LOGD(\"第六步 通过流的编解码参数中的编解码 ID ,来获取当前流的解码器\"); AVCodec *codec = avcodec_find_decoder(codecParameters-&gt;codec_id); //有可能不支持当前解码 //找不到解码器，重新编译 ffmpeg --enable-librtmp if (!codec) { pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_FIND_DECODER_FAIL); return; } //第七步 通过拿到的解码器，获取解码器上下文 LOGD(\"第七步 通过拿到的解码器，获取解码器上下文\"); AVCodecContext *codecContext = avcodec_alloc_context3(codec); if (!codecContext) { pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_ALLOC_CODEC_CONTEXT_FAIL); return; } //第八步 给解码器上下文 设置参数 LOGD(\"第八步 给解码器上下文 设置参数\"); result = avcodec_parameters_to_context(codecContext, codecParameters); if (result &lt; 0) { pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_CODEC_CONTEXT_PARAMETERS_FAIL); return; } //第九步 打开解码器 LOGD(\"第九步 打开解码器\"); result = avcodec_open2(codecContext, codec, 0); if (result) { pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_OPEN_DECODER_FAIL); return; } //媒体流里面可以拿到时间基 AVRational baseTime = stream-&gt;time_base; //第十步 从编码器参数中获取流类型 codec_type LOGD(\"第十步 从编码器参数中获取流类型 codec_type\"); if (codecParameters-&gt;codec_type == AVMEDIA_TYPE_AUDIO) { audioChannel = new AudioChannel(stream_index, codecContext,baseTime); } else if (codecParameters-&gt;codec_type == AVMEDIA_TYPE_VIDEO) { //获取视频帧 fps //平均帧率 == 时间基 AVRational frame_rate = stream-&gt;avg_frame_rate; int fps_value = av_q2d(frame_rate); videoChannel = new VideoChannel(stream_index, codecContext, baseTime, fps_value); videoChannel-&gt;setRenderCallback(renderCallback); } }//end for //第十一步 如果流中没有音视频数据 LOGD(\"第十一步 如果流中没有音视频数据\"); if (!audioChannel &amp;&amp; !videoChannel) { pCallback-&gt;onErrorAction(THREAD_CHILD, FFMPEG_NOMEDIA); return; } //第十二步 要么有音频 要么有视频 要么音视频都有 LOGD(\"第十二步 要么有音频 要么有视频 要么音视频都有\"); // 准备完毕，通知Android上层开始播放 if (this-&gt;pCallback) { pCallback-&gt;onPrepared(THREAD_CHILD); }} 上面的注释我标注的很全面，这里我们直接跳到第十步，我们知道可以通过如下 codecParameters-&gt;codec_type 函数来进行判断数据属于什么类型，进行进行单独操作。 获取待解码数据(如:H264、AAC)在解封装完成之后我们把待解码的数据放入队列中，如下所示: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 读包 、未解码、音频/视频 包 放入队列 */void YKPlayer::start_() { // 循环 读音视频包 while (isPlaying) { if (isStop) { av_usleep(2 * 1000); continue; } LOGD(\"start_\"); //内存泄漏点 1，解决方法 : 控制队列大小 if (videoChannel &amp;&amp; videoChannel-&gt;videoPackages.queueSize() &gt; 100) { //休眠 等待队列中的数据被消费 av_usleep(10 * 1000); continue; } //内存泄漏点 2 ，解决方案 控制队列大小 if (audioChannel &amp;&amp; audioChannel-&gt;audioPackages.queueSize() &gt; 100) { //休眠 等待队列中的数据被消费 av_usleep(10 * 1000); continue; } //AVPacket 可能是音频 可能是视频，没有解码的数据包 AVPacket *packet = av_packet_alloc(); //这一行执行完毕， packet 就有音视频数据了 int ret = av_read_frame(formatContext, packet); /* if (ret != 0) { return; }*/ if (!ret) { if (videoChannel &amp;&amp; videoChannel-&gt;stream_index == packet-&gt;stream_index) {//视频包 //未解码的 视频数据包 加入队列 videoChannel-&gt;videoPackages.push(packet); } else if (audioChannel &amp;&amp; audioChannel-&gt;stream_index == packet-&gt;stream_index) {//语音包 //将语音包加入到队列中，以供解码使用 audioChannel-&gt;audioPackages.push(packet); } } else if (ret == AVERROR_EOF) { //代表读取完毕了 //TODO---- LOGD(\"拆包完成 %s\", \"读取完成了\") isPlaying = 0; stop(); release(); break; } else { LOGD(\"拆包 %s\", \"读取失败\") break;//读取失败 } }//end while //最后释放的工作 isPlaying = 0; isStop = false; videoChannel-&gt;stop(); audioChannel-&gt;stop();} 通过上面源码我们知道，通过 FFmpeg API av_packet_alloc(); 拿到待解码的指针类型 AVPacket 然后放入对应的音视频队列中，等待解码。 视频解码上一步我们知道，解封装完成之后把对应的数据放入了待解码的队列中，下一步我们就从队列中拿到数据进行解码，如下图所示: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 视频解码 */void VideoChannel::video_decode() { AVPacket *packet = 0; while (isPlaying) { if (isStop) { //线程休眠 10s av_usleep(2 * 1000); continue; } //控制队列大小，避免生产快，消费满的情况 if (isPlaying &amp;&amp; videoFrames.queueSize() &gt; 100) {// LOGE(\"视频队列中的 size :%d\", videoFrames.queueSize()); //线程休眠等待队列中的数据被消费 av_usleep(10 * 1000);//10s continue; } int ret = videoPackages.pop(packet); //如果停止播放，跳出循环，出了循环，就要释放 if (!isPlaying) { LOGD(\"isPlaying %d\", isPlaying); break; } if (!ret) { continue; } //开始取待解码的视频数据包 ret = avcodec_send_packet(pContext, packet); if (ret) { LOGD(\"ret %d\", ret); break;//失败了 } //释放 packet releaseAVPacket(&amp;packet); //AVFrame 拿到解码后的原始数据包 AVFrame *frame = av_frame_alloc(); ret = avcodec_receive_frame(pContext, frame); if (ret == AVERROR(EAGAIN)) { //从新取 continue; } else if (ret != 0) { LOGD(\"ret %d\", ret); releaseAVFrame(&amp;frame);//内存释放 break; } //解码后的视频数据 YUV,加入队列中 videoFrames.push(frame); } //出循环，释放 if (packet) releaseAVPacket(&amp;packet);} 通过上面代码我们得到，主要把待解码的数据放入 avcodec_send_packet 中，然后通过 avcodec_receive_frame 函数来进行接收，最后解码完成的 YUV 数据又放入原始数据队列中，进行转换格式 YUV 转 RGBA在 Android 中并不能直接播放 YUV, 我们需要把它转换成 RGB 的格式然后在调用本地 nativeWindow 或者 OpenGL ES 来进行渲染，下面就直接调用 FFmpeg API 来进行转换，代码如下所示: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void VideoChannel::video_player() { //1. 原始视频数据 YUV ---&gt; rgba /** * sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param) */ SwsContext *swsContext = sws_getContext(pContext-&gt;width, pContext-&gt;height, pContext-&gt;pix_fmt, pContext-&gt;width, pContext-&gt;height, AV_PIX_FMT_RGBA, SWS_BILINEAR, NULL, NULL, NULL); //2. 给 dst_data 申请内存 uint8_t *dst_data[4]; int dst_linesize[4]; AVFrame *frame = 0; /** * pointers[4]：保存图像通道的地址。如果是RGB，则前三个指针分别指向R,G,B的内存地址。第四个指针保留不用 * linesizes[4]：保存图像每个通道的内存对齐的步长，即一行的对齐内存的宽度，此值大小等于图像宽度。 * w: 要申请内存的图像宽度。 * h: 要申请内存的图像高度。 * pix_fmt: 要申请内存的图像的像素格式。 * align: 用于内存对齐的值。 * 返回值：所申请的内存空间的总大小。如果是负值，表示申请失败。 */ int ret = av_image_alloc(dst_data, dst_linesize, pContext-&gt;width, pContext-&gt;height, AV_PIX_FMT_RGBA, 1); if (ret &lt; 0) { printf(\"Could not allocate source image\\n\"); return; } //3. YUV -&gt; rgba 格式转换 一帧一帧的转换 while (isPlaying) { if (isStop) { //线程休眠 10s av_usleep(2 * 1000); continue; } int ret = videoFrames.pop(frame); //如果停止播放，跳出循环，需要释放 if (!isPlaying) { break; } if (!ret) { continue; } //真正转换的函数,dst_data 是 rgba 格式的数据 sws_scale(swsContext, frame-&gt;data, frame-&gt;linesize, 0, pContext-&gt;height, dst_data, dst_linesize); //开始渲染，显示屏幕上 //渲染一帧图像(宽、高、数据) renderCallback(dst_data[0], pContext-&gt;width, pContext-&gt;height, dst_linesize[0]); releaseAVFrame(&amp;frame);//渲染完了，frame 释放。 } releaseAVFrame(&amp;frame);//渲染完了，frame 释放。 //停止播放 flag isPlaying = 0; av_freep(&amp;dst_data[0]); sws_freeContext(swsContext);} 上面代码就是直接通过 sws_scale 该函数来进行 YUV -&gt; RGBA 转换。 渲染 RGBA转换完之后，我们直接调用 ANativeWindow 来进行渲染，代码如下所示: 1234567891011121314151617181920/** * 设置播放 surface */extern \"C\"JNIEXPORT void JNICALLJava_com_devyk_player_1common_PlayerManager_setSurfaceNative(JNIEnv *env, jclass type, jobject surface) { LOGD(\"Java_com_devyk_player_1common_PlayerManager_setSurfaceNative\"); pthread_mutex_lock(&amp;mutex); if (nativeWindow) { ANativeWindow_release(nativeWindow); nativeWindow = 0; } //创建新的窗口用于视频显示窗口 nativeWindow = ANativeWindow_fromSurface(env, surface); pthread_mutex_unlock(&amp;mutex);} 渲染: 12345678910111213141516171819202122232425262728293031323334353637383940/** * * 专门渲染的函数 * @param src_data 解码后的视频 rgba 数据 * @param width 视频宽 * @param height 视频高 * @param src_size 行数 size 相关信息 * */void renderFrame(uint8_t *src_data, int width, int height, int src_size) { pthread_mutex_lock(&amp;mutex); if (!nativeWindow) { pthread_mutex_unlock(&amp;mutex); } //设置窗口属性 ANativeWindow_setBuffersGeometry(nativeWindow, width, height, WINDOW_FORMAT_RGBA_8888); ANativeWindow_Buffer window_buffer; if (ANativeWindow_lock(nativeWindow, &amp;window_buffer, 0)) { ANativeWindow_release(nativeWindow); nativeWindow = 0; pthread_mutex_unlock(&amp;mutex); return; } //填数据到 buffer,其实就是修改数据 uint8_t *dst_data = static_cast&lt;uint8_t *&gt;(window_buffer.bits); int lineSize = window_buffer.stride * 4;//RGBA //下面就是逐行 copy 了。 //一行 copy for (int i = 0; i &lt; window_buffer.height; ++i) { memcpy(dst_data + i * lineSize, src_data + i * src_size, lineSize); } ANativeWindow_unlockAndPost(nativeWindow); pthread_mutex_unlock(&amp;mutex);} 视频渲染就完成了。 音频解码音频的流程跟视频一样，拿到解封装之后的 AAC 数据开始进行解码，代码如下所示: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 音频解码 */void AudioChannel::audio_decode() { //待解码的 packet AVPacket *avPacket = 0; //只要正在播放，就循环取数据 while (isPlaying) { if (isStop) { //线程休眠 10s av_usleep(2 * 1000); continue; } //这里有一个 bug，如果生产快，消费慢，就会造成队列数据过多容易造成 OOM, //解决办法：控制队列大小 if (isPlaying &amp;&amp; audioFrames.queueSize() &gt; 100) {// LOGE(\"音频队列中的 size :%d\", audioFrames.queueSize()); //线程休眠 10s av_usleep(10 * 1000); continue; } //可以正常取出 int ret = audioPackages.pop(avPacket); //条件判断是否可以继续 if (!ret) continue; if (!isPlaying) break; //待解码的数据发送到解码器中 ret = avcodec_send_packet(pContext, avPacket);//@return 0 on success, otherwise negative error code: if (ret)break;//给解码器发送失败了 //发送成功，释放 packet releaseAVPacket(&amp;avPacket); //拿到解码后的原始数据包 AVFrame *avFrame = av_frame_alloc(); //将原始数据发送到 avFrame 内存中去 ret = avcodec_receive_frame(pContext, avFrame);//0:success, a frame was returned if (ret == AVERROR(EAGAIN)) { continue;//获取失败，继续下次任务 } else if (ret != 0) {//说明失败了 releaseAVFrame(&amp;avFrame);//释放申请的内存 break; } //将获取到的原始数据放入队列中，也就是解码后的原始数据 audioFrames.push(avFrame); } //释放packet if (avPacket) releaseAVPacket(&amp;avPacket);} 音视频的逻辑都是一样的就不在多说了。 渲染 PCM渲染 PCM 可以使用 Java 层的 AudioTrack ,也可以使用 NDK 的 OpenSL ES 来渲染，我这里为了性能和更好的对接，直接都在 C++ 中实现了，代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 音频播放 //直接使用 OpenLS ES 渲染 PCM 数据 */void AudioChannel::audio_player() { //TODO 1. 创建引擎并获取引擎接口 // 1.1创建引擎对象：SLObjectItf engineObject SLresult result = slCreateEngine(&amp;engineObject, 0, NULL, 0, NULL, NULL); if (SL_RESULT_SUCCESS != result) { return; } // 1.2 初始化引擎 result = (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE); if (SL_BOOLEAN_FALSE != result) { return; } // 1.3 获取引擎接口 SLEngineItf engineInterface result = (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineInterface); if (SL_RESULT_SUCCESS != result) { return; } //TODO 2. 设置混音器 // 2.1 创建混音器：SLObjectItf outputMixObject result = (*engineInterface)-&gt;CreateOutputMix(engineInterface, &amp;outputMixObject, 0, 0, 0); if (SL_RESULT_SUCCESS != result) { return; } // 2.2 初始化 混音器 result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE); if (SL_BOOLEAN_FALSE != result) { return; } // 不启用混响可以不用获取混音器接口 // 获得混音器接口 // result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB, // &amp;outputMixEnvironmentalReverb); // if (SL_RESULT_SUCCESS == result) { // 设置混响 ： 默认。 // SL_I3DL2_ENVIRONMENT_PRESET_ROOM: 室内 // SL_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM : 礼堂 等 // const SLEnvironmentalReverbSettings settings = SL_I3DL2_ENVIRONMENT_PRESET_DEFAULT; // (*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties( // outputMixEnvironmentalReverb, &amp;settings); // } //TODO 3. 创建播放器 // 3.1 配置输入声音信息 // 创建buffer缓冲类型的队列 2个队列 SLDataLocator_AndroidSimpleBufferQueue loc_bufq = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 2}; // pcm数据格式 // SL_DATAFORMAT_PCM：数据格式为pcm格式 // 2：双声道 // SL_SAMPLINGRATE_44_1：采样率为44100（44.1赫兹 应用最广的，兼容性最好的） // SL_PCMSAMPLEFORMAT_FIXED_16：采样格式为16bit （16位）(2个字节) // SL_PCMSAMPLEFORMAT_FIXED_16：数据大小为16bit （16位）（2个字节） // SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT：左右声道（双声道） （双声道 立体声的效果） // SL_BYTEORDER_LITTLEENDIAN：小端模式 SLDataFormat_PCM format_pcm = {SL_DATAFORMAT_PCM, 2, SL_SAMPLINGRATE_44_1, SL_PCMSAMPLEFORMAT_FIXED_16, SL_PCMSAMPLEFORMAT_FIXED_16, SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT, SL_BYTEORDER_LITTLEENDIAN}; // 数据源 将上述配置信息放到这个数据源中 SLDataSource audioSrc = {&amp;loc_bufq, &amp;format_pcm}; // 3.2 配置音轨（输出） // 设置混音器 SLDataLocator_OutputMix loc_outmix = {SL_DATALOCATOR_OUTPUTMIX, outputMixObject}; SLDataSink audioSnk = {&amp;loc_outmix, NULL}; // 需要的接口 操作队列的接口 const SLInterfaceID ids[1] = {SL_IID_BUFFERQUEUE}; const SLboolean req[1] = {SL_BOOLEAN_TRUE}; // 3.3 创建播放器 result = (*engineInterface)-&gt;CreateAudioPlayer(engineInterface, &amp;bqPlayerObject, &amp;audioSrc, &amp;audioSnk, 1, ids, req); if (SL_RESULT_SUCCESS != result) { return; } // 3.4 初始化播放器：SLObjectItf bqPlayerObject result = (*bqPlayerObject)-&gt;Realize(bqPlayerObject, SL_BOOLEAN_FALSE); if (SL_RESULT_SUCCESS != result) { return; } // 3.5 获取播放器接口：SLPlayItf bqPlayerPlay result = (*bqPlayerObject)-&gt;GetInterface(bqPlayerObject, SL_IID_PLAY, &amp;bqPlayerPlay); if (SL_RESULT_SUCCESS != result) { return; } //TODO 4. 设置播放器回调函数 // 4.1 获取播放器队列接口：SLAndroidSimpleBufferQueueItf bqPlayerBufferQueue (*bqPlayerObject)-&gt;GetInterface(bqPlayerObject, SL_IID_BUFFERQUEUE, &amp;bqPlayerBufferQueue); // 4.2 设置回调 void bqPlayerCallback(SLAndroidSimpleBufferQueueItf bq, void *context) (*bqPlayerBufferQueue)-&gt;RegisterCallback(bqPlayerBufferQueue, bqPlayerCallback, this); //TODO 5. 设置播放状态 (*bqPlayerPlay)-&gt;SetPlayState(bqPlayerPlay, SL_PLAYSTATE_PLAYING); //TODO 6. 手动激活回调函数 bqPlayerCallback(bqPlayerBufferQueue, this);} 设置渲染数据: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 获取 PCM * @return */int AudioChannel::getPCM() { //定义 PCM 数据大小 int pcm_data_size = 0; //原始数据包装类 AVFrame *pcmFrame = 0; //循环取出 while (isPlaying) { if (isStop) { //线程休眠 10s av_usleep(2 * 1000); continue; } int ret = audioFrames.pop(pcmFrame); if (!isPlaying)break; if (!ret)continue; //PCM 处理逻辑 pcmFrame-&gt;data; // 音频播放器的数据格式是我们在下面定义的（16位 双声道 ....） // 而原始数据（是待播放的音频PCM数据） // 所以，上面的两句话，无法统一，一个是(自己定义的16位 双声道 ..) 一个是原始数据，为了解决上面的问题，就需要重采样。 // 开始重采样 int dst_nb_samples = av_rescale_rnd(swr_get_delay(swr_ctx, pcmFrame-&gt;sample_rate) + pcmFrame-&gt;nb_samples, out_sample_rate, pcmFrame-&gt;sample_rate, AV_ROUND_UP); //重采样 /** * * @param out_buffers 输出缓冲区，当PCM数据为Packed包装格式时，只有out[0]会填充有数据。 * @param dst_nb_samples 每个通道可存储输出PCM数据的sample数量。 * @param pcmFrame-&gt;data 输入缓冲区，当PCM数据为Packed包装格式时，只有in[0]需要填充有数据。 * @param pcmFrame-&gt;nb_samples 输入PCM数据中每个通道可用的sample数量。 * * @return 返回每个通道输出的sample数量，发生错误的时候返回负数。 */ ret = swr_convert(swr_ctx, &amp;out_buffers, dst_nb_samples, (const uint8_t **) pcmFrame-&gt;data, pcmFrame-&gt;nb_samples);//返回每个通道输出的sample数量，发生错误的时候返回负数。 if (ret &lt; 0) { fprintf(stderr, \"Error while converting\\n\"); } pcm_data_size = ret * out_sample_size * out_channels; //用于音视频同步 audio_time = pcmFrame-&gt;best_effort_timestamp * av_q2d(this-&gt;base_time); break; } //渲染完成释放资源 releaseAVFrame(&amp;pcmFrame); return pcm_data_size;}/** * 创建播放音频的回调函数 */void bqPlayerCallback(SLAndroidSimpleBufferQueueItf bq, void *context) { AudioChannel *audioChannel = static_cast&lt;AudioChannel *&gt;(context); //获取 PCM 音频裸流 int pcmSize = audioChannel-&gt;getPCM(); if (!pcmSize)return; (*bq)-&gt;Enqueue(bq, audioChannel-&gt;out_buffers, pcmSize);} 代码编写到这里，音视频也都正常渲染了，但是这里还有一个问题，随着播放的时间越久那么就会产生音视频各渲染各的，没有达到同步或者一直播放，这样的体验是非常不好的，所以下一小节我们来解决这个问题。 音视频同步音视频同步市面上有 3 种解决方案: 音频向视频同步，视频向音频同步，音视频统一向外部时钟同步。下面就分别来介绍这三种对齐方式是如何实现的，以及各自的优缺点。 音频向视频同步 先来看一下这种同步方式是如何实现的，音频向视频同步，顾名思义，就是视频会维持一定的刷新频率，或者根据渲染视频帧的时长来决定当前视频帧的渲染时长，或者说视频的每一帧肯定可以全部渲染出来，当我们向 AudioChannel 模块填充音频数据的时候，会与当前渲染的视频帧的时间戳进行比较，这个差值如果不在阀值得范围内，就需要做对齐操作；如果其在阀值范围内，那么就可以直接将本帧音频帧填充到 AudioChannel 模块，进而让用户听到该声音。那如果不在阀值范围内，又该如何进行对齐操作呢？这就需要我们去调整音频帧了，也就是说如果要填充的音频帧的时间戳比当前渲染的视频帧的时间戳小，那就需要进行跳帧操作（可以通过加快速度播放，也可以是丢弃一部分音频帧）；如果音频帧的时间戳比当前渲染的视频帧的时间戳大，那么就需要等待，具体实现可以向 AudioChannel 模块填充空数据进行播放，也可以是将音频的速度放慢播放给用户听，而此时视频帧是继续一帧一帧进行渲染的，一旦视频的时间戳赶上了音频的时间戳，就可以将本帧的音频帧的数据填充到 AudioChannel 模块了，这就是音频向视频同步的实现。 优点: 视频可以将每一帧都播放给用户看，画面看上去是最流畅的。 缺点: 音频会加速或者丢帧，如果丢帧系数小，那么用户感知可能不太强，如果系数大，那么用户感知就会非常的强烈了，发生丢帧或者插入空数据的时候，用户的耳朵是可以明显感觉到的。 视频向音频同步 再来看一下视频向音频同步的方式是如何实现的，这与上面提到的方式恰好相反，由于不论是哪一个平台播放音频的引擎，都可以保证播放音频的时间长度与实际这段音频所代表的时间长度是一致的，所以我们可以依赖于音频的顺序播放为我们提供的时间戳，当客户端代码请求发送视频帧的时候，会先计算出当前视频队列头部的视频帧元素的时间戳与当前音频播放帧的时间戳的差值。如果在阀值范围内，就可以渲染这一帧视频帧；如果不在阀值范围内，则要进行对齐操作。具体的对齐操作方法就是: 如果当前队列头部的视频帧的时间戳小于当前播放音频帧的时间戳，那么就进行跳帧操作；如果大于当前播放音频帧的时间戳，那么就等待(睡眠、重复渲染、不渲染)的操作。 优点 : 音频可以连续的渲染。 缺点 : 视频画面会有跳帧的操作，但是对于视频画面的丢帧和跳帧用户的眼睛是不太容易分辨得出来的。 音视频统一向外部时钟同步 这种策略其实更像是上述两种方式对齐的合体，其实现就是在外部单独维护一轨外部时钟，我们要保证该外部时钟的更新是按照时间的增加而慢慢增加的，当我们获取音频数据和视频帧的时候，都需要与这个外部时钟进行对齐，如果没有超过阀值，那么就会直接返回本帧音频帧或者视频帧，如果超过阀值就要进行对齐操作，具体的对齐操作是: 使用上述两种方式里面的对齐操作，将其分别应用于音频的对齐和视频的对齐。 优点: 可以最大限度的保证音视频都可以不发生跳帧的行为。 缺点: 外部时钟不好控制，极有可能引发音频和视频都跳帧的行为。 同步总结: 根据人眼睛和耳朵的生理构造因素，得出了一个结论，那就是人的耳朵比人的眼睛要敏感的多，那就是说，如果音频有跳帧的行为或者填空数据的行为，那么我们的耳朵是非常容易察觉得到的；而视频如果有跳帧或者重复渲染的行为，我们的眼睛其实不容易分别出来。根据这个理论，所以我们这里也将采用 视频向音频对齐 的方式。 根据得出的结论，我们需要在音频、视频渲染之前修改几处地方，如下所示: 通过 ffmpeg api 拿到音频时间戳 12345678910//1. 在 BaseChannel 里面定义变量,供子类使用//###############下面是音视频同步需要用到的 //FFmpeg 时间基: 内部时间 AVRational base_time; double audio_time; double video_time;//###############下面是音视频同步需要用到的//2. 得到音频时间戳 pcmFrame 解码之后的原始数据帧audio_time = pcmFrame-&gt;best_effort_timestamp * av_q2d(this-&gt;base_time); 视频向音频时间戳对齐(大于小于音频时间戳的处理方式) 12345678910111213141516171819202122232425262728293031323334353637383940//视频向音频时间戳对齐---》控制视频播放速度//在视频渲染之前，根据 fps 来控制视频帧//frame-&gt;repeat_pict = 当解码时，这张图片需要要延迟多久显示double extra_delay = frame-&gt;repeat_pict;//根据 fps 得到延迟时间double base_delay = 1.0 / this-&gt;fpsValue;//得到当前帧的延迟时间double result_delay = extra_delay + base_delay; //拿到视频播放的时间基video_time = frame-&gt;best_effort_timestamp * av_q2d(this-&gt;base_time); //拿到音频播放的时间基double_t audioTime = this-&gt;audio_time; //计算音频和视频的差值double av_time_diff = video_time - audioTime; //说明://video_time &gt; audioTime 说明视频快，音频慢，等待音频//video_time &lt; audioTime 说明视频慢，音屏快，需要追赶音频，丢弃掉冗余的视频包也就是丢帧if (av_time_diff &gt; 0) { //通过睡眠的方式灵活等待 if (av_time_diff &gt; 1) { av_usleep((result_delay * 2) * 1000000); LOGE(\"av_time_diff &gt; 1 睡眠:%d\", (result_delay * 2) * 1000000); } else {//说明相差不大 av_usleep((av_time_diff + result_delay) * 1000000); LOGE(\"av_time_diff &lt; 1 睡眠:%d\", (av_time_diff + result_delay) * 1000000); }} else { if (av_time_diff &lt; 0) { LOGE(\"av_time_diff &lt; 0 丢包处理：%f\", av_time_diff); //视频丢包处理 this-&gt;videoFrames.deleteVideoFrame(); continue; } else { //完美 }} 加上这段代码之后，咱们音视频就算是差不多同步了，不敢保证 100%。 总结音视频播放器已经实现完毕，咱们从解封装-&gt;解码-&gt;音视频同步-&gt;音视频渲染按照流程讲解并编写了实例代码,相信你已经对播放器的流程和架构设计都已经有了一定的认识，等公司有需求的时候也可以自己设计一款播放器并开发出来了。 完整代码已上传 GitHub","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B9%9D-FFmpeg-librtmp-%E5%AE%9E%E7%8E%B0%E6%8B%89%E6%B5%81%E6%92%AD%E6%94%BE%E5%99%A8/"},{"title":"音视频学习 (三) JNI 从入门到掌握","text":"前言音视频系列文章已经发布 2 篇了，C/C++ 基础咱们也已经学完了，那么该篇文章开始就真正进入 NDK 学习了，在进入 NDK 学习之前我们还要学习 JNI 基础。为了保证该系列文章输出，以后尽量一周一篇。 介绍JNI 是 Java 程序设计语言功能功能最强的特征，它允许 Java 类的某些方法原生实现，同时让它们能够像普通 Java 方法一样被调用和使用。这些原生方法也可以使用 Java 对象，使用方法与 Java 代码调用 Java 对象的方法相同。原生方法可以创建新的 Java 对象或者使用 Java 应用程序创建的对象，这些 Java 应用程序可以检查、修改和调用这些对象的方法以执行任务。 环境配置安装 AS + NDK + CMake + LLDB AS: Android 开发工具。 NDK：这套工具集允许为 Android 使用 C 和 C++ 代码。 CMake：一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果只计划使用 ndk-build，则不需要此组件。 LLDB：debug 调式。 local.properties 配置: 12ndk.dir=/Users/devyk/Data/Android/SDK/ndk-bundlesdk.dir=/Users/devyk/Data/Android/SDK build.gradle 配置: 123456789android {... externalNativeBuild { cmake { path \"src/main/cpp/CMakeLists.txt\" version \"3.10.2\" } }} 简单示例 创建 native c++ 工程 根据提示点击 next 基本代码生成 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity { /** * 1. 加载 native 库 */ static { System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.sample_text); /**3.调用 native c++ 函数*/ tv.setText(stringFromJNI()); } /** * 2. 定义 native 函数 */ public native String stringFromJNI();} Native-lib.cpp 代码： 12345678910#include &lt;jni.h&gt;#include &lt;string&gt;extern \"C\" JNIEXPORT jstring JNICALLJava_com_devyk_ndk_1sample_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-&gt;NewStringUTF(hello.c_str());} 运行之后屏幕就会出现 “Hello from C++” 字符串，一个最简单的 native 项目就创建完成了。 JNI 入门学习1. 数据类型和类型描述符Java 中有两种数据类型: 基本数据类型: boolean 、char、byte、int、short、long、float、double。 引用数据类型: String、Object[]、Class、Object 及其它类。 1.1 基本数据类型 基本数据类型可以直接与 C/C++ 的相应基本数据类型映射，如下表所示。JNI 用类型定义使得这种映射对开发人员透明。 Java 类型 JNI 类型 C/C++ 类型 size 位 boolean jboolean unsigned char 8 byte jbyte char 8 char jchar unsingned short 16 short jshort short 16 int jint int 32 long jlong long 64 float jfloat float 32 double jdouble double 64 1.2 引用类型: 与基本数据类型不同，引用类型对原生方法时不透明的，引用类型映射如下表所示。它们的内部数据结构并不直接向原生代码公开。 Java 类型 原生类型 Java.lang.Class jclass Java.lang.Throwable jthrowable Java.lang.String jstring Other objects jobjects Java.lang.Object[] jobjectArray boolean[] jbooleanArray byte[] jbyteArray char[] jcharArray short[] jshortArray int[] jintArray long[] jlongArray float[] jfloatArray double[] jdoubleArray Other arrays jarray 1.3 数据类型描述符 在 JVM 虚拟机中，存储数据类型的名称时，是使用指定的描述符来存储，而不是我们习惯的 int，float 等。 Java 类型 签名 (描述符) boolean Z byte B char C short S int I long J float F double D void V 其它引用类型 L + 全类名 + ； type[] [ method type (参数)返回值 示例: 表示一个 String Java 类型 : java.lang.String JNI 描述符: Ljava/lang/String; (L + 类全名 + ；) 表示一个数组 Java 类型: String[]JNI 描述符: [Ljava/lang/String;Java 类型: int [] []JNI 描述符: [[I 表示一个方法 Java 方法: long func(int n, String s, int[] arr);JNI 描述符: (ILjava/lang/String;[I)J Java 方法: void func();JNI 描述符: ()V 也可以使用命令 : javap -s 全路径 来获取方法签名 2. JNIEnv 和 JavaVm 介绍2.1 JNIEnv : JNIEnv 表示 Java 调用 native 语言的环境，是一个封装了几乎全部 JNI 方法的指针。 JNIEnv 只在创建它的线程生效，不能跨线程传递，不同线程的 JNIEnv 彼此独立。 native 环境中创建的线程，如果需要访问 JNI，必须要调用 AttachCurrentThread 关联，并使用 DetachCurrentThread 解除链接。 2.2 JavaVm : JavaVM 是虚拟机在 JNI 层的代表，一个进程只有一个 JavaVM，所有的线程共用一个 JavaVM。 2.3 代码风格 (C/C++) 123C: (*env)-&gt;NewStringUTF(env, “Hellow World!”);C++: env-&gt;NewStringUTF(“Hellow World!”); 3. JNI API参考官方 API 文档 或者 JNI 方法大全及使用示例 4. 对数据类型的操作JNI 处理 Java 传递过来的数据 定义 native 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends AppCompatActivity { /** * 1. 加载 native 库 */ static { System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** 1. Java 数据传递给 native */ test1(true, (byte) 1, ',', (short) 3, 4, 3.3f, 2.2d, \"DevYK\", 28, new int[]{1, 2, 3, 4, 5, 6, 7}, new String[]{\"1\", \"2\", \"4\"}, new Person(\"阳坤\"), new boolean[]{false, true} ); } /** * Java 将数据传递到 native 中 */ public native void test1( boolean b, byte b1, char c, short s, long l, float f, double d, String name, int age, int[] i, String[] strs, Person person, boolean[] bArray );} jni 处理 Java 传递过来的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#include &lt;iostream&gt;#define TAG \"native-lib\"// __VA_ARGS__ 代表 ...的可变参数#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__);extern \"C\"//支持 C 语言代码JNIEXPORT void JNICALLJava_com_devyk_ndk_1sample_MainActivity_test1(JNIEnv *env, jobject instance, jboolean jboolean1, jbyte jbyte1, jchar jchar1, jshort jshort1, jlong jlong1, jfloat jfloat1, jdouble jdouble1, jstring name_, jint age, jintArray i_, jobjectArray strs, jobject person, jbooleanArray bArray_ ) { //1. 接收 Java 传递过来的 boolean 值 unsigned char b_boolean = jboolean1; LOGD(\"boolean-&gt; %d\", b_boolean); //2. 接收 Java 传递过来的 boolean 值 char c_byte = jbyte1; LOGD(\"jbyte-&gt; %d\", c_byte); //3. 接收 Java 传递过来的 char 值 unsigned short c_char = jchar1; LOGD(\"char-&gt; %d\", c_char); //4. 接收 Java 传递过来的 short 值 short s_short = jshort1; LOGD(\"short-&gt; %d\", s_short); //5. 接收 Java 传递过来的 long 值 long l_long = jlong1; LOGD(\"long-&gt; %d\", l_long); //6. 接收 Java 传递过来的 float 值 float f_float = jfloat1; LOGD(\"float-&gt; %f\", f_float); //7. 接收 Java 传递过来的 double 值 double d_double = jdouble1; LOGD(\"double-&gt; %f\", d_double); //8. 接收 Java 传递过来的 String 值 const char *name_string = env-&gt;GetStringUTFChars(name_, 0); LOGD(\"string-&gt; %s\", name_string); //9. 接收 Java 传递过来的 int 值 int age_java = age; LOGD(\"int:%d\", age_java); //10. 打印 Java 传递过来的 int [] jint *intArray = env-&gt;GetIntArrayElements(i_, NULL); //拿到数组长度 jsize intArraySize = env-&gt;GetArrayLength(i_); for (int i = 0; i &lt; intArraySize; ++i) { LOGD(\"intArray-&gt;%d：\", intArray[i]); } //释放数组 env-&gt;ReleaseIntArrayElements(i_, intArray, 0); //11. 打印 Java 传递过来的 String[] jsize stringArrayLength = env-&gt;GetArrayLength(strs); for (int i = 0; i &lt; stringArrayLength; ++i) { jobject jobject1 = env-&gt;GetObjectArrayElement(strs, i); //强转 JNI String jstring stringArrayData = static_cast&lt;jstring &gt;(jobject1); //转 C String const char *itemStr = env-&gt;GetStringUTFChars(stringArrayData, NULL); LOGD(\"String[%d]: %s\", i, itemStr); //回收 String[] env-&gt;ReleaseStringUTFChars(stringArrayData, itemStr); } //12. 打印 Java 传递过来的 Object 对象 //12.1 获取字节码 const char *person_class_str = \"com/devyk/ndk_sample/Person\"; //12.2 转 jni jclass jclass person_class = env-&gt;FindClass(person_class_str); //12.3 拿到方法签名 javap -a const char *sig = \"()Ljava/lang/String;\"; jmethodID jmethodID1 = env-&gt;GetMethodID(person_class, \"getName\", sig); jobject obj_string = env-&gt;CallObjectMethod(person, jmethodID1); jstring perStr = static_cast&lt;jstring &gt;(obj_string); const char *itemStr2 = env-&gt;GetStringUTFChars(perStr, NULL); LOGD(\"Person: %s\", itemStr2); env-&gt;DeleteLocalRef(person_class); // 回收 env-&gt;DeleteLocalRef(person); // 回收 //13. 打印 Java 传递过来的 booleanArray jsize booArrayLength = env-&gt;GetArrayLength(bArray_); jboolean *bArray = env-&gt;GetBooleanArrayElements(bArray_, NULL); for (int i = 0; i &lt; booArrayLength; ++i) { bool b = bArray[i]; jboolean b2 = bArray[i]; LOGD(\"boolean:%d\",b) LOGD(\"jboolean:%d\",b2) } //回收 env-&gt;ReleaseBooleanArrayElements(bArray_, bArray, 0);} 输出: 1234567891011121314151617181920212223242526&gt; **输出:**&gt;&gt; native-lib: boolean-&gt; 1&gt; native-lib: jbyte-&gt; 1&gt; native-lib: char-&gt; 44&gt; native-lib: short-&gt; 3&gt; native-lib: long-&gt; 4&gt; native-lib: float-&gt; 3.300000&gt; native-lib: double-&gt; 2.200000&gt; native-lib: string-&gt; DevYK&gt; native-lib: int:28&gt; native-lib: intArray-&gt;1：&gt; native-lib: intArray-&gt;2：&gt; native-lib: intArray-&gt;3：&gt; native-lib: intArray-&gt;4：&gt; native-lib: intArray-&gt;5：&gt; native-lib: intArray-&gt;6：&gt; native-lib: intArray-&gt;7：&gt; native-lib: String[0]: 1&gt; native-lib: String[1]: 2&gt; native-lib: String[2]: 4&gt; native-lib: Person: 阳坤&gt; native-lib: boolean:0&gt; native-lib: jboolean:0&gt; native-lib: boolean:1&gt; native-lib: jboolean:1 ​ JNI 处理 Java 对象 定义一个 Java 对象 12345678910111213141516171819202122232425262728293031323334public class Person { private String name; private int age; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name){ this.name = name; } public String getName(){ return name; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 定义 native 接口 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity { private String TAG = this.getClass().getSimpleName(); /** * 1. 加载 native 库 */ static { System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView text = findViewById(R.id.sample_text); /**处理 Java 对象*/ String str = getPerson().toString(); text.setText(str); } public native Person getPerson();} 根据上面代码我们知道，如果获取成功，手机屏幕上肯定会打印会显示数据。 JNI 的处理 123456789101112131415161718192021222324252627282930313233343536373839extern \"C\"JNIEXPORT jobject JNICALLJava_com_devyk_ndk_1sample_MainActivity_getPerson(JNIEnv *env, jobject instance) { //1. 拿到 Java 类的全路径 const char *person_java = \"com.devyk.ndk_sample.Person\"; const char *method = \"&lt;init&gt;\"; // Java构造方法的标识 //2. 找到需要处理的 Java 对象 class jclass j_person_class = env-&gt;FindClass(person_java); //3. 拿到空参构造方法 jmethodID person_constructor = env-&gt;GetMethodID(j_person_class, method, \"()V\"); //4. 创建对象 jobject person_obj = env-&gt;NewObject(j_person_class, person_constructor); //5. 拿到 setName 方法的签名，并拿到对应的 setName 方法 const char *nameSig = \"(Ljava/lang/String;)V\"; jmethodID nameMethodId = env-&gt;GetMethodID(j_person_class, \"setName\", nameSig); //6. 拿到 setAge 方法的签名，并拿到 setAge 方法 const char *ageSig = \"(I)V\"; jmethodID ageMethodId = env-&gt;GetMethodID(j_person_class, \"setAge\", ageSig); //7. 正在调用 Java 对象函数 const char *name = \"DevYK\"; jstring newStringName = env-&gt;NewStringUTF(name); env-&gt;CallVoidMethod(person_obj, nameMethodId, newStringName); env-&gt;CallVoidMethod(person_obj, ageMethodId, 28); const char *sig = \"()Ljava/lang/String;\"; jmethodID jtoString = env-&gt;GetMethodID(j_person_class, \"toString\", sig); jobject obj_string = env-&gt;CallObjectMethod(person_obj, jtoString); jstring perStr = static_cast&lt;jstring &gt;(obj_string); const char *itemStr2 = env-&gt;GetStringUTFChars(perStr, NULL); LOGD(\"Person: %s\", itemStr2); return person_obj;} 输出: 可以看到 native 返回数据给 Java 了。 5. JNI 动态注册前面咱们学习的都是静态注册，静态注册虽然简单方便，但是也面临一个较大的问题，如果当前类定义的 native 方法名称改变或者包名改变，那么这一改也就面临在 cpp 中实现的也将改动，如果将要面临这种情况你可以试试 JNI 动态注册，如下代码所示: 1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity { private String TAG = this.getClass().getSimpleName(); /** * 1. 加载 native 库 */ static { System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView text = findViewById(R.id.sample_text); /**动态注册的 native */ dynamicRegister(\"我是动态注册的\"); } /** * 动态注册 */ public native void dynamicRegister(String name);} cpp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#include &lt;iostream&gt;#define TAG \"native-lib\"// __VA_ARGS__ 代表 ...的可变参数#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__);/** * TODO 动态注册*//** * 对应java类的全路径名，.用/代替 */const char *classPathName = \"com/devyk/ndk_sample/MainActivity\";extern \"C\" //支持 C 语言JNIEXPORT void JNICALL //告诉虚拟机，这是jni函数native_dynamicRegister(JNIEnv *env, jobject instance, jstring name) { const char *j_name = env-&gt;GetStringUTFChars(name, NULL); LOGD(\"动态注册: %s\", j_name) //释放 env-&gt;ReleaseStringUTFChars(name, j_name);}/* 源码结构体 * typedef struct { const char* name; const char* signature; void* fnPtr; } JNINativeMethod; */static const JNINativeMethod jniNativeMethod[] = { {\"dynamicRegister\", \"(Ljava/lang/String;)V\", (void *) (native_dynamicRegister)}};/** * 该函数定义在jni.h头文件中，System.loadLibrary()时会调用JNI_OnLoad()函数 */JNIEXPORT jint JNICALLJNI_OnLoad(JavaVM *javaVm, void *pVoid) { //通过虚拟机 创建爱你全新的 evn JNIEnv *jniEnv = nullptr; jint result = javaVm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;jniEnv), JNI_VERSION_1_6); if (result != JNI_OK) { return JNI_ERR; // 主动报错 } jclass mainActivityClass = jniEnv-&gt;FindClass(classPathName); jniEnv-&gt;RegisterNatives(mainActivityClass, jniNativeMethod, sizeof(jniNativeMethod) / sizeof(JNINativeMethod));//动态注册的数量 return JNI_VERSION_1_6;} 输出: 动态注册: 我是动态注册的 6. 异常处理异常处理是 Java 程序设计语言的重要功能， JNI 中的异常行为与 Java 中的有所不同，在 Java 中，当抛出一个异常时，虚拟机停止执行代码块并进入调用栈反向检查能处理特定类型异常的异常处理程序代码块，这也叫捕获异常。虚拟机清除异常并将控制权交给异常处理程序。相比之下， JNI 要求开发人员在异常发生后显式地实现异常处理流。 捕获异常: JNIEvn 接口提供了一组与异常相关的函数集，在运行过程中可以使用 Java 类查看这些函数，比如代码如下: 1234567891011public native void dynamicRegister2(String name);/** * 测试抛出异常 * * @throws NullPointerException */private void testException() throws NullPointerException { throw new NullPointerException(\"MainActivity testException NullPointerException\");} 当调用 testException 方法时，dynamicRegister2 该原生方法需要显式的处理异常信息，JNI 提供了 ExceptionOccurred 函数查询虚拟机中是否有挂起的异常。在使用完之后，异常处理程序需要用 ExceptionClear 函数显式的清除异常，如下代码: 12345jthrowable exc = env-&gt;ExceptionOccurred(); // 检测是否发生异常 if (exc) {//如果发生异常 env-&gt;ExceptionDescribe(); // 打印异常信息 env-&gt;ExceptionClear(); // 清除掉发生的异常 } 抛出异常: JNI 也允许原生代码抛出异常。因为异常是 Java 类，应该先用 FindClass 函数找到异常类，用 ThrowNew 函数可以使用化且抛出新的异常，如下代码所示: 12345jthrowable exc = env-&gt;ExceptionOccurred(); // 检测是否发生异常 if (exc) {//如果发生异常 jclass newExcCls = env-&gt;FindClass(\"java/lang/IllegalArgumentException\"); env-&gt;ThrowNew(newExcCls, \"JNI 中发生了一个异常信息\"); // 返回一个新的异常到 Java } 因为原生函数的代码执行不受虚拟机的控制，因此抛出异常并不会停止原生函数的执行并把控制权交给异常处理程序。到抛出异常时，原生函数应该释放所有已分配的原生资源，例如内存及合适的返回值等。通过 JNIEvn 接口获得的引用是局部引用且一旦返回原生函数，它们自动地被虚拟机释放。 示例代码: 123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity { private String TAG = this.getClass().getSimpleName(); /** * 1. 加载 native 库 */ static { System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dynamicRegister2(\"测试异常处理\"); } public native void dynamicRegister2(String name); /** * 测试抛出异常 * * @throws NullPointerException */ private void testException() throws NullPointerException { throw new NullPointerException(\"MainActivity testException NullPointerException\"); }} native-lib.cpp 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#include &lt;iostream&gt;#define TAG \"native-lib\"// __VA_ARGS__ 代表 ...的可变参数#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__);/** * TODO 动态注册*/.......extern \"C\" //支持 C 语言JNIEXPORT void JNICALL //告诉虚拟机，这是jni函数native_dynamicRegister2(JNIEnv *env, jobject instance, jstring name) { const char *j_name = env-&gt;GetStringUTFChars(name, NULL); LOGD(\"动态注册: %s\", j_name) jclass clazz = env-&gt;GetObjectClass(instance);//拿到当前类的class jmethodID mid =env-&gt;GetMethodID(clazz, \"testException\", \"()V\");//执行 Java 测试抛出异常的代码 env-&gt;CallVoidMethod(instance, mid); // 执行会抛出一个异常 jthrowable exc = env-&gt;ExceptionOccurred(); // 检测是否发生异常 if (exc) {//如果发生异常 env-&gt;ExceptionDescribe(); // 打印异常信息 env-&gt;ExceptionClear(); // 清除掉发生的异常 jclass newExcCls = env-&gt;FindClass(\"java/lang/IllegalArgumentException\"); env-&gt;ThrowNew(newExcCls, \"JNI 中发生了一个异常信息\"); // 返回一个新的异常到 Java } //释放 env-&gt;ReleaseStringUTFChars(name, j_name);}... 这里还是使用的动态注册。 最后效果如下: 可以看见这里即捕获到了 Java 抛出的异常，也抛出了一个 JNI 新的异常信息。 7. 局部与全局引用引用在 Java 程序设计中扮演非常重要的角色。虚拟机通过追踪类实例的引用并收回不在引用的垃圾来管理类实例的使用期限。因为原生代码不是一个管理环境，因此 JNI 提供了一组函数允许原生代码显式地管理对象引用及使用期间原生代码。 JNI 支持三种引用: 局部引用、全局引用和弱全局引用。下面将介绍这几类引用。 局部引用: 大多数 JNI 函数返回局部引用。局部应用不能在后续的调用中被缓存及重用，主要是因为它们的使用期限仅限于原生方法，一旦原生方法返回，局部引用即被释放。例如: FindClass 函数返回一个局部引用，当原生方法返回时，它被自动释放，也可以用 DeleteLocalRef 函数显式的释放原生代码。如下代码所示: 1234567891011121314151617jclass personClass;extern \"C\" //支持 C 语言JNIEXPORT void JNICALL //告诉虚拟机，这是jni函数native_test4(JNIEnv *env, jobject instance) { LOGD(\"测试局部引用\") if (personClass == NULL) { const char *person_class = \"com/devyk/ndk_sample/Person\"; personClass = env-&gt;FindClass(person_class); LOGD(\"personClass == null 执行了。\") } //Java Person 构造方法实例化 const char *sig = \"()V\"; const char *method = \"&lt;init&gt;\";//Java 构造方法标识 jmethodID init = env-&gt;GetMethodID(personClass, method, sig); //创建出来 env-&gt;NewObject(personClass, init);} 效果: 跟介绍的一样的吧。局部引用不能再后续的调用中重复使用，那么怎么解决这个问题勒，其实只要把局部引用提升为全局引用或者调用 DeleteLocalRef 显式释放就行了。这个我们在全局引用中演示。 全局引用: 全局引用在原生方法的后续调用过程中依然有效，除非它们被原生代码显式释放。 创建全局引用 可以使用 NewGlobalRef 函数将局部引用初始化为全局引用，如下代码所示: 1234567891011121314151617181920212223242526jclass personClass;extern \"C\" //支持 C 语言JNIEXPORT void JNICALL //告诉虚拟机，这是jni函数native_test4(JNIEnv *env, jobject instance) { LOGD(\"测试局部引用\") if (personClass == NULL) { //1. 提升全局解决不能重复使用问题 const char *person_class = \"com/devyk/ndk_sample/Person\"; jclass jclass1 = env-&gt;FindClass(person_class); personClass = static_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(jclass1)); LOGD(\"personClass == null 执行了。\") } //Java Person 构造方法实例化 const char *sig = \"()V\"; const char *method = \"&lt;init&gt;\";//Java 构造方法标识 jmethodID init = env-&gt;GetMethodID(personClass, method, sig); //创建出来 env-&gt;NewObject(personClass, init); //2. 显式释放主动删除全局引用 env-&gt;DeleteLocalRef(personClass); personClass = NULL;} 删除全局引用 当原生代码不再需要一个全局引用时，可以随时用 DeleteGlobalRef 函数释放它，如下代码所示: 12env-&gt;DeleteLocalRef(personClass);personClass = NULL; 弱全局引用 全局引用的另一种类型是弱全局引用。与全局引用一样，弱全局引用在原生方法的后续调用依然有效。与全局引用不同，弱全局引用并不阻止潜在的对象被垃圾收回。 创建弱全局引用 可以使用 NewWeakGlobalRef 函数对弱全局引用进行初始化，如下所示: 1234567891011121314151617181920212223242526272829jclass personClass;extern \"C\" //支持 C 语言JNIEXPORT void JNICALL //告诉虚拟机，这是jni函数native_test4(JNIEnv *env, jobject instance) { LOGD(\"测试局部引用\") if (personClass == NULL) { //1. 提升全局解决不能重复使用问题 const char *person_class = \"com/devyk/ndk_sample/Person\"; jclass jclass1 = env-&gt;FindClass(person_class);// personClass = static_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(jclass1)); personClass = static_cast&lt;jclass&gt;(env-&gt;NewWeakGlobalRef(jclass1)); LOGD(\"personClass == null 执行了。\") } //Java Person 构造方法实例化 const char *sig = \"()V\"; const char *method = \"&lt;init&gt;\";//Java 构造方法标识 jmethodID init = env-&gt;GetMethodID(personClass, method, sig); //创建出来 env-&gt;NewObject(personClass, init); //2. 显式释放主动删除局部引用// env-&gt;DeleteLocalRef(personClass); env-&gt;DeleteWeakGlobalRef(personClass); personClass = NULL;} 弱全局引用的有效性检验 可以用 IsSameObject 函数来检验一个弱全局引用是否仍然指向活动的类实例. 删除弱全局引用 1env-&gt;DeleteWeakGlobalRef(personClass); 全局引用显示释放前一直有效，它们可以被其它原生函数及原生线程使用。 8. JNI 线程操作作为多线程环境的一部分，虚拟机支持运行的原生代码。在开发构件时要记住 JNI 技术的一些约束: 只有再原生方法执行期间及正在执行原生方法的线程环境下局部引用是有效的，局部引用不能再多线程间共享，只有全局可以被多个线程共享。 被传递给每个原生方法的 JNIEvn 接口指针在与方法调用相关的线程中也是有效的，它不能被其它线程缓存或使用。 同步: 同步是多线程程序设计最终的特征。与 Java 同步类似， JNI 的监视器允许原生代码利用 Java 对象同步，虚拟机保证存取监视器的线程能够安全执行，而其他线程等待监视器对象变成可用状态。 1jint MonitorEnter(jobject obj) 对 MonitorEnter 函数的调用应该与对 MonitorExit 的调用相匹配，从而避免代码出现死锁。 例子: 1234567891011121314151617181920public void test4(View view) { for (int i = 0; i &lt; 10; i++) { new Thread(new Runnable() { @Override public void run() { count(); nativeCount(); } }).start(); }}private void count() { synchronized (this) { count++; Log.d(\"Java\", \"count=\" + count); }}public native void nativeCount(); native 代码: 1234567891011121314151617181920212223242526272829extern \"C\" //支持 C 语言JNIEXPORT void JNICALL //告诉虚拟机，这是jni函数native_count(JNIEnv *env, jobject instance) { jclass cls = env-&gt;GetObjectClass(instance); jfieldID fieldID = env-&gt;GetFieldID(cls, \"count\", \"I\"); /*if (env-&gt;MonitorEnter(instance) != JNI_OK) { LOGE(\"%s: MonitorEnter() failed\", __FUNCTION__); }*/ /* synchronized block */ int val = env-&gt;GetIntField(instance, fieldID); val++; LOGI(\"count=%d\", val); env-&gt;SetIntField(instance, fieldID, val); /*if (env-&gt;ExceptionOccurred()) { LOGE(\"ExceptionOccurred()...\"); if (env-&gt;MonitorExit(instance) != JNI_OK) { LOGE(\"%s: MonitorExit() failed\", __FUNCTION__); }; } if (env-&gt;MonitorExit(instance) != JNI_OK) { LOGE(\"%s: MonitorExit() failed\", __FUNCTION__); };*/} 在 native 中没有进行同步，打印如下: 输出: 2020-01-09 00:02:29.637 17573-17707/com.devyk.ndk_sample D/Java: count=12020-01-09 00:02:29.637 17573-17707/com.devyk.ndk_sample I/native-lib: count=22020-01-09 00:02:29.641 17573-17708/com.devyk.ndk_sample D/Java: count=32020-01-09 00:02:29.641 17573-17708/com.devyk.ndk_sample I/native-lib: count=42020-01-09 00:02:29.641 17573-17709/com.devyk.ndk_sample D/Java: count=52020-01-09 00:02:29.641 17573-17709/com.devyk.ndk_sample I/native-lib: count=62020-01-09 00:02:29.641 17573-17710/com.devyk.ndk_sample D/Java: count=72020-01-09 00:02:29.642 17573-17710/com.devyk.ndk_sample I/native-lib: count=82020-01-09 00:02:29.643 17573-17711/com.devyk.ndk_sample D/Java: count=92020-01-09 00:02:29.643 17573-17711/com.devyk.ndk_sample I/native-lib: count=102020-01-09 00:02:29.643 17573-17712/com.devyk.ndk_sample D/Java: count=112020-01-09 00:02:29.643 17573-17712/com.devyk.ndk_sample I/native-lib: count=122020-01-09 00:02:29.645 17573-17715/com.devyk.ndk_sample D/Java: count=132020-01-09 00:02:29.646 17573-17715/com.devyk.ndk_sample I/native-lib: count=152020-01-09 00:02:29.646 17573-17714/com.devyk.ndk_sample D/Java: count=152020-01-09 00:02:29.646 17573-17714/com.devyk.ndk_sample I/native-lib: count=162020-01-09 00:02:29.648 17573-17713/com.devyk.ndk_sample D/Java: count=172020-01-09 00:02:29.648 17573-17713/com.devyk.ndk_sample I/native-lib: count=182020-01-09 00:02:29.648 17573-17716/com.devyk.ndk_sample D/Java: count=192020-01-09 00:02:29.648 17573-17716/com.devyk.ndk_sample I/native-lib: count=20 通过多线程对 count 字段操作，可以看见已经无法保证 count 的可见性了。这就需要 JNI 本地实现也要同步。 我们把注释放开: 打印如下: 输出: 2020-01-09 00:07:10.579 18225-18385/com.devyk.ndk_sample D/Java: count=12020-01-09 00:07:10.579 18225-18385/com.devyk.ndk_sample I/native-lib: count=22020-01-09 00:07:10.581 18225-18386/com.devyk.ndk_sample D/Java: count=32020-01-09 00:07:10.581 18225-18386/com.devyk.ndk_sample I/native-lib: count=42020-01-09 00:07:10.582 18225-18387/com.devyk.ndk_sample D/Java: count=52020-01-09 00:07:10.582 18225-18387/com.devyk.ndk_sample I/native-lib: count=62020-01-09 00:07:10.584 18225-18388/com.devyk.ndk_sample D/Java: count=72020-01-09 00:07:10.584 18225-18388/com.devyk.ndk_sample I/native-lib: count=82020-01-09 00:07:10.586 18225-18390/com.devyk.ndk_sample D/Java: count=92020-01-09 00:07:10.586 18225-18390/com.devyk.ndk_sample I/native-lib: count=102020-01-09 00:07:10.586 18225-18391/com.devyk.ndk_sample D/Java: count=112020-01-09 00:07:10.586 18225-18391/com.devyk.ndk_sample I/native-lib: count=122020-01-09 00:07:10.586 18225-18393/com.devyk.ndk_sample D/Java: count=132020-01-09 00:07:10.587 18225-18389/com.devyk.ndk_sample D/Java: count=142020-01-09 00:07:10.587 18225-18389/com.devyk.ndk_sample I/native-lib: count=152020-01-09 00:07:10.587 18225-18393/com.devyk.ndk_sample I/native-lib: count=162020-01-09 00:07:10.587 18225-18394/com.devyk.ndk_sample D/Java: count=172020-01-09 00:07:10.588 18225-18394/com.devyk.ndk_sample I/native-lib: count=182020-01-09 00:07:10.588 18225-18392/com.devyk.ndk_sample D/Java: count=192020-01-09 00:07:10.588 18225-18392/com.devyk.ndk_sample I/native-lib: count=20 现在保证了count 的可见性了。 原生线程: 为了执行特定任务，这些原生构建可以并行使用原生线程。因为虚拟机不知道原生线程，因此它们不能与 Java 构建直接通信。为了与应用的依然活跃部分交互，原生线程应该先附着在虚拟机上。 JNI 通过 JavaVM 接口指针提供了 AttachCurrentThread 函数以便于让原生代码将原生线程附着到虚拟机上，如下代码所示, JavaVM 接口指针应该尽早被缓存，否则的话它不能被获取。 1234567JavaVM* jvm；...JNIEnv* env = NULL；...jvm-&gt;AttachCurrentThread(&amp;env,0);//把 native 线程附着到 JVM 上...jvm-&gt;DetachCurrentThread();//解除 附着 到 JVM 的 native 线程 对 AttachCurrentThread 函数的调用允许应用程序获得对当前线程有效的 JNIEnv 接口指针。将一个已经附着的原生线程再次附着不会有任何副作用。当原生线程完成时，可以用 DetachCurrentThread 函数将原生线程与虚拟机分离。 例子: MainActivity.java 123456789101112131415161718192021222324252627282930313233public void test5(View view) { testThread();}// AndroidUI操作，让C++线程里面来调用public void updateUI() { if (Looper.getMainLooper() == Looper.myLooper()) { new AlertDialog.Builder(MainActivity.this) .setTitle(\"UI\") .setMessage(\"native 运行在主线程，直接更新 UI ...\") .setPositiveButton(\"确认\", null) .show(); } else { runOnUiThread(new Runnable() { @Override public void run() { new AlertDialog.Builder(MainActivity.this) .setTitle(\"UI\") .setMessage(\"native运行在子线程切换为主线程更新 UI ...\") .setPositiveButton(\"确认\", null) .show(); } }); }}public native void testThread();public native void unThread();@Overrideprotected void onDestroy() { super.onDestroy(); unThread();} native-lib.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647JavaVM * jvm;jobject instance;void * customThread(void * pVoid) { // 调用的话，一定需要JNIEnv *env // JNIEnv *env 无法跨越线程，只有JavaVM才能跨越线程 JNIEnv * env = NULL; // 全新的env int result = jvm-&gt;AttachCurrentThread(&amp;env, 0); // 把native的线程，附加到JVM if (result != 0) { return 0; } jclass mainActivityClass = env-&gt;GetObjectClass(instance); // 拿到MainActivity的updateUI const char * sig = \"()V\"; jmethodID updateUI = env-&gt;GetMethodID(mainActivityClass, \"updateUI\", sig); env-&gt;CallVoidMethod(instance, updateUI); // 解除 附加 到 JVM 的native线程 jvm-&gt;DetachCurrentThread(); return 0;}extern \"C\" //支持 C 语言JNIEXPORT void JNICALL //告诉虚拟机，这是jni函数native_testThread(JNIEnv *env, jobject thiz) { instance = env-&gt;NewGlobalRef(thiz); // 全局的，就不会被释放，所以可以在线程里面用 // 如果是非全局的，函数一结束，就被释放了 pthread_t pthreadID; pthread_create(&amp;pthreadID, 0, customThread, instance); pthread_join(pthreadID, 0);}extern \"C\" //支持 C 语言JNIEXPORT void JNICALL //告诉虚拟机，这是jni函数native_unThread(JNIEnv *env, jobject thiz) { if (NULL != instance) { env-&gt;DeleteGlobalRef(instance); instance = NULL; }} 效果: 总结该篇文件全面介绍了 JNI 技术实现 Java 应用程序与原生代码之间通信的方式，关于更多 JNI 技术可以下载 JNI 使用手册 。","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%B8%89-JNI-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%8E%8C%E6%8F%A1/"},{"title":"音视频学习 (五) shell 脚本入门","text":"前言学习 Shell 脚本也是为了后面编译第三方库打下一个基础，编译第三方库几乎都需要用到 shell 语法，如果你不懂那么就不会编译出自己想要的版本，只会 copy 网络上别人写好的这其实是没有任何学习的意义。 介绍Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。 Shell 入门学习打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好。 第一个 shell 脚本我们还是以输出一个 “Hello Word !” 为例子正式进行学习，脚本代码如下: 12#!/bin/bashecho \"Hello World !\" 输出: #! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 echo 命令用于向窗口输出文本。 注意: 如果执行提示没有权限还需要命令输入 chmod +x test.sh 开放可执行权限。 变量定义变量时，变量名不加美元符号 ($) ,如下: 1my_name=\"DevYK\" 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 除了显式地直接赋值，还可以用语句给变量赋值，如： 12345#一定要切记for file in $后边的那个引号不是单引号，而是tab键上边的那个键，或者说是1左边的那个键。否则的话不起作用。for file in $`ls /root/android`doecho $filedone 输出效果: 使用变量: 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 1234my_name=\"DevYK\"echo $my_name#变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界echo ${my_name} 输出: 12DevYKDevYK 只读变量: 1234#4. 只读变量my_blog_url=\"https://www.devyk.top/\"readonly my_blog_urlmy_blog_url=\"www.baidu.com\" 输出: 删除变量: 1234#变量被删除后不能再次使用。unset 命令不能删除只读变量。your_name=\"小明\"unset your_nameecho $your_name 输出: 可以看到定义了删除变量之后，后面是没有任何输出 变量类型: 运行shell时，会同时存在三种变量： 1) 局部变量 局部变量在脚本或命令中定义，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量。 2) 环境变量 所有的程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候 shell 脚本也可以定义环境变量。 3) shell变量 shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 字符串字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。 12#单引号str='this is a book' 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 1234#双引号your_title=“玄幻小说”str=\"嗨, 请问这是一本什么类型的小说？ \\\"$your_title\\\" \\n\"echo -e $str 输出: 1嗨, 请问这是一本什么类型的小说？ \"“玄幻小说”\" 双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串: 123456789your_name=\"DevYK_1\"#使用双引号拼接str1=\"2 我是 “$your_name” !\"str2=\"2 我是 ${your_name} !\"echo $str1 $str2#使用单引号拼接str3='1 我是 “$your_name” !'str4='1 我是 ${your_name} !'echo $str3 $str4 输出: 122 我是 “DevYK_1” ! 2 我是 DevYK_1 !1 我是 DevYK_1 ! 1 我是 ${your_name} ! 获取字符串长度: 12str_length='123456'echo ${#str_length} 输出: 6 提取字符串: 以下实例从字符串第 2 个字符开始截取 4 个字符： 1echo ${str_length:1:4} 输出: 2345 查找字符串: 1echo `expr index \"$str_length\" 3` //是反斜杠 tab 上 1 键左 输出：3 传递参数我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 例子: 以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名： 12345echo \"Shell 传递参数实例！\";echo \"执行的文件名：$0\";echo \"第一个参数为：$1\";echo \"第二个参数为：$2\";echo \"第三个参数为：$3\"; 输出: 数组数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小。 与大部分编程语言类似，数组元素的下标由 0 开始。 Shell 数组用括号来表示，元素用 “空格” 符号分割开，语法格式如下： 1array_name=(value1 ... valuen) 例子: 1234567891011121314my_array=(A B \"C\" D)echo \"第一个元素为: ${my_array[0]}\"echo \"第二个元素为: ${my_array[1]}\"echo \"第三个元素为: ${my_array[2]}\"echo \"第四个元素为: ${my_array[3]}\"#使用@ 或 * 可以获取数组中的所有元素，例如：echo \"数组的元素为: ${my_array[*]}\"echo \"数组的元素为: ${my_array[@]}\"#获取数组长度的方法与获取字符串长度的方法相同echo \"数组元素个数为: ${#my_array[*]}\"echo \"数组元素个数为: ${#my_array[@]}\" 输出: 12345678第一个元素为: A第二个元素为: B第三个元素为: C第四个元素为: D数组的元素为: A B C D数组的元素为: A B C D数组元素个数为: 4数组元素个数为: 4 运算符Shell 和其他编程语言一样，支持多种运算符，包括： 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 注意: 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算符运算符: 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 1234567891011121314151617181920212223242526a=10b=20val=`expr $a + $b`echo \"a + b : $val\"val=`expr $a - $b`echo \"a - b : $val\"val=`expr $a \\* $b`echo \"a * b : $val\"val=`expr $b / $a`echo \"b / a : $val\"val=`expr $b % $a`echo \"b % a : $val\"if [ $a == $b ]then echo \"a 等于 b\"fiif [ $a != $b ]then echo \"a 不等于 b\"fi 输出: 123456a + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a 不等于 b 注意: 乘号(*)前边必须加反斜杠()才能实现乘法运算； if…then…fi 是条件语句，后续将会讲解。 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “&quot; 。 关系运算符: 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 例子: 1234567891011121314151617181920212223242526272829303132333435363738a=10b=20if [ $a -eq $b ]then echo \"$a -eq $b : a 等于 b\"else echo \"$a -eq $b: a 不等于 b\"fiif [ $a -ne $b ]then echo \"$a -ne $b: a 不等于 b\"else echo \"$a -ne $b : a 等于 b\"fiif [ $a -gt $b ]then echo \"$a -gt $b: a 大于 b\"else echo \"$a -gt $b: a 不大于 b\"fiif [ $a -lt $b ]then echo \"$a -lt $b: a 小于 b\"else echo \"$a -lt $b: a 不小于 b\"fiif [ $a -ge $b ]then echo \"$a -ge $b: a 大于或等于 b\"else echo \"$a -ge $b: a 小于 b\"fiif [ $a -le $b ]then echo \"$a -le $b: a 小于或等于 b\"else echo \"$a -le $b: a 大于 b\"fi 输出: 12345610 -eq 20: a 不等于 b10 -ne 20: a 不等于 b10 -gt 20: a 不大于 b10 -lt 20: a 小于 b10 -ge 20: a 小于 b10 -le 20: a 小于或等于 b 布尔运算符: 下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 123456789101112131415161718192021222324252627a=10b=20if [ $a != $b ]then echo \"$a != $b : a 不等于 b\"else echo \"$a == $b: a 等于 b\"fiif [ $a -lt 100 -a $b -gt 15 ]then echo \"$a 小于 100 且 $b 大于 15 : 返回 true\"else echo \"$a 小于 100 且 $b 大于 15 : 返回 false\"fiif [ $a -lt 100 -o $b -gt 100 ]then echo \"$a 小于 100 或 $b 大于 100 : 返回 true\"else echo \"$a 小于 100 或 $b 大于 100 : 返回 false\"fiif [ $a -lt 5 -o $b -gt 100 ]then echo \"$a 小于 5 或 $b 大于 100 : 返回 true\"else echo \"$a 小于 5 或 $b 大于 100 : 返回 false\"fi 输出: 123410 != 20 : a 不等于 b10 小于 100 且 20 大于 15 : 返回 true10 小于 100 或 20 大于 100 : 返回 true10 小于 5 或 20 大于 100 : 返回 false 逻辑运算符: 以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ $Misplaced &amp;a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false || 逻辑的 OR [[ $a -lt 100 例子: 123456789101112131415a=10b=20if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]then echo \"返回 true\"else echo \"返回 false\"fiif [[ $a -lt 100 || $b -gt 100 ]]then echo \"返回 true\"else echo \"返回 false\"fi 输出: 12返回 false返回 true 字符串运算符 下表列出了常用的字符串运算符，假定变量 a 为 “123”，变量 b 为 “456”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 例子: 123456789101112131415161718192021222324252627282930313233str1=\"123\"str2=\"456\"if [ $str1 = $str2 ]then echo \"$str1 = $str2 : str1 等于 str2\"else echo \"$str1 = $str2: str1 不等于 str2\"fiif [ $str1 != $str2 ]then echo \"$str1 != $str2 : str1 不等于 str2\"else echo \"$str1 != $str2: str1 等于 str2\"fiif [ -z $str1 ]then echo \"-z $str1 : 字符串长度为 0\"else echo \"-z $str1 : 字符串长度不为 0\"fiif [ -n \"$str1\" ]then echo \"-n $str1 : 字符串长度不为 0\"else echo \"-n $str1 : 字符串长度为 0\"fiif [ $str1 ]then echo \"$str1 : 字符串不为空\"else echo \"$str1 : 字符串为空\"fi 输出: 12345123 = 456: str1 不等于 str2123 != 456 : str1 不等于 str2-z 123 : 字符串长度不为 0-n 123 : 字符串长度不为 0123 : 字符串不为空 文件测试运算符: 文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 其他检查符： -S: 判断某文件是否 socket。 -L: 检测文件是否存在并且是一个符号链接。 变量 file 表示文件 /root/android/shell/test.sh，它具有 rwx 权限。下面的代码，将检测该文件的各种属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243file=\"/root/android/shell/test.sh\"if [ -r $file ]then echo \"文件可读\"else echo \"文件不可读\"fiif [ -w $file ]then echo \"文件可写\"else echo \"文件不可写\"fiif [ -x $file ]then echo \"文件可执行\"else echo \"文件不可执行\"fiif [ -f $file ]then echo \"文件为普通文件\"else echo \"文件为特殊文件\"fiif [ -d $file ]then echo \"文件是个目录\"else echo \"文件不是个目录\"fiif [ -s $file ]then echo \"文件不为空\"else echo \"文件为空\"fiif [ -e $file ]then echo \"文件存在\"else echo \"文件不存在\"fi 输出: 1234567文件可读文件可写文件可执行文件为普通文件文件不是个目录文件不为空文件存在 echo 命令Shell 的 echo 指令用于字符串的输出。命令格式： 1echo string 例子 1234567891011121314151617#显示普通字符串echo \"This is a book\"#也可以省略双引号echo This is a book#显示转义字符echo\"\\\"This is a book\"\\\"#显示变量your_name_2=\"DevYK_2\"echo \"变量的名称是:$your_name_2\"#显示换行 -e 开始转义echo -e \"换行 \\n\"echo \"是否换行了\"#显示不换行echo -e \"不换行 \\c\"echo \"是否换行了\"#显示命令执行结果echo `date` 输出: 123456789This is a bookThis is a book\"This is a book\"变量的名称是:DevYK_2换行 是否换行了不换行 是否换行了Mon Jan 13 12:12:32 CST 2020 printf 命令上一章节我们学习了 Shell 的 echo 命令，本章节我们来学习 Shell 的另一个输出命令 printf。 printf 命令模仿 C 程序库（library）里的 printf() 程序。 printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。 printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \\n。 printf 命令的语法： 1printf format-string [arguments...] 参数说明： format-string: 为格式控制字符串 arguments: 为参数列表。 例子: 1234printf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg printf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 printf \"%-10s %-8s %-4.2f\\n\" 杨过 男 48.6543 printf \"%-10s %-8s %-4.2f\\n\" 郭芙 女 47.9876 输出: 1234姓名 性别 体重kg郭靖 男 66.12杨过 男 48.65郭芙 女 47.99 %s %c %d %f都是格式替代符 %-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。 %-4.2f 指格式化为小数，其中.2指保留2位小数。 test 命令Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 数值测试: 参数 说明 -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 例子: 12345678num1=100num2=100if test $[num1] -eq $[num2]then echo '两个数相等！'else echo '两个数不相等！'fi 输出: 1两个数相等！ 字符串测试: 参数 说明 = 等于则为真 != 不相等则为真 -z 字符串 字符串的长度为零则为真 -n 字符串 字符串的长度不为零则为真 例子: 12345678name_=\"DEVYK\"name2_=\"DevYK\"if test $name_ = $name2_then echo '两个字符串相等!'else echo '两个字符串不相等!'fi 输出: 1两个字符串不相等! 文件测试: 参数 说明 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 例子: 123456if test -e ./test.shthen echo '文件已存在!'else echo '文件不存在!'fi 输出: 1文件已存在! 流程控制和 Java 语言不一样，sh 的流程控制不可为空，如(以下为Java流程控制写法)： 12345if(1 == 2){ add(1,2)}else{ //不做任何处理} 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。 if 语句语法格式: 1234567if conditionthen command1 command2 ... commandN fi 写成一行（适用于终端命令提示符）： 1if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; then echo \"true\"; fi for 循环: 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 例子: 1234for loop in 1 2 3do echo \"the value is $loop\"done 输出: 123the value is 1the value is 2the value is 3 while 语句 while 循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为： 1234while conditiondo commanddone 以下是一个基本的 while 循环，测试条件是：如果 int 小于等于 5，那么条件返回真。int 从 0 开始，每次循环处理时，int 加 1 。运行上述脚本，返回数字 1 到 5 ，然后终止。 123456int=1while(( $int&lt;=5 ))do echo $int let \"int++\"done 输出: 1234512345 无限循环 无限循环语法格式： 1234while :do commanddone 或者: 1234while truedo commanddone 或者: 1for (( ; ; )) 函数linux shell 可以用户定义函数，然后在 shell 脚本中可以随便调用。 shell 中函数的定义格式如下： 123456789[ function ] funname [()]{ action; [return int;]} 说明： 1、可以带 function fun() 定义，也可以直接 fun() 定义,不带任何参数。 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return 后跟数值 n(0-255) 例子: 1234567891011funWithReturn(){ echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum))}funWithReturnecho \"输入的两个数字之和为 $? !\" 输出: 1234567这个函数会对输入的两个数字进行相加运算...输入第一个数字: 12输入第二个数字: 22两个数字分别为 12 和 22 !输入的两个数字之和为 34 ! 函数返回值在调用该函数后通过 $? 来获得。 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 函数参数: 在 Shell 中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… 例子: 12345678910funWithParam(){ echo \"第一个参数为 $1 !\" echo \"第二个参数为 $2 !\" echo \"第十个参数为 $10 !\" echo \"第十个参数为 ${10} !\" echo \"第十一个参数为 ${11} !\" echo \"参数总数有 $# 个!\" echo \"作为一个字符串输出所有参数 $* !\"}funWithParam 1 2 3 4 5 6 7 8 9 22 11 输出: 1234567第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 22 !第十一个参数为 11 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 22 11 ! 注意，$10 不能获取第十个参数，获取第十个参数需要​${10}。当n&gt;=10时，需要使用${n}来获取参数。 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本或函数的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 总结Shell 入门知识就介绍这么多，后续编译第三方库编写 Shell 脚本有陌生的在进行介绍。 参考 Shell 教程 Linux 命令","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%BA%94-shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"},{"title":"音视频学习 (六) FFmpeg 交叉编译","text":"前言​ 该篇文章起就正式进入音视频学习了，在进入音视频学习之前我们必须要先学习 FFmpeg 这个库，这个库非常强大，强大到什么地步呢 ？可以说只要做音视频的没有人不了解它，包括国内外一些比较出名的播放器也用到了 FFmpeg 这个库。 FFmpeg 定义​ FFmpeg 既是一款音视频编解码工具，同时也是一组音视频编解码开发套件，作为编解码开发套件，他为开发者提供了丰富的音视频处理的调用接口。 ​ FFmpeg 提供了多种媒体格式的封装和解封装，包括多种音视频编码、多种协议的流媒体、多种色彩格式转换、多种采样率转换、多种码率转换等; FFmpeg 框架提供了多种丰富的插件模块，包含封装与解封转的插件、编码与解码的插件等。 FFmpeg 历史​ FFmpeg 由法国天才程序员 Fabrice Bellard 在 2000 年的时开发出初版；后来发展到 2004 年， Fabrice Bellard 找到了接手人，这个人至今还在维护 FFmpeg 的 Michael Niedermayer 。Michael Niedermayer 对 FFmpeg 的贡献非常大，其将滤镜子系统 libavfilter 加入 FFmpeg 项目中，使得 FFmpeg 的多媒体处理更加多样、更加方便。在 FFmpeg 发布了 0.5 版本之后，很长一段时间没有进行新版本的发布，直到后来 FFmpeg 采用了 Git 作为版本控制服务器以后才开始继续进行代码更新、版本发布，当然也是时隔多年之后了；2011 年 3 月，在 FFmpeg 项目中有一些提交者对 FFmpeg的项目管理方式并不满意，因而重新创建了一个新的项目，命名为 Libav, 该项目尽管至今并没有 FFmpeg 发展这么迅速，但是提交权限相对 FFmpeg 更加开放；2015 年 8 月，Michael Niedermayer 主动辞去 FFmpeg 项目负责人的职务。Michael Niedermayter 从 Libav 中移植了大量的代码和功能到 FFmpeg 中，Michael Niedermayter 辞职的主要目的是希望两个项目最终能够一起发展，若能够合并则更好。时至今日，在大多数的 Linux 发行版本系统中已经使用 FFmpeg 来进行多媒体处理。 FFmpeg 可以通过以下方式自由获取源代码，具体方式如下: 官方网站 http://git.videolan.org/?p=ffmpeg.git GitHub FFmpeg 模块介绍 ​ FFmpeg 框架的基本组成包含 libavcodec 、libavformat、libavfilter、libavdevice 、libavutil 等模块。 下面针对这些模块做一个大概的介绍。 libavcodec: 编解码库，封装了 Codec 层，但是有一些 codec 是具备自己的 License 的，FFmpeg 不会默认添加像 libx264、FDK-AAC、Lame 等库，但是 FFmpeg 像一个平台，可以将其他的第三方codec以插件的方式添加进来，为开发者提供统一接口 libavformat: 文件格式和协议库，封装了 Protocol 层和 Demuxer、Muxer 层，使得协议和格式对于开发者来说是透明的 libavfilter: 音视频滤镜库，该模块包含了音频特效和视频特效的处理，在使用 FFmpeg 的 API 进行编解码的过程中，可以使用该模块高效的为音视频数据做特效处理 libavdevice: 输入输出设备库，比如需要编译出播放声音或者视频的工具 ffplay，就需要确保该模块是打开的，同事也需要 libsdl 的预先编译，该设备模块播放声音和视频都又是使用libsdl 库 libavutil: 核心工具库，最基础模块之一，其他模块都会依赖该库做一些基本的音视频处理操作 libswresample: 用于音频重采样，可以对数字音频进行声道数、数据格式、采样率等多种基本信息的转换 libswscale 该模块用于图像格式转换，可以将 YUV 的数据转换为 RGB 的数据 libpostproc 该模块用于进行后期处理，当我们使用filter的时候，需要打开这个模块，filter会用到这个模块的一些基础函数 比较老的 ffmpeg 还会编译出 avresamle 模块，也是用于对音频原始出具进行重采样的，但是已经被废弃，推荐使用 libswresample 替代 另外，库里还可以包含对 H.264/MPEG-4 AVC 视频编码的 X264 库，是最常用的有损视频编码器，支持 CBR、VBR 模式，可以在编码的过程中直接改变码率的设置，在直播的场景中非常适用！可以做码率自适应的功能。 下载 FFmpegFFmpeg 官网 直接下载源码方式 在 linux 环境中，命令下载: 123456//1. 命令下载wget https://ffmpeg.org/releases/ffmpeg-4.2.2.tar.bz2//2. 安装解压缩工具yum -y install bzip2//3. 解压 FFmpeg tar -jxvf ffmpeg-4.2.2.tar.bz2 编译 FFmpeg编译环境 ffmpeg-4.2.2 Centos 7 android-ndk-r17c-linux-x86_64.zip configure 脚本介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#!/bin/sh...#帮组选项Help options: --help print this message --quiet Suppress showing informative output --list-decoders show all available decoders --list-encoders show all available encoders --list-hwaccels show all available hardware accelerators --list-demuxers show all available demuxers --list-muxers show all available muxers --list-parsers show all available parsers --list-protocols show all available protocols --list-bsfs show all available bitstream filters --list-indevs show all available input devices --list-outdevs show all available output devices --list-filters show all available filters#标准选项#--disable 代表关闭状态 ；--enable 代表开启状态Standard options: --logfile=FILE log tests and output to FILE [ffbuild/config.log] --disable-logging do not log configure debug information --fatal-warnings fail if any configure warning is generated #我们最终编译好的动态静态库位置，必须设置 --prefix=PREFIX install in PREFIX [$prefix_default] --bindir=DIR install binaries in DIR [PREFIX/bin] --datadir=DIR install data files in DIR [PREFIX/share/ffmpeg] --docdir=DIR install documentation in DIR [PREFIX/share/doc/ffmpeg] --libdir=DIR install libs in DIR [PREFIX/lib] --shlibdir=DIR install shared libs in DIR [LIBDIR] --incdir=DIR install includes in DIR [PREFIX/include] --mandir=DIR install man page in DIR [PREFIX/share/man] --pkgconfigdir=DIR install pkg-config files in DIR [LIBDIR/pkgconfig] --enable-rpath use rpath to allow installing libraries in paths not part of the dynamic linker search path use rpath when linking programs (USE WITH CARE) --install-name-dir=DIR Darwin directory name for installed targetsLicensing options: --enable-gpl allow use of GPL code, the resulting libs and binaries will be under GPL [no] --enable-version3 upgrade (L)GPL to version 3 [no] --enable-nonfree allow use of nonfree code, the resulting libs and binaries will be unredistributable [no]Configuration options:#开启静态库 --disable-static do not build static libraries [no]#关闭动态库 --enable-shared build shared libraries [no#可以优化库的大小 --enable-small optimize for size instead of speed --disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary) --enable-gray enable full grayscale support (slower color) --disable-swscale-alpha disable alpha channel support in swscale --disable-all disable building components, libraries and programs --disable-autodetect disable automatically detected external libraries [no]Program options:#我们不需要使用程序，不需要在Windows中执行，某.exe程序，我们只需要在代码中使用 [此命令操作的是下面三项] --disable-programs do not build command line programs #使用FFmpeg命令 --disable-ffmpeg disable ffmpeg build #播放器 --disable-ffplay disable ffplay build --disable-ffprobe disable ffprobe buildDocumentation options: --disable-doc do not build documentation --disable-htmlpages do not build HTML documentation pages --disable-manpages do not build man documentation pages --disable-podpages do not build POD documentation pages --disable-txtpages do not build text documentation pages#模块选项Component options:#可以操控我们的摄像头-（Android中是不支持）） --disable-avdevice disable libavdevice build#audio video codec(编码 和 解码) --disable-avcodec disable libavcodec build#音视频格式生成和解析相关 --disable-avformat disable libavformat build#音频重采样（如果想把单声道，变成双声道） --disable-swresample disable libswresample build#对视频显示相关（对视频的缩放，放大 缩小） --disable-swscale disable libswscale build#后期处理，很少用，可以关闭掉 --disable-postproc disable libpostproc build#给视频加水印，加字幕，特殊效果 --disable-avfilter disable libavfilter build --enable-avresample enable libavresample build (deprecated) [no] --disable-pthreads disable pthreads [autodetect] --disable-w32threads disable Win32 threads [autodetect] --disable-os2threads disable OS/2 threads [autodetect] --disable-network disable network support [no] --disable-dct disable DCT code --disable-dwt disable DWT code --disable-error-resilience disable error resilience code --disable-lsp disable LSP code --disable-lzo disable LZO decoder code --disable-mdct disable MDCT code --disable-rdft disable RDFT code --disable-fft disable FFT code --disable-faan disable floating point AAN (I)DCT code --disable-pixelutils disable pixel utils in libavutilIndividual component options: --disable-everything disable all components listed below --disable-encoder=NAME disable encoder NAME --enable-encoder=NAME enable encoder NAME#编码可以去关闭掉 --disable-encoders disable all encoders --disable-decoder=NAME disable decoder NAME --enable-decoder=NAME enable decoder NAME --disable-decoders disable all decoders --disable-hwaccel=NAME disable hwaccel NAME --enable-hwaccel=NAME enable hwaccel NAME --disable-hwaccels disable all hwaccels --disable-muxer=NAME disable muxer NAME --enable-muxer=NAME enable muxer NAME #混合封装（音视频等于 一段音频 一段视频 合并在一起 就是.mp4，不想这样就可以关闭） --disable-muxers disable all muxers --disable-demuxer=NAME disable demuxer NAME --enable-demuxer=NAME enable demuxer NAME --disable-demuxers disable all demuxers --enable-parser=NAME enable parser NAME --disable-parser=NAME disable parser NAME --disable-parsers disable all parsers --enable-bsf=NAME enable bitstream filter NAME --disable-bsf=NAME disable bitstream filter NAME --disable-bsfs disable all bitstream filters --enable-protocol=NAME enable protocol NAME --disable-protocol=NAME disable protocol NAME --disable-protocols disable all protocols --enable-indev=NAME enable input device NAME --disable-indev=NAME disable input device NAME --disable-indevs disable input devices --enable-outdev=NAME enable output device NAME --disable-outdev=NAME disable output device NAME --disable-outdevs disable output devices --disable-devices disable all devices --enable-filter=NAME enable filter NAME --disable-filter=NAME disable filter NAME --disable-filters disable all filters... 编写 32/64 位 FFmpeg4.2.2 shell 脚本ndk20b+ffmpeg4.2.2 clang 编译脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/bin/bashecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译硬件解码版本 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"echo \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 注意：该编译环境目前只在 NDK20b + ffmpeg4.2.2 测试过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"echo \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 注意：该编译环境目前只在 NDK20b + ffmpeg4.2.2 测试过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"#你自己的NDK路径.export NDK=/root/android/ndk/android-ndk-r20bTOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64function build_android{echo \"开始编译 $CPU\"./configure \\--prefix=$PREFIX \\--enable-neon \\--enable-hwaccels \\--enable-gpl \\--enable-postproc \\--enable-shared \\--disable-debug \\--enable-small \\--enable-jni \\--enable-mediacodec \\--enable-decoder=h264_mediacodec \\--disable-static \\--disable-doc \\--enable-ffmpeg \\--disable-ffplay \\--disable-ffprobe \\--disable-avdevice \\--disable-doc \\--disable-symver \\--cross-prefix=$CROSS_PREFIX \\--target-os=android \\--arch=$ARCH \\--cpu=$CPU \\--cc=$CC \\--cxx=$CXX \\--enable-cross-compile \\--sysroot=$SYSROOT \\--extra-cflags=\"-Os -fpic $OPTIMIZE_CFLAGS\" \\--extra-ldflags=\"$ADDI_LDFLAGS\"make cleanmakemake installecho \"编译成功 $CPU\"}#armv8-aARCH=arm64CPU=armv8-aAPI=21CC=$TOOLCHAIN/bin/aarch64-linux-android$API-clangCXX=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysrootCROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-PREFIX=$(pwd)/android/$CPUOPTIMIZE_CFLAGS=\"-march=$CPU\"build_android#armv7-aARCH=armCPU=armv7-aAPI=16CC=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clangCXX=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang++SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysrootCROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-androideabi-PREFIX=$(pwd)/android/$CPUOPTIMIZE_CFLAGS=\"-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU \"build_android ndk17c + ffmpeg4.2.2 gcc编译脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/bin/bashecho \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译软件解码版本 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"echo \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 注意：该编译环境目前只在 NDK17c + ffmpeg4.2.2 测试过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"echo \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 注意：该编译环境目前只在 NDK17c + ffmpeg4.2.2 测试过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"#NDK_ROOT 变量指向 ndk 目录NDK_ROOT=$NDK_HOME#指定android api版本ANDROID_API=21#开始编译 在下面调用传入参数即可function build_ffmpeg{echo \"开始编译 $PREFIX_CPU\"echo \"开始编译 $PREFIX\"echo \"开始编译 $TOOLCHAIN\"./configure \\--prefix=$PREFIX \\--disable-doc \\--disable-yasm \\--disable-asm \\--disable-symver \\--enable-gpl \\--disable-ffplay \\--disable-ffmpeg \\--disable-ffprobe \\--enable-small \\--disable-programs \\--disable-avdevice \\--disable-encoders \\--disable-muxers \\--disable-filters \\--enable-cross-compile \\--cross-prefix=$CROSS_PREFIX \\--disable-shared \\--enable-static \\--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-$ARCH \\--extra-cflags=\"$CFLAGES\" \\--arch=$ARCH \\--target-os=android#上面运行脚本生成makefile之后，使用make执行脚本make cleanmakemake installecho \"$PREFIX_CPU 编译完成\"echo \"$PREFIX_CPU 编译完成\"echo \"$PREFIX_CPU 编译完成\"}#armeabi-v7aPREFIX=./result/armeabi-v7aTOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64ARCH=armCROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-androideabi-CFLAGES=\"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC\"build_ffmpeg#arm64-v8aPREFIX=./result/arm64-v8aTOOLCHAIN=$NDK_ROOT/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64ARCH=arm64CROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-CFLAGES=\"-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC\"build_ffmpeg#直接跳转到编译完成的路径cd /result 编译遇见的坑: arm-linux-androideabi-gcc is unable to create an executable file 原因 1：FFmpeg 4.2.2 版本默认使用了 clang 进行编译 解决： 1234567//1. 修改 configure 文件vim configure//2. 把 默认的 clang 修改为 gccif test \"$target_os\" = android; then # cc_default=\"clang\" cc_default=\"gcc\"fi 原因 2： 检查路径是否正确 nasm/yasm not found or too old. Use –disable-x86asm for a crippled build. 分析：yasm 是汇编编译器，ffmpeg 为了提高效率使用了汇编指令，如 MMX 和 SSE等。 所以系统中未安装yasm时，就会报上面错误。 12345678910111213141516171819解决错误：安装yasm编译器。安装方法如下：1）下载：[yasm的下载链接]wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz2）解压：把下载下来的压缩包进行解压tar -zxvf yasm-1.3.0.tar.gz3）切换路径： cd yasm-1.3.04）执行配置： ./configure5）编译：make6）安装：make install 解决 “ lib64 libc so 6 version `GLIBC_2 18’ not found (required by lib… 12345678910111213141516171819202122curl -O http://ftp.gnu.org/gnu/glibc/glibc-2.18.tar.gztar zxf glibc-2.18.tar.gz cd glibc-2.18/mkdir buildcd build/../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/binmake make install安装完成后，查看是否成功ll /lib64/libc*然后可以继续查看 glibc 支持的版本strings /lib64/libc.so.6 | grep GLIBC//------------------------------------------------------------//下面可以不用参考，这个是我在升级 glibc 的时候把 libc-2.17.so 给误删除了，导致基本上瘫痪了，可以使用以下命令恢复//ll cp 等命令失效请用以下进行软连接 LD_PRELOAD=/lib64/libc-2.17.so ln -s /lib64/libc-2.17.so /lib64/libc.so.6//如果不小心定义了错误环境变量可以通过以下命令删除unset LD_LIBRARY_PATH config.mak 文件没有生成 解决：执行./configure --disable-x86asm 生成 config.mak 文件 更多坑错误请点击此处查看 错误解决完之后，按下回车键，如果出现如下输出，就开始在编译了: 大概等 10 分钟左右就会编译完成，如下所示就代表编译静态库成功了: 如果想编译动态库，仅仅修改下参数就行了，如下所示: 1234#开启动态库--enable-shared \\#关闭静态库--disable-static \\ 压缩: 1tar -zcvf ffmpeg_android.tar.gz android 利用 FileZill 工具 从服务器端把编译好的静态文件导出到电脑本地，导出完之后我们就在 AS 中测试编译的 .a 文件是否有误。 Android 集成交叉编译之后的 FFmpeg 静态库 创建一个 C/C++ 项目的 Android 工程，并把编译好的静态库导入项目中，如下结构: 编写 JNI 代码 1234567891011121314151617181920212223#include &lt;jni.h&gt;// 有坑，会报错，必须混合编译//#include &lt;libavutil/avutil.h&gt;extern \"C\" {#include &lt;libavutil/avutil.h&gt;}/** * 拿到 ffmpeg 当前版本 * @return */const char *getFFmpegVer() { return av_version_info();}extern \"C\"JNIEXPORT jstring JNICALLJava_com_devyk_ffmpeg_MainActivity_getFFmpegVersion(JNIEnv *env, jclass type) { return env-&gt;NewStringUTF(getFFmpegVer());} 编写 CMakeLists.txt 脚本 1234567891011121314151617181920212223242526272829303132333435363738#指定 Cmake 最低版本cmake_minimum_required(VERSION 3.4.1)#找到包含所有的cpp文件file(GLOB allCpp *.cpp)#打印当前 cmakeLists 的路径message(\"当前cmakel路径: ${CMAKE_SOURCE_DIR} \\n cpu架构：${CMAKE_ANDROID_ARCH_ABI}\")add_library( ffmpeg_lib SHARED ${allCpp})find_library( log-lib log)# 引入FFmpeg的头文件include_directories(${CMAKE_SOURCE_DIR}/include)# 引入FFmpeg的库文件，设置内部的方式引入，指定库的目录是 -L 指定具体的库-lset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -L${CMAKE_SOURCE_DIR}/${CMAKE_ANDROID_ARCH_ABI}\")target_link_libraries( ffmpeg_lib # 具体的库文件，链接到总库 # 这样写会报错，有坑 # avcodec avfilter avformat avutil swresample swscale # 先把有依赖的库，先依赖进来 avformat avcodec avfilter avutil swresample swscale ${log-lib}) app/build.gradle 配置 12345678910111213141516171819202122apply plugin: 'com.android.application'android { compileSdkVersion 29 buildToolsVersion \"29.0.2\" ... defaultConfig { ... externalNativeBuild(){ cmake{ abiFilters \"armeabi-v7a\" //指定编译为 armeabi-v7a } } }... externalNativeBuild(){ cmake{ //指定构建 C++ 代码脚本 path 'src/main/cpp/CMakeLists.txt' } }}... MainActivity 测试代码 123456789101112131415161718192021public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\"ffmpeg_lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView ffmpegVer = findViewById(R.id.ffmpeg_ver); ffmpegVer.setText(\"当前 FFmpeg 版本为:\" + getFFmpegVersion()); } /** * @return 返回当前 */ public native static String getFFmpegVersion();} 效果: 到这里 FFmpeg 编译及导入 AS 使用已经全部介绍完了，动态库编译及使用需要自己动手去实践了，使用方式都大同小异。 总结在编译 FFmpeg 的时候会出现很多坑，基本上每个版本的 shell 脚本编写都不一样，所以如果对 Shell 不太了解的，建议先去复习一下。 该篇文章下来咱们用到了交叉编译、 Shell 脚本、 JNI 、Cmake 的知识，如果对这些基础还不了解的一定要先去把基础学好。也可以看我之前系列基础文章。 文章中的代码 感谢 FFmpeg","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AD-FFmpeg-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"title":"音视频学习 (十) 基于 Nginx 搭建直播服务器","text":"前言最近这几年做直播和短视频领域是真的很火，而且直播的领域也很广泛，可以预见，未来的音视频技术将会作为一种基础技术应用到更广泛的场景中。它可以与 AR/VR 结合，让你在远端体验虚拟与现实，如虚拟服装体验；也可以与人工智能结合用于提高服务质量，如用于教学上帮助老师提高教学质量；它还可以与物联网结合，用在自动驾驶、家庭办公等领域。那么这么火范围这么广的领域我们可不可以参与一下呢，肯定是可以的，下面我们借助 Nginx 和 nginx-http-flv-module 搭建一个简易的直播服务器，当然如果对并发要求不是太高的，这个完全可以满足了。 由于笔者没有后台服务开发的经验并且对一些服务环境配置也不太懂，所以也是参考了一些博客最后总结了一套安装使用教程，下面附上详细的步骤。 注意: 以下文字中如有出现 http://ip:port ，请替换成您自己的 IP 或域名。 直播协议介绍国内常见公开的直播协议有几个：RTMP、HLS、HDL（HTTP-FLV）、RTP，我们来逐一介绍。 RTMP它是 Adobe 的专利协议，现在大部分国外的 CDN 已不支持。在国内流行度很高。原因有几个方面： 1、开源软件和开源库的支持稳定完整。如斗鱼主播常用的 OBS 软件，开源的 librtmp 库，服务端有 nginx-rtmp 插件。 2、播放端安装率高。只要浏览器支持 FlashPlayer 就能非常简易的播放 RTMP 的直播，协议详解可以 Google 了解。相对其他协议而言，RTMP 协议初次建立连接的时候握手过程过于复杂（底层基于 TCP，这里说的是 RTMP 协议本身的交互），视不同的网络状况会带来给首开带来 100ms 以上的延迟。基于 RTMP 的直播一般内容延迟在2~5 秒。 HTTP-FLV即使用 HTTP 协议流式的传输媒体内容。相对于 RTMP，HTTP 更简单和广为人知，而且不担心被 Adobe 的专利绑架。内容延迟同样可以做到 2~5 秒，打开速度更快，因为 HTTP 本身没有复杂的状态交互。所以从延迟角度来看，HTTP-FLV 要优于 RTMP。 HLS即 Http Live Streaming ，是由苹果提出基于 HTTP 的流媒体传输协议。HLS 有一个非常大的优点：HTML5 可以直接打开播放；这个意味着可以把一个直播链接通过微信等转发分享，不需要安装任何独立的 APP，有浏览器即可，所以流行度很高。社交直播 APP，HLS 可以说是刚需，下来我们分析下其原理 。 基于 HLS 的直播流 URL 是一个 m3u8 的文件，里面包含了最近若干个小视频 TS（一种视频封装格式，这里就不扩展介绍）文件。如 http://ip:port/live.m3u8 是一个直播留链接，其内容如下： 假设列表里面的包含 5 个 TS 文件，每个 TS 文件包含 5 秒的视频内容，那么整体的延迟就是 25 秒。当然可以缩短列表的长度和单个 TS 文件的大小来降低延迟，极致来说可以缩减列表长度为 1，1 秒内容的 m3u8 文件，但是极易受网络波动影响造成卡顿。通过公网的验证，目前按同城网络可以做到比较好的效果是 5~7 秒的延迟，也是综合流畅度和内容延迟的结果。 RTP即 Real-time Transport Protocol ，用于 Internet 上针对多媒体数据流的一种传输层协议。 实际应用场景下经常需要 RTCP（RTP Control Protocol）配合来使用，可以简单理解为 RTCP 传输交互控制的信令，RTP 传输实际的媒体数据。 RTP 在视频监控、视频会议、IP 电话上有广泛的应用，因为视频会议、IP 电话的一个重要的使用体验：内容实时性强。 对比与上述 3 种或实际是 2 种协议，RTP 和它们有一个重要的区别就是默认是使用 UDP 协议来传输数据，而 RTMP 和 HTTP 是基于 TCP 协议传输。为什么 UDP 能做到如此实时的效果呢？关于 TCP 和 UDP 差别的分析文章一搜一大把，这里不在赘述，简单概括： UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序； TCP：流式，需要建立连接，复杂，可靠 ，有序。 实时音视频流的场景不需要可靠保障，因此也不需要有重传的机制，实时的看到图像声音，网络抖动时丢了一些内容，画面模糊和花屏，完全不重要。TCP 为了重传会造成延迟与不同步，如某一截内容因为重传，导致 1 秒以后才到，那么整个对话就延迟了 1 秒，随着网络抖动，延迟还会增加成 2 秒、3 秒，如果客户端播放是不加以处理将严重影响直播的体验。 总结一下：在直播协议的选择中，如果选择是 RTMP 或 HTTP-FLV 则意味着有 25 秒的内容延迟，但是就打开延迟开，HTTP-FLV 要优于 RTMP。HLS 则有 57 秒的内容延迟。选择 RTP 进行直播则可以做到1秒内的直播延迟。但就目前所了解，各大 CDN 厂商没有支持基于 RTP 直播的，所以目前国内主流还是 RTMP 或 HTTP-FLV 。 流媒体服务器开源软件 流媒体服务器 环境准备本来我打算是在我的 个人博客 服务器上搭建的，最终还是放弃了，因为之前的带宽跟容量也不是很大，也正巧碰见了 腾讯云 这几天在搞活动就又购买了一台服务器，以后关于后台服务的项目也基本上在这台部署了。 以下是我搭建以及测试的环境 搭建服务器环境 云服务器: 腾讯云 系统: centos 直播服务器: nginx 拓展模块: nginx-http-flv-module (支持 rtmp、http-flv、http-hls 等) 如果 NGINX 要支持正则表达式，需要安装 PCRE库。 如果 NGINX 要支持加密访问，需要安装 OpenSSL库。 如果 NGINX 要支持压缩，需要安装 zlib库。 测试环境: 电脑 : MAC 推流软件: obs-studio MAC 拉流软件: VLC Android 拉流软件: 前几天写的一个 Android 播放器 ykplayer 正好供于拉流测试 HTML5 FLV 播放器: bilibili 开源的 flv.js 本来之前我是借助 nginx-rtmp-module 来搭建的直播服务器(已成功)，奈何它好像不支持 Http-flv 协议，所以替换成了 nginx-http-flv-module 模块，它是基于 nginx-rtmp-module 模块二次开发的，所以完美的继承了 rtmp 模块的所有功能。 服务器搭建1. download nginx1234# 通过 wget 命令下载wget http://nginx.org/download/nginx-1.17.8.tar.gz# 解压tar -zxvf nginx-1.17.8.tar.gz 2. download nginx-http-flv-module提醒: 关于它的详细信息可以参考它的介绍 123456# 通过 wget 命令下载wget https://github.com/winshining/nginx-http-flv-module/archive/v1.2.7.tar.gz# 解压tar -zxvf v1.2.7.tar.gz# 重命名mv v1.2.7 nginx-http-flv-module 3. install nginx 需要的环境如果在执行 configure 之后报 OpenSSL 、PCRE 、Zlib error 那么就必须安装它们 123456#安装 opensslyum install openssl#安装 pcreyum install pcre-devel#安装 zlibyum install zlib-devel 等它们安装好了之后编译 nginx 4. build nginx在当前解压 nginx 目录中创建编译 nginx 和 http-flv 脚本 123456789101112131415#!/bin/sh# ../ 代表当前目录的上一级HTTP_FLV_MODULE_PATH=../nginx-http-flv-module-1.2.7OpenSSL_PATH=../openssl-1.1.1d#--prefix=./bin 代表编译完成之后输出的路径地址#--add-module 将拓展模块添加到当前一起编译./configure --prefix=./bin \\--add-module=$HTTP_FLV_MODULE_PATH \\--with-openssl=$OpenSSL_PATH \\--with-debug# 通过 make install 构建makemake install 如果中途没有报任何错误，并且输出了我们指定的 bin 目录，那么就代表成功了。如下图所示: 5. 配置 nginx.conf在当前目录下输入 vim bin/conf/nginx.conf 进行配置 rtmp、http 直播协议，我直接贴上我的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130user root;worker_processes auto; #运行在Windows上时，设置为1，因为Windows不支持Unix domain socket#worker_processes auto; #1.3.8和1.2.5以及之后的版本#worker_cpu_affinity 0001 0010 0100 1000; #只能用于FreeBSD和Linuxworker_cpu_affinity auto; #1.9.10以及之后的版本error_log logs/error.log error;#如果此模块被编译为动态模块并且要使用与RTMP相关的功#能时，必须指定下面的配置项并且它必须位于events配置#项之前，否则NGINX启动时不会加载此模块或者加载失败#load_module modules/ngx_http_flv_live_module.so;events { worker_connections 4096;}http { include mime.types; default_type application/octet-stream; keepalive_timeout 65; server { listen 80;//自定义填写 http 的端口 location / { root /root/nginx/nginx-http-flv-module-1.2.7/test/www; index index.html index.htm;//默认首页 } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } location /flvjsplay {//测试地址 root /root/nginx/flv.js-1.5.0; index index.html;//flv.js 测试播放首页 } location /flv { flv_live on; #打开HTTP播放FLV直播流功能 chunked_transfer_encoding on; #支持'Transfer-Encoding: chunked'方式回复 #跨域 add_header 'Access-Control-Allow-Origin' '*'; #添加额外的HTTP头 add_header 'Access-Control-Allow-Credentials' 'true'; #添加额外的HTTP头 } location /hls { types { application/vnd.apple.mpegurl m3u8; video/mp2t ts; } root /root/nginx/nginx-http-flv-module-1.2.7; add_header 'Cache-Control' 'no-cache'; index hlsplay.html;//浏览器播放的页面。 } location /dash { root /root/nginx/nginx-http-flv-module-1.2.7; add_header 'Cache-Control' 'no-cache'; } location /stat { #push和pull状态的配置 rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.xsl { root /root/nginx/nginx-http-flv-module-1.2.7; #指定stat.xsl的位置 } #如果需要JSON风格的stat, 不用指定stat.xsl #但是需要指定一个新的配置项rtmp_stat_format #location /stat { # rtmp_stat all; # rtmp_stat_format json; #} location /control { rtmp_control all; #rtmp控制模块的配置 } }}rtmp_auto_push on;rtmp_auto_push_reconnect 1s;rtmp_socket_dir /root/nginx/nginx-http-flv-module-1.2.7;rtmp { out_queue 4096; out_cork 8; max_streams 128; timeout 30s; drop_idle_publisher 30s; log_interval 5s; #log模块在access.log中记录日志的间隔时间，对调试非常有用 log_size 1m; #log模块用来记录日志的缓冲区大小 server { listen 1935;//自定义 rtmp 端口 # server_name www.test.*; #用于虚拟主机名后缀通配 application devyk { live on; gop_cache on; #打开GOP缓存，减少首屏等待时间 } application hls { live on; hls on; hls_path /root/nginx/nginx-http-flv-module-1.2.7/hls; } application dash { live on; dash on; dash_path /root/nginx/nginx-http-flv-module-1.2.7/dash; } } #可以有多个 server 配置} Nginx 配置文件详解请看该篇文章 Nginx 配置文件详解请看该篇文章 nginx-rtmp-module配置指令详解 在根目录输入 bin/sbin/nginx -t , 如出现如下就说明配置成功。 6. 开启 nginx 服务12345678#开启服务bin/sbin/nginx#停止服务bin/sbin/nginx -s stop#重启服务bin/sbin/nginx -s reload 7. 网页测试是否都显示正常 直接在网页上输入: http://ip:port，如果出现如下，证明首页和基本配置没有问题了 直接在网页输入: http://ip:port/stat 如出现如下监控页面，说明监控页面一切正常。 现在服务器搭建完成，下面可以进入测试环节了。 rtmp 推流我们直接用开源 obs-studio 软件进行推流，听说很多游戏主播也用该款推流软件。 推流源设置: 如上图所示，证明已经推流成功了，下面我们就来测试拉流。 拉流flv 在 Html5 上播放注意: 其它播放也是如下格式，这里只是以 Html 举例说明: 例子: 假设在http配置块中的listen配置项是： 1234567891011http { ... server { listen 8080; #不是默认的80端口 ... location /live { flv_live on; } }} 在rtmp配置块中的listen配置项是： 1234567891011rtmp { ... server { listen 1935; #也可以不是默认的1935端口 ... application myapp { live on; } }} 并且发布的流的名称是mystream，那么基于 HTTP-FLV 的播放url是： 1http://ip:8080/flv?port=1935&amp;app=myapp&amp;stream=mystream 播放器这里选择 bilibili 开源的 flv.js , 既然我们已经有服务器了，那就直接把 flv.js 项目部署在服务器上吧 安装 npm 1234#安装 npmyum install npm#检查是否安装成功，如有输出证明安装成功npm --version 直接下载 flv.js 到服务器上 1234#通过 wget 下载wget https://github.com/bilibili/flv.js/archive/v1.5.0.tar.gz#解压tar -zxvf v1.5.0.tar.gz 安装 进入 flv.js 根目录直接输入 npm install 命令，安装完成之后会出现一个 node_modules 模块 安装生成工具 还是在当前根目录下安装，输入如下命令: 1npm install -g gulp 包装和最小化 js 放入 dist 文件夹中 12#输入如下命令gulp release 这一步执行完成之后会生成如下文件: 修改 demo 提供的播放页面 将 demo 中 2 个文件(.ccs,.js) copy 到 dist 文件下,并修改 html 中 flv.js 路径，如下所示: 最后将 dist 文件夹重命名 flvjsplay 部署 nginx.conf 配置网页加载路径: 1234location /flvjsplay {//测试地址 root /root/nginx/flv.js-1.5.0; index index.html;#flv.js 测试播放首页} 修改了配置文件需要在 nginx 根目录输入如下指令，对 nginx 服务器重启: 12#重新启动bin/sbin/nginx -s reload chrome 加载播放 左边是拉流，右边是推流 可以看到首屏加载速度还是比较快延迟在 2-5s 之间，画面延迟有点高跟我服务器和网络有关。 VLC rtmp 拉流播放VLC 点击文件-&gt;打开网络输入 rtmp 拉流地址点击播放 123456//配置rtmp 拉流格式//ip:host//rtmpPost:rtmp 服务的端口//appname 配置在rtmp application 的名称//streamname：推流的时候填写的密码rtmp://ip:rtmpPort/appname/streamname 左边是拉流，右边是推流 http-hls 播放播放格式: 1http://ip:port/hls/streamname.m3u8 因为笔者不是做 H5 开发的，所以对浏览器播放 HLS 直播流兼容性不是太清楚，我就直接使用 video 标签在我电脑上用 chrome 浏览器测试, 结果是播放不出来的，查了资料好像说是原生 video 标签仅支持 MP4、WebM、Ogg 格式，那这怎么办呢？其实可以直接使用开源项目来解决的，比如 video.js 、videojs-contrib-hls 等，我这里直接使用的是 videojs-contrib-hls ，目前测试在 Android 浏览器、PC 谷歌浏览器 、IOS 微信、IOS Safari 浏览器 均已成功，下面是 Html 代码，如下所示: 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Player&lt;/title&gt; &lt;link href=\"https://unpkg.com/video.js/dist/video-js.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;video id=\"video\" class=\"video-js vjs-default-skin\" controls autoplay=\"autoplay\" width=\"640\" height=\"320\" data-setup='{}' poster=\"https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200221192142.png\"&gt; //换成你自己的直播链接 &lt;source src=\"http://ip:8082/hls/live1.m3u8\" type=\"application/x-mpegURL\" /&gt; &lt;/video&gt; &lt;script src=\"https://unpkg.com/video.js/dist/video.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.12.1/videojs-contrib-hls.min.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意:在这儿使用的js等资源皆是在线的一些支持。若需要在项目中使用，最好下载到本地使用 为了测试方便，我也直接把该 Html 代码部署到了云服务器中，nginx.conf 配置如下: 1234location /hlsplay { root /root/nginx/nginx-http-flv-module-1.2.7/hls; index hlsplay.html; //指定首页，也就是我们播放的页面，hlsplay.html 就是上面代码。} 重启 nginx 服务器之后，直接输入 http://ip:port/hlsplay 就可以播放了，测试效果如下图: VLC、Html5、android 三端同时拉流测试 总结到这里您已经成功搭建直播服务器了，虽然说该篇文章没有敲任何的代码，也许你会说没有学到什么，但是搭建服务器和部署一套直播环境这个过程也都是值得我们作为一个移动或者前端开发者学习的。 参考 直播协议介绍 nginx + nginx-http-flv-module 搭建文档 感谢 Igor Sysoev，NGINX的作者。 Roman Arutyunyan，nginx-rtmp-module的作者。 winshining ,nginx-http-flv-module 的作者。 obsproject ，obs-studio (用于实时流式传输和屏幕录制)。 bilibili，HTML5 flv.js","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81-%E5%9F%BA%E4%BA%8E-Nginx-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"音视频学习 (八) 视频渲染","text":"简介上一篇文章我们学习了音频的基础知识和音频的渲染之后，该篇我们学习视频的知识，与上一篇学习方式一样，基础 + demo ，主打渲染，采集跟编码我们后面学习播放器和录屏在来研究。 视频的基础知识图像的物理现象做过 Camera 采集或者做过帧动画其实应该知道，视频是由一幅幅图像或者说一帧帧 YUV 数据组成，所以要学习视频还得从图像开始学习。 我们回顾一下，应该是初中的时候做过一个三棱镜实验，内容是如何利用三棱镜将太阳光分解成彩色的光带？第一个做这个实验者是 牛顿 ，各色光因其所形成的折射角不同而彼此分离，就像彩虹一样，所以白光能够分解成多种色彩的光。后来人们通过实验证明，红绿蓝三种色光无法被分解，故称为三原色光，等量的三原色光相加会变为白光，即白光中含有等量的红光(R),绿光(G),蓝光(B)。 在日常生活中，由于光的反射，我们才能看到各类物体的轮廓和颜色。但是如果将这个理论应用到手机中，那么该结论还成立吗？答案是否定的，因为在黑暗中我们也可以看到手机屏幕中的内容，实际上人眼能看到手机屏幕上的内容的原理如下。 假设一部手机屏幕的分辨率是 1920 * 1080 说明水平方向有 1080 个像素点，垂直方向有 1920 个像素点，所以整个屏幕就有 1920 * 1080 个像素点(这也是分辨率的含义)。每个像素点都由三个子像素点组成，如下图所示，这些密密麻麻的子像素点在图像放大或者在显微镜下可以看得一清二楚。当要显示某篇文字或者某幅图像时，就会把这幅图像的每一个像素点的 RGB 通道分别对应的屏幕位置上的子像素点绘制到屏幕上，从而显示整个图像。 所以在黑暗的环境下也能看到手机屏幕上的内容，是因为手机屏幕是自发光的，而不是通过光的反射才被人们看到的。 图像的数值表示RGB 表示方式通过上一小节我们清楚的知道任何一个图像都是由 RGB 组成，那么一个像素点的 RGB 该如何表示呢？音频里面的每一个采样 (sample) 均使用 16 bit 来表示，那么像素里面的子像素又该如何表示呢？通常的表示方式有以下几种。 浮点表示: 取值范围在 0.0 ~ 1.0 之间，比如在 OpenGL ES 中对每一个子像素点的表示使用的就是这种方式。 整数表示: 取值范围为 0 ~ 255 或者 00 ~ FF , 8 个 bit 表示一个子像素点，32 个 bit 表示一个像素，这就是类似某些平台上表示图像格式的 RGBA_8888 数据格式。比如 Android 平台上的 RGB_565 的表示方法为 16 个 bit 模式表示一个像素， R 用 5 个 bit , G 用 6 个 bit, B 用 5 个 bit 来表示。 对于一幅图像，一般使用整数表示方法进行描述，比如计算一张 1920 * 1080 的 RGB_8888 的图像大小，可采用如下计算方式: 11920 * 1080 * 4 / 1024 / 1024 ≈ 7.910 MB 这也是 Bitmap 在内存中所占用的大小，所以每一张图像的裸数据都是很大的。对于图像的裸数据来说，直接来网络中进行传输也是不大可能的，所以就有了图像的压缩格式，比如我之前开源过一个基于 JPEG 压缩 :JPEG 是静态图像压缩标准，由 ISO 制定。 JPEG 图像压缩算法在提供良好的压缩性能的同时，具有较好的重建质量。这种算法被广泛应用于图像处理领域，当然它也是一种有损压缩。在很多网站如淘宝上使用的都是这种压缩之后的图像，但是，这种压缩不能直接应用于视频压缩，因为对于视频来讲，还有一个时域上的因素需要考虑，也就是说不仅仅要考虑帧内编码，还要考虑帧间编码。视频采用的是更加成熟的算法，关于视频压缩算法的相关内容我们会在后面进行介绍。 YUV 表示方式对于视频帧的裸数据表示，其实更多的是 YUV 数据格式的表示， YUV 主要应用于优化彩色视频信号的传输，使其向后兼容老式黑白电视。在 RGB 视频信号传输相比，它最大的优点在于只需要占用极少的频宽(RGB 要求三个独立的视频信号同时传输)。其中 Y 表示明亮度，而 “U”,”V” 表示的则是色度值，它们的作用是描述影像的色彩及饱和度，用于指定像素的颜色。“亮度” 是透过 RGB 输入信号来建立的，方法时将 RGB 信号的特定部分叠加到一起。“色度” 则定义了颜色的两个方面 - 色调与饱和度，分别用 Cr 和 Cb 来表示。其中，Cr 反应了 RGB 输入信号红色部分与 RGB 信号亮度值之间的差异，而 Cb 反映的则是 RGB 输入信号蓝色部分与 RGB 信号亮度值之间的差异。 之所以采用 YUV 色彩空间，是因为它的亮度信号 Y 和色度信号 U、V 是分离的。如果只有 Y 信号分量而没有 U 、V 分量，那么这样表示的图像就是黑白灰图像。彩色电视采用 YUV 空间正是为了用亮度信号 Y 解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号，最常用的表示形式是 Y、U、V 都使用 8 字节来表示，所以取值范围是 0 ~ 255 。 在广播电视系统中不传输很低和很高的数值，实际上是为了防止信号变动造成过载， Y 的取值范围都是 16 ~ 235 ，UV 的取值范围都是 16 ~ 240。 YUV 最常用的采样格式是 4:2:0 ， 4:2:0 并不意味着只有 Y 、Cb 而没有 Cr 分量。它指的是对每行扫描线来说，只有一种色度分量是以 2：1 的抽样率来存储的。相邻的扫描行存储着不同的色度分量，也就是说，如果某一行是 4：2：0，那么下一行就是 4：0：2，在下一行是 4：2：0，以此类推。对于每个色度分量来说，水平方向和竖直方向的抽象率都是 2：1，所以可以说色度的抽样率是 4：1。对非压缩的 8 bit 量化的视频来说，8*4 的一张图片需要占用 48 byte 内存。 相较于 RGB ，我们可以计算一帧为 1920 * 1080 的视频帧，用 YUV420P 的格式来表示，其数据量的大小如下: 1(1920 * 1080 * 1 + 1920 * 1080 * 0.5 ) / 1024 /1024 ≈ 2.966MB 如果 fps（1 s 的视频帧数量）是 25 ，按照 5 分钟的一个短视频来计算，那么这个短视频用 YUV420P 的数据格式来表示的话，其数据量的大小就是 : 12.966MB * 25fps * 5min * 60s / 1024 ≈ 21GB 可以看到仅仅 5 分钟的视频数据量就能达到 21 G, 像抖音，快手这样短视频领域的代表这样的话还不卡死，那么如何对短视频进行存储以及流媒体播放呢？答案肯定是需要进行视频编码，后面会介绍视频编码的内容。 如果对 YUV 采样或者存储不明白的可以看这篇文章:音视频基础知识—像素格式YUV YUV 和 RGB 的转化前面已经讲过，凡是渲染到屏幕上的文字、图片、或者其它，都需要转为 RGB 的表示形式，那么 YUV 的表示形式和 RGB 的表示形式之间是如何进行转换的呢？可以参考该篇文章YUV &lt;——&gt; RGB 转换算法, 相互转换 C++ 代码可以参考地址 视频的编码方式视频编码还记得上一篇文章我们学习的音频编码方式吗？音频的编码主要是去除冗余信息，从而实现数据量的压缩。那么对于视频压缩，又该从哪几个方面来对数据进行压缩呢？其实与之前提到的音频编码类似，视频压缩也是通过去除冗余信息来进行压缩的。相较于音频数据，视频数据有极强的相关性，也就是说有大量的冗余信息，包括空间上的冗余信息和时间上的冗余信息，具体包括以下几个部分。 运动补偿: 运动补偿是通过先前的局部图像来预测，，补偿当前的局部图像，它是减少帧序列冗余信息的有效方法。 运动表示: 不同区域的图像需要使用不同的运动矢量来描述运动信息。 运动估计: 运动估计是从视频序列中抽取运动信息的一整套技术。 使用帧内编码技术可以去除空间上的冗余信息。 大家还记得之前提到的图像编码 JPEG 吗？对于视频， ISO 同样也制定了标准: Motion JPEG 即 MPEG ，MPEG 算法是适用于动态视频的压缩算法，它除了对单幅图像进行编码外，还利用图像序列中的相关原则去除冗余，这样可以大大提高视频的压缩比，截至目前，MPEG 的版本一直在不断更新中，主要包括这样几个版本: Mpeg1(用于 VCD)、Mpeg2(用于 DVD)、Mpeg4 AVC(现在流媒体使用最多的就是它了)。 想比较 ISO 指定的 MPEG 的视频压缩标准，ITU-T 指定的 H.261、H.262、H.263、H.264 一系列视频编码标准是一套单独的体系。其中，H.264 集中了以往标准的所有优点，并吸取了以往标准的经验，采样的是简洁设计，这使得它比 Mpeg4 更容易推广。现在使用最多的就是 H.264 标准, H.264 创造了多参考帧、多块类型、整数变换、帧内预测等新的压缩技术，使用了更精准的分像素运动矢量(1/4、1/8) 和新一代的环路滤波器，这使得压缩性能得到大大提高，系统也变得更加完善。 编码概念视频编码中，每帧都代表着一幅静止的图像。而在进行实际压缩时，会采取各种算法以减少数据的容量，其中 IPB 帧就是最常见的一种。 IPB 帧 I 帧: 表示关键帧，你可以理解为这一帧画面的完整保留，解码时只需要本帧数据就可以完成(包含完整画面)。 P 帧: 表示的是当前 P 帧与上一帧( I 帧或者 P帧)的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别生成最终画面。(也就是差别帧， P 帧没有完整画面数据，只有与前一帧的画面差别的数据。) B 帧: 表示双向差别帧，也就是 B 帧记录的是当前帧与前后帧(前一个 I 帧或 P 帧和后面的 P 帧)的差别(具体比较复杂，有 4 种情况)， 换言之，要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面数据与本帧数据的叠加取得最终的画面。B 帧压缩率高，但是解码时 CPU 会比较吃力。 IDR 帧与 I 帧的理解在 H264 的概念中有一个帧称为 IDR 帧，那么 IDR 帧与 I 帧的区别是什么呢 ？ 首先要看下 IDR 的英文全称 instantaneous decoding refresh picture , 因为 H264 采用了多帧预测，所以 I 帧之后的 P 帧有可能会参考 I 帧之前的帧，这就使得在随机访问的时候不能以找到 I 帧作为参考条件，因为即使找到 I 帧，I 帧之后的帧还是有可能解析不出来，而 IDR 帧就是一种特殊的 I 帧，即这一帧之后的所有参考帧只会参考到这个 IDR 帧，而不会再参考前面的帧。在解码器中，一旦收到第一个 IDR 帧，就会立即清理参考帧缓冲区，并将 IDR 帧作为被参考的帧。 PTS 与 DTSDTS 主要用视频的解码，全称为(Decoding Time Stamp), PTS 主要用于解码阶段进行视频的同步和输出， 全称为 (Presentation Time Stamp) 。在没有 B 帧的情况下， DTS 和 PTS 的输出顺序是一样的。因为 B 帧打乱了解码和显示的顺序，所以一旦存在 B 帧， PTS 与 DTS 势必就会不同。在大多数编解码标准(H.264 或者 HEVC) 中，编码顺序和输入顺序并不一致，于是才会需要 PTS 和 DTS 这两种不同的时间戳。 GOP 的概念两个 I 帧之间形成的一组图片，就是 GOP (Group Of Picture) 的概念。通常在为编码器设置参数的时候，必须要设置 gop_size 的值，其代表的是两个 I 帧之间的帧数目。一个 GOP 中容量最大的帧就是 I 帧，所以相对来讲，gop_size 设置得越大，整个画面的质量就会越好，但是在解码端必须从接收到的第一个 I 帧开始才可以正确的解码出原始图像，否则会无法正确解码，在提高视频质量的技巧中，还有个技巧是多使用 B 帧，一般来说，I 的压缩率是 7 （与 JPG 差不多），P 是 20 ，B 可以达到 50 ，可见使用 B 帧能节省大量空间，节省出来的空间可以用来更多地保存 I 帧，这样就能在相同的码率下提供更好的画质，所以我们要根据不同的业务场景，适当地设置 gop_size 的大小，以得到更高质量的视频。 结合下图，希望可以帮组大家更好的理解 DTS 和 PTS 的概念。 ! 视频渲染OpenGL ES实现效果 介绍OpenGL (Open Graphics Lib) 定义了一个跨编程语言、跨平台编程的专业图形程序接口。可用于二维或三维图像的处理与渲染，它是一个功能强大、调用方便的底层图形库。对于嵌入式的设备，其提供了 OpenGL ES(OpenGL for Embedded System) 版本，该版本是针对手机、Pad 等嵌入式设备而设计的，是 OpenGL 的一个子集。到目前为止，OpenGL ES 已经经历过很多版本的迭代与更新，到目前为止运用最广泛的还是 OpenGL ES 2.0 版本。我们接下来所实现的 Demo 就是基于 OpenGL ES 2.0 接口进行编程并实现图像的渲染。 由于 OpenGL ES 是基于跨平台的设计，所以在每个平台上都要有它的具体实现，既要提供 OpenGL ES 的上下文环境以及窗口的管理。在 OpenGL 的设计中，OpenGL 是不负责管理窗口的。那么在 Android 平台上其实是使用 EGL 提供本地平台对 OpenGL ES 的实现。 使用要在 Android 平台下使用 OpenGL ES , 第一种方式是直接使用 GLSurfaceView ，通过这种方式使用 OpenGL ES 比较简单，因为不需要开发者搭建 OpenGL ES 的上下文环境，以及创建 OpenGL ES 的显示设备。但是凡事都有两面，有好处也有坏处，使用 GLSurfaceView 不够灵活，很多真正的 OpenGL ES 的核心用法(比如共享上下文来达到多线程使用 EGL 的 API 来搭建的，并且是基于 C++ 的环境搭建的。因为如果仅仅在 Java 层编写 ，那么对于普通的应用也许可行，但是对于要进行解码或者使用第三方库的场景(比如人脸识别)，则需要到 C++ 层来实施。处于效率和性能的考虑，这里的架构将直接使用 Native 层的 EGL 搭建一个 OpenGL ES 的开发环境。要想在 Native 层使用 EGL ,那么就必须在 CmakeLists.txt 中添加 EGL 库(可以参考如下提供的 CMakeLists 文件配置)，并在使用该库的 C++ 文件中引入对应的头文件，需要引如的头文件地址如下: 1234567891011//1. 在开发中如果要使用 EGL 需要在 CMakeLists.txt 中添加 EGL 库，并指定头文件//使用 EGL 需要添加的头文件#include &lt;EGL/egl.h&gt;#include &lt;EGL/eglext.h&gt;//2. 使用 OpenGL ES 2.0 也需要在 CMakeLists.txt 中添加 GLESv2 库，并指定头文件//使用 OpenGL ES 2.0 需要添加的头文件#include &lt;GLES2/gl2.h&gt;#include &lt;GLES2/gl2ext.h&gt; CMakeLists 文件配置: 12345678910111213141516171819202122232425262728293031323334cmake_minimum_required(VERSION 3.4.1)#音频渲染set(OpenSL ${CMAKE_SOURCE_DIR}/opensl)#视频渲染set(OpenGL ${CMAKE_SOURCE_DIR}/gles)#批量添加自己编写的 cpp 文件,不要把 *.h 加入进来了file(GLOB ALL_CPP ${OpenSL}/*.cpp ${OpenGL}/*.cpp)#添加自己编写 cpp 源文件生成动态库add_library(audiovideo SHARED ${ALL_CPP})#找系统中 NDK log库find_library(log_lib log)#最后才开始链接库target_link_libraries( #最后生成的 so 库名称 audiovideo #音频渲染 OpenSLES # OpenGL 与 NativeWindow 连接本地窗口的中间者 EGL #视频渲染 GLESv2 #添加本地库 android ${log_lib}) 至此，对于 OpenGL 的开发需要用到的头文件以及库文件就引入完毕了，下面再来看看如何使用 EGL 搭建出 OpenGL 的上下文环境以及渲染视频数据。 使用 EGL 首先必须创建，建立本地窗口系统和 OpenGL ES 的连接 123456789//1.获取原始窗口nativeWindow = ANativeWindow_fromSurface(env, surface);//获取Displaydisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);if (display == EGL_NO_DISPLAY) { LOGD(\"egl display failed\"); showMessage(env, \"egl display failed\", false); return;} 初始化 EGL 123456//初始化egl，后两个参数为主次版本号 if (EGL_TRUE != eglInitialize(display, 0, 0)) { LOGD(\"eglInitialize failed\"); showMessage(env, \"eglInitialize failed\", false); return; } 确定可用的渲染表面（ Surface ）的配置。 12345678910111213141516//surface 配置，可以理解为窗口EGLConfig eglConfig;EGLint configNum;EGLint configSpec[] = { EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_SURFACE_TYPE, EGL_WINDOW_BIT, EGL_NONE}; if (EGL_TRUE != eglChooseConfig(display, configSpec, &amp;eglConfig, 1, &amp;configNum)) { LOGD(\"eglChooseConfig failed\"); showMessage(env, \"eglChooseConfig failed\", false); return;} 创建渲染表面 surface（4/5步骤可互换） 1234567//创建surface(egl和NativeWindow进行关联。最后一个参数为属性信息，0表示默认版本) winSurface = eglCreateWindowSurface(display, eglConfig, nativeWindow, 0); if (winSurface == EGL_NO_SURFACE) { LOGD(\"eglCreateWindowSurface failed\"); showMessage(env, \"eglCreateWindowSurface failed\", false); return; } 创建渲染上下文 Context 1234567891011//4 创建关联上下文const EGLint ctxAttr[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE};//EGL_NO_CONTEXT表示不需要多个设备共享上下文context = eglCreateContext(display, eglConfig, EGL_NO_CONTEXT, ctxAttr);if (context == EGL_NO_CONTEXT) { LOGD(\"eglCreateContext failed\"); showMessage(env, \"eglCreateContext failed\", false); return;} 指定某个 EGLContext 为当前上下文, 关联起来 1234567//将egl和opengl关联//两个surface一个读一个写。第二个一般用来离线渲染if (EGL_TRUE != eglMakeCurrent(display, winSurface, winSurface, context)) { LOGD(\"eglMakeCurrent failed\"); showMessage(env, \"eglMakeCurrent failed\", false); return;} 使用 OpenGL 相关的 API 进行绘制操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188GLint vsh = initShader(vertexShader, GL_VERTEX_SHADER);GLint fsh = initShader(fragYUV420P, GL_FRAGMENT_SHADER); //创建渲染程序GLint program = glCreateProgram();if (program == 0) { LOGD(\"glCreateProgram failed\"); showMessage(env, \"glCreateProgram failed\", false); return;} //向渲染程序中加入着色器glAttachShader(program, vsh);glAttachShader(program, fsh); //链接程序glLinkProgram(program);GLint status = 0;glGetProgramiv(program, GL_LINK_STATUS, &amp;status);if (status == 0) { LOGD(\"glLinkProgram failed\"); showMessage(env, \"glLinkProgram failed\", false); return;}LOGD(\"glLinkProgram success\");//激活渲染程序glUseProgram(program); //加入三维顶点数据static float ver[] = { 1.0f, -1.0f, 0.0f, -1.0f, -1.0f, 0.0f, 1.0f, 1.0f, 0.0f, -1.0f, 1.0f, 0.0f}; GLuint apos = static_cast&lt;GLuint&gt;(glGetAttribLocation(program, \"aPosition\"));glEnableVertexAttribArray(apos);glVertexAttribPointer(apos, 3, GL_FLOAT, GL_FALSE, 0, ver); //加入纹理坐标数据static float fragment[] = { 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f};GLuint aTex = static_cast&lt;GLuint&gt;(glGetAttribLocation(program, \"aTextCoord\"));glEnableVertexAttribArray(aTex);glVertexAttribPointer(aTex, 2, GL_FLOAT, GL_FALSE, 0, fragment); //纹理初始化//设置纹理层对应的对应采样器？ /** * //获取一致变量的存储位置GLint textureUniformY = glGetUniformLocation(program, \"SamplerY\");GLint textureUniformU = glGetUniformLocation(program, \"SamplerU\");GLint textureUniformV = glGetUniformLocation(program, \"SamplerV\");//对几个纹理采样器变量进行设置glUniform1i(textureUniformY, 0);glUniform1i(textureUniformU, 1);glUniform1i(textureUniformV, 2); *///对sampler变量，使用函数glUniform1i和glUniform1iv进行设置glUniform1i(glGetUniformLocation(program, \"yTexture\"), 0);glUniform1i(glGetUniformLocation(program, \"uTexture\"), 1);glUniform1i(glGetUniformLocation(program, \"vTexture\"), 2);//纹理IDGLuint texts[3] = {0};//创建若干个纹理对象，并且得到纹理IDglGenTextures(3, texts); //绑定纹理。后面的的设置和加载全部作用于当前绑定的纹理对象//GL_TEXTURE0、GL_TEXTURE1、GL_TEXTURE2 的就是纹理单元，GL_TEXTURE_1D、GL_TEXTURE_2D、CUBE_MAP为纹理目标//通过 glBindTexture 函数将纹理目标和纹理绑定后，对纹理目标所进行的操作都反映到对纹理上glBindTexture(GL_TEXTURE_2D, texts[0]);//缩小的过滤器glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);//放大的过滤器glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//设置纹理的格式和大小// 加载纹理到 OpenGL，读入 buffer 定义的位图数据，并把它复制到当前绑定的纹理对象// 当前绑定的纹理对象就会被附加上纹理图像。//width,height表示每几个像素公用一个yuv元素？比如width / 2表示横向每两个像素使用一个元素？glTexImage2D(GL_TEXTURE_2D, 0,//细节基本 默认0 GL_LUMINANCE,//gpu内部格式 亮度，灰度图（这里就是只取一个亮度的颜色通道的意思） width,//加载的纹理宽度。最好为2的次幂(这里对y分量数据当做指定尺寸算，但显示尺寸会拉伸到全屏？) height,//加载的纹理高度。最好为2的次幂 0,//纹理边框 GL_LUMINANCE,//数据的像素格式 亮度，灰度图 GL_UNSIGNED_BYTE,//像素点存储的数据类型 NULL //纹理的数据（先不传）); //绑定纹理glBindTexture(GL_TEXTURE_2D, texts[1]);//缩小的过滤器glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//设置纹理的格式和大小glTexImage2D(GL_TEXTURE_2D, 0,//细节基本 默认0 GL_LUMINANCE,//gpu内部格式 亮度，灰度图（这里就是只取一个颜色通道的意思） width / 2,//u数据数量为屏幕的4分之1 height / 2, 0,//边框 GL_LUMINANCE,//数据的像素格式 亮度，灰度图 GL_UNSIGNED_BYTE,//像素点存储的数据类型 NULL //纹理的数据（先不传）); //绑定纹理glBindTexture(GL_TEXTURE_2D, texts[2]);//缩小的过滤器glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//设置纹理的格式和大小glTexImage2D(GL_TEXTURE_2D, 0,//细节基本 默认0 GL_LUMINANCE,//gpu内部格式 亮度，灰度图（这里就是只取一个颜色通道的意思） width / 2, height / 2,//v数据数量为屏幕的4分之1 0,//边框 GL_LUMINANCE,//数据的像素格式 亮度，灰度图 GL_UNSIGNED_BYTE,//像素点存储的数据类型 NULL //纹理的数据（先不传）); unsigned char *buf[3] = {0};buf[0] = new unsigned char[width * height];//ybuf[1] = new unsigned char[width * height / 4];//ubuf[2] = new unsigned char[width * height / 4];//v showMessage(env, \"onSucceed\", true); FILE *fp = fopen(data_source, \"rb\");if (!fp) { LOGD(\"oepn file %s fail\", data_source); return;} while (!feof(fp)) { //解决异常退出,终止读取数据 if (!isPlay) return; fread(buf[0], 1, width * height, fp); fread(buf[1], 1, width * height / 4, fp); fread(buf[2], 1, width * height / 4, fp); //激活第一层纹理，绑定到创建的纹理 //下面的width,height主要是显示尺寸？ glActiveTexture(GL_TEXTURE0); //绑定y对应的纹理 glBindTexture(GL_TEXTURE_2D, texts[0]); //替换纹理，比重新使用glTexImage2D性能高多 glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0,//相对原来的纹理的offset width, height,//加载的纹理宽度、高度。最好为2的次幂 GL_LUMINANCE, GL_UNSIGNED_BYTE, buf[0]); //激活第二层纹理，绑定到创建的纹理 glActiveTexture(GL_TEXTURE1); //绑定u对应的纹理 glBindTexture(GL_TEXTURE_2D, texts[1]); //替换纹理，比重新使用glTexImage2D性能高 glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width / 2, height / 2, GL_LUMINANCE, GL_UNSIGNED_BYTE, buf[1]); //激活第三层纹理，绑定到创建的纹理 glActiveTexture(GL_TEXTURE2); //绑定v对应的纹理 glBindTexture(GL_TEXTURE_2D, texts[2]); //替换纹理，比重新使用glTexImage2D性能高 glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width / 2, height / 2, GL_LUMINANCE, GL_UNSIGNED_BYTE, buf[2]); glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); //8. 窗口显示，交换双缓冲区 eglSwapBuffers(display, winSurface);} 交换 EGL 的 Surface 的内部缓冲和 EGL 创建的和平台无关的窗口 diaplay 12//窗口显示，交换双缓冲区eglSwapBuffers(display, winSurface); 释放资源 1234567891011121314151617181920212223242526/** * 销毁数据 */void Gles_play::release() { if (display || winSurface || context) { //销毁显示设备 eglDestroySurface(display, winSurface); //销毁上下文 eglDestroyContext(display, context); //释放窗口 ANativeWindow_release(nativeWindow); //释放线程 eglReleaseThread(); //停止 eglTerminate(display); eglMakeCurrent(display, winSurface, EGL_NO_SURFACE, context); context = EGL_NO_CONTEXT; display = EGL_NO_SURFACE; winSurface = nullptr; winSurface = 0; nativeWindow = 0; isPlay = false; }} 到这里整个 OpenGL ES 渲染工作都完成了，代码已上传到 GitHub 仓库，需要的可以自行查看,注意: 测试的时候需要把 raw/*.yuv 放入 sdcard/ 根目录中。 OpenGL ES 使用可以参考该篇博客 总结本章的概念比较多，难免会枯燥一些，但是了解这些概念是必须的。下一篇将带来 FFmpeg + LibRtmp 播放器开发练习，支持 rtmp 拉流、本地视频播放(该篇文章和上一篇文章都分别讲解了音频视频基础和渲染就是为了播放器开发做准备)，可以先看一下效果(如下图)。是不是有那么一点小小的期待 😜 ，预计在 2 月下旬发布文章，在等一等。","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"},{"title":"音视频学习 (四) 交叉编译入门","text":"[TOC] 前言该篇文章主要介绍 Android 端利用 NDK 工具库来对 C/C++ 进行交叉编译，并通过 makefile 和 cmake 来构建 Android 项目。 编译器了解 c/c++ 编译器的基本使用，能够在后续移植第三方框架进行交叉编译时，清楚的了解应该传递什么参数。 1. clang clang 是一个C、C++、Object-C的轻量级编译器。基于LLVM（ LLVM是以C++编写而成的构架编译器的框架系统，可以说是一个用于开发编译器相关的库）,对比 gcc，它具有编译速度更快、编译产出更小等优点，但是某些软件在使用 clang 编译时候因为源码中内容的问题会出现错误。 2. gcc GNU C 编译器。原本只能处理 C 语言，但是它很快扩展，变得可处理 C++。( GNU目标是创建一套完全自由的操作系统)。 3. g++ GNU c++ 编译器，后缀为 .c 的源文件，gcc 把它当作是 C 程序，而 g++ 当作是 C++ 程序；后缀为 .cpp 的，两者都会认为是 c++ 程序，g++ 会自动链接 c++ 标准库 stl ，gcc 不会，gcc 不会定义 __cplusplus 宏，而 g++ 会。 编译原理一个 C/C++ 文件要经过预处理(preprocessing)、编译(compilation)、汇编(assembly)、和链接(linking)才能变成可执行文件。 我们先在 linux 系统上创建一个 test.c 文件，编写一个最简单的 c 程序，代码如下: 12345#include&lt;stdio.h&gt;int main(){ printf(\" 执行成功 ! \\n\");return 19921001;} 预处理阶段 预处理阶段主要处理 include 和 define 等。它把 #include 包含进来的 .h 文件插入到 #include 所在的位置，把源程序中使用到的用 #define 定义的宏用实际的字符串代替。 我们可以通过以下命令来对 c/c++ 文件预处理，命令如下: 1gcc -E test.c -o test.i //-E 的作用是让 gcc 在预处理结束后停止编译 可以看到输入该命令之后就会生成一个 test.i 文件。 编译阶段 在这个阶段中，gcc 首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作。 我们可以通过如下命令来处理 test.i 文件，编译成汇编文件，命令如下: 1gcc -S test.i -o test.s//-S 的作用是编译结束生成汇编文件。 汇编阶段 汇编阶段把 .S 文件翻译成二进制机器指令文件 .o ，这个阶段接收.c ,.i ,.s 的文件都没有问题。 下面我们通过以下命令生成二进制机器指令文件 .o 文件: 1gcc -c test.s -o test.o 链接阶段 链接阶段，链接的是函数库。可以通过以下命令实现: 12gcc -C test.o -o test ./test 最后我们通过实际操作，对编译有了一定的了解，当然你也可以直接通过如下命令一步到位: 1gcc test.c -o test 到这里我们成功的在 linux 平台生成了可执行文件，试想一下我们可以将这个可执行文件拷贝到安卓手机上执行吗？我们也不猜想了，实际测试下就行，我们把 test 可执行文件 push 到手机 /data/local/tmp 里面, 如下所示: 可以看到 test 在手机 /data/local/tmp 的路径下是有可读可写可执行的权限，但是最后执行不成功，这是为什么呢? 其实 主要原因是两个平台的 CPU 指令集不一样，根本就无法识别指令。那么怎么解决这个问题呢? 下面就要用到今天一个比较重要的知识点了， 利用 Android NDK 工具包来对 C/C++ 代码进行交叉编译 。 交叉编译简单地来说，交叉编译就是程序的编译环境和实际运行环境不一致，即在一个平台上生成另一个平台上的可执行代码。 在音视频开发中了解交叉编译是很有必要的，因为无论在哪一种移动平台下开发，第三方库都是需要进行交叉编译的。下面我们就以之前的例子来讲解如何在 linux 环境下交叉编译出移动平台上的可执行代码。 了解 NDKAndroid 原生开发包 (NDK) 可用于 Android 平台上的 C++ 开发，NDK 不仅仅是一个单一功能的工具，还是一个包含了 API 、交叉编译器、调试器、构建工具等得综合工具集。 下面大致列举了一下经常会用到的组件。 ARM 交叉编译器 构建工具 Java 原生接口头文件 C 库 Math 库 最小的 C++ 库 ZLib 压缩库 POSIX 线程 Android 日志库 Android 原生应用 API OpenGL ES 库 OpenSL ES 库 下面来看一下 Android 所提供的 NDK 跟目录下的结构。 ndk-build: 该 Shell 脚本是 Android NDK 构建系统的起始点，一般在项目中仅仅执行这一个命令就可以编译出对应的动态链接库了。 ndk-gdb: 该 Shell 脚本允许用 GUN 调试器调试 Native 代码，并且可以配置到 AS 中，可以做到像调试 Java 代码一样调试 Native 代码。 ndk-stack: 该 Shell 脚本可以帮组分析 Native 代码崩溃时的堆栈信息。 build: 该目录包含 NDK 构建系统的所有模块。 platforms: 该目录包含支持不同 Android 目标版本的头文件和库文件， NDK 构建系统会根据具体的配置来引用指定平台下的头文件和库文件。 toolchains: 该目录包含目前 NDK 所支持的不同平台下的交叉编译器 - ARM 、X86、MIPS ，目前比较常用的是 ARM 。构建系统会根据具体的配置选择不同的交叉编译器。 下面我们就来为交叉编译的环境变量配置 环境变量配置 ndk 在 Linux 上的环境变量配置: 12345678910//1. vim /etc/profile#NDK环境变量export NDK_HOME=/root/android/ndk/android-ndk-r17cexport PATH=$PATH:$NDK_HOME//2. 保存source /etc/profile//3. 测试ndk-build -v 如果出现如下字样，就证明配置成功了。 交叉编译在 Linux 上的环境变量配置(做一个参考，采坑之后的环境配置): 1234567891011121314export NDK_GCC_x86=\"/root/android/ndk/android-ndk-r17c/toolchains/x86-4.9/prebuilt/linux-x86_64/bin/i686-linux-android-gcc\"export NDK_GCC_x64=\"/root/android/ndk/android-ndk-r17c/toolchains/x86_64-4.9/prebuilt/linux-x86_64/bin/x86_64-linux-android-gcc\"export NDK_GCC_arm=\"/root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc\"export NDK_GCC_arm_64=\"/root/android/ndk/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-gcc\"export NDK_CFIG_x86=\"--sysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-x86 -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/i686-linux-android\"export NDK_CFIG_x64=\"--sysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-x86_64 -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/x86_64-linux-android\"export NDK_CFIG_arm=\"--sysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-arm -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/arm-linux-androideabi\"export NDK_CFIG_arm_64=\"--isysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-arm64 -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/aarch64-linux-android\"export NDK_AR_x86=\"/root/android/ndk/android-ndk-r17c/toolchains/x86-4.9/prebuilt/linux-x86_64/bin/i686-linux-android-ar\"export NDK_AR_x64=\"/root/android/ndk/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-ar\"export NDK_AR_arm=\"/root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-ar\"export NDK_AR_arm_64=\"/root/android/ndk/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-ar\" 你可以根据自己的 ndk 路径对应我的环境变量来进行配置。下面我们就用 ndk gcc 来对 test.c 进行交叉编译，步骤如下: 首先找到 /root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc 执行如下命令: 1/root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc -o test test.c 这种错误是说在我们编得时候编译器找不到我们引入的 stdio.h 头文件，那怎么告诉编译器 stdio.h 头文件在哪里呢? 下面知识点说明怎么指定这些报错的头文件 ** 指定头文件代码 1/root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc --sysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-arm -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -pie -o test test.c 上面出现了几个命令符号，不了解了可以看一下如下解释: –sysroot=?: 使用 ？作为这一次编译的头文件与库文件的查找目录，查找下面的 usr/include 目录。 -isystem ?(主要中间有一个英文空格) : 使用头文件查找目录，覆盖 –sysroot, 查找 ?/usr/include 目录下面的头文件。 *-isystem ?(主要中间有一个英文空格): * 指定头文件的查找路径。 -I?: 头文件的查找目录，I 是大写。 这样编译之后还是会报一个 asm/types.h 文件找不到，我们还要继续修改一下路径，如下 1/root/android/ndk/android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc --sysroot=/root/android/ndk/android-ndk-r17c/platforms/android-21/arch-arm -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include -isystem /root/android/ndk/android-ndk-r17c/sysroot/usr/include/arm-linux-androideabi -pie -o test test.c 这样就能编译成一个 Android 平台可执行的文件了，这样看起来路径太多不易阅读，大家可以参考我提供的全局变量配置来进行设置，最后一行命令解决，如下: 1$NDK_GCC_arm $NDK_CFIG_arm -pie -o test test.c ![](https://devyk.oss-cn-qingdao.aliyuncs.com/blog/20200111191038.gif) 可以看到，我们使用 Android NDK 编译出来的可执行文件已经在 Linux 平台下不可执行了。下面我们将 test 文件导入到 手机 /data/local/tmp 目录。 将 NDK 交叉编译出来的 test 可执行文件，导入 Android 手机中并执行 test 文件。 根据上面的录屏，我们知道已经成功的在 Android 设备下执行了 NDK 交叉编译后的 test 文件了。 下面我们利用 NDK 工具交叉编译 test.c 输出静态动态库。 动态库 &amp; 静态库编译静态库 将 test.c 使用 NDK GCC 编译为 .o 文件 ,命令如下: 1$NDK_GCC_arm $NDK_CFIG_arm -fpic -c test.c -o test.o 如果出现如下文件，证明已经成功了。 使用 NDK arm-linux-androideabi-ar 工具将 test.o 文件生成 test.a 静态库，命令如下: 1$NDK_AR_arm r test.a test.o 之后我们把 test.a 文件导入到 AS 中，来对 .a 的使用。 编译动态库在编译动态库的时候我们需要指定 -fPIC -shared 额外参数给编译器，完整命令如下： 1$NDK_GCC_arm $NDK_CFIG_arm -fpic -shared test.c -o libTest.so 动态库与静态库的区别在平时工作中我们经常把一些常用的函数或者功能封装为一个个库供给别人使用，java开发我们可以封装为 ja r包提供给别人用，安卓平台后来可以打包成 aar 包，同样的，C/C++ 中我们封装的功能或者函数可以通过静态库或者动态库的方式提供给别人使用。 Linux 平台静态库以 .a 结尾，而动态库以 .so 结尾。 那静态库与动态库有什么区别呢？ 1. 静态库 与静态库连接时，静态库中所有被使用的函数的机器码在编译的时候都被拷贝到最终的可执行文件中，并且会被添加到和它连接的每个程序中： 优点：运行起来会快一些，不用查找其余文件的函数库了。 缺点：导致最终生成的可执行代码量相对变多,运行时, 都会被加载到内存中. 又多消耗了内存空间。 2. 动态库 与动态库连接的可执行文件只包含需要的函数的引用表，而不是所有的函数代码，只有在程序执行时, 那些需要的函数代码才被拷贝到内存中。 优点：生成可执行文件比较小, 节省磁盘空间，一份动态库驻留在内存中被多个程序使用，也同时节约了内存。 缺点：由于运行时要去链接库会花费一定的时间，执行速度相对会慢一些。 静态库是时间换空间，动态库是空间换时间，二者均有好坏。 如果我们要修改函数库，使用动态库的程序只需要将动态库重新编译就可以了，而使用静态库的程序则需要将静态库重新编译好后，将程序再重新编译一遍。 mk &amp; cmake上一小节我们通过 NDK 交叉编译了 test.c 为动态静态库，那么该小节我们就基于 makefile 和 cmake 来构建一个 C/C++ 的 Android 程序, 并使用 test .a /libTest.so mkAndroid.mk 是在 Android 平台上构建一个 C 或者 C ++ 语言编写的程序系统的 Makefile 文件，不同的是， Android 提供了一些列内置变量来提供更加方便的构建语法规则。Application.mk 文件实际上是对应用程序本身进行描述的文件，它描述了应用程序要针对哪些 CPU 架构打包动态 so 包、要构建的是 release 包还是 debug 包以及一些编译和链接参数等。 语法基础1. Android.mk LOCAL_PATH :=$(call my-dir) 返回当前文件在系统中路径，Android.mk 文件开始时必须定义该变量。 include $(CLEAR_VARS), 表明清楚上一次构建过程的所有全局变量，因为在一个 Makefile 编译脚本中，会使用大量的全局变量，使用这行脚本表明需要清除掉所有的全局变量。 LOCAL_SRC_FILES, 要编译的 C 或者 CPP 的文件，注意这里不需要列举头文件，构建系统会自动帮组开发者依赖这些文件。 LOCAL_LDLIBS:= -L$(SYSROOT)/usr/lib -Ilog -IOpenSLES -IGLESv2 -IEGL -Iz,定编译过程所依赖的 NDK 提供的动态静态库， SYSROOT 变量代表的是 NDK_ROOT 下面的目录 $NDK 提供的动态与静态库，SYSROOT 变量代表的是 NDK_ROOT 下面目录 $NDK_ROOT/platforms/android-21/arch-arm, 而在这个目录的 usr/lib/ 目录下有很多对应的 so 的动态库以及 .a 的静态库。 LOCAL_CFLAGS , 编译 C 或者 CPP 的编译标志，在实际编译的时候会发送给编译器。比如常用的实例是加上 -DAUTO_TEST , 然后在代码中就可以利用条件判断 #ifdef AUTO_TEST 来做一些与自动化测试相关的事情。 LOCAL_LDFLAGS, 链接标志的可选列表，当对目标文件进行链接以生成输出文件的时候，将这些标志带给链接器。该指令与 LOCAL_LDLIBS 有些类似，一般情况下，该选项会用于指定第三方编译的静态库，LOCAL_LDLIBS 经常用于指定系统的库(比如 log、OpenGLES、EGL 等)。 LOCAL_MODULE, 该模块的编译的目标名，用于区分各个模块，名字必须是唯一并不包含空格的，如果编译目标是 so 库，那么该 so 库的名称就是 lib 项目名 .so。 include $(BUILD_SHARED_LIBRARY) ，其实类似的 include 还有很多，都是构建系统提供的内置变量，该变量的意义是构建动态库，其他的内置变量还包括如下几种。 —BUILD_STATIC_LIBRARY: 构建静态库 —PREBUILT_STATIC_LIBRARY: 对已有的静态库进行包装，使其成为一个模块。 —PREBUILT_SHARED_LIBRARY: 对已有的静态库进行包装，使其成为一个模块。 —BUILD_EXECUTABLE: 构建可执行文件。 2. Application.mk APP_ABI := XXX ,这里的 XXX 是指不同平台，可以选填的有 x86 、mips 、armeabi、armeabi-v7a、all 等，值得一提的是，若选择 all 则会构建构建出所有平台的 so ,如果不填写该项，那么将默认构建为 armeabi 平台下的库。 APP_STL := gnustl_static ,NDK 构建系统提供了由 Android 系统给出的最小 C++ 运行时库 （、system/lib/libstdc++.so）的 C++ 头文件。 APP_CPPFLAGS :=-std=gnu++11 -fexceptions, 指定编译过程的 flag ,可以在该选项中开启 exception rtti 等特性，但是为了效率考虑，最好关闭 rtti。 NDK_TOOLCHAIN_VERSION = 4.8，指定交叉工具编译链里面的版本号，这里指定使用 4.8。 APP_PLATFORM :=android-9,指定创建的动态库的平台 APP_OPTIM := release,该变量是可选的，用来定义 “release” 或者 “debug” ,”release” 模式是默认的，并且会生成高度优化的二进制代码；“debug” 模式生成的是未优化的二进制代码，但是可以检测出很多的 BUG, 经常用于调试阶段，也相当于在 ndk-build 指令后边直接加上参数 NDK_DEBUG=1。 构建 C/C++ Android 项目项目源代码 效果: Makefile 的方式我们只做一个了解，因为以后我们构建 C/C++ 的 Android 项目都是用 cmake 方式来构建，所以我们重点掌握 cmake 就行。 cmake之前做 NDK 开发或者老的项目都是基于 Android.mk、Application.mk 来构建项目的，但从 AS 2.2 之后便开始采用 CMake 的方式来构建 C/C++ 项目，采用 CMake 相比与之前的 Android.mk、Application.mk 方便简单了许多。下面我们简单的来介绍下 cmake 基础语法吧。 语法基础1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#1. 指定 cmake 的最小版本cmake_minimum_required(VERSION 3.4.1)#2. 设置项目名称project(demo)#3. 设置编译类型add_executable(demo test.cpp) # 生成可执行文件add_library(common STATIC test.cpp) # 生成静态库add_library(common SHARED test.cpp) # 生成动态库或共享库#4. 明确指定包含哪些源文件add_library(demo test.cpp test1.cpp test2.cpp)#5. 自定义搜索规则并加载文件file(GLOB SRC_LIST \"*.cpp\" \"protocol/*.cpp\")add_library(demo ${SRC_LIST}) //加载当前目录下所有的 cpp 文件## 或者file(GLOB SRC_LIST \"*.cpp\")file(GLOB SRC_PROTOCOL_LIST \"protocol/*.cpp\")add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})## 或者aux_source_directory(. SRC_LIST)//搜索当前目录下的所有.cpp文件aux_source_directory(protocol SRC_PROTOCOL_LIST) add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})#6. 查找指定库文件find_library( log-lib //为 log 定义一个变量名称 log ) //ndk 下的 log 库#7. 设置包含的目录include_directories( ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/include)#8. 设置链接库搜索目录link_directories( ${CMAKE_CURRENT_SOURCE_DIR}/libs)#9. 设置 target 需要链接的库target_link_libraries( # 目标库 demo # 目标库需要链接的库 # log-lib 是上面 find_library 指定的变量名 ${log-lib} ) #10. 指定链接动态库或者静态库target_link_libraries(demo libtest.a) # 链接libtest.atarget_link_libraries(demo libtest.so) # 链接libtest.so#11. 根据全路径链接动态静态库target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libtest.a)target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libtest.so)#12. 指定链接多个库target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libtest.a test.a boost_thread pthread) 常用变量 预定义变量 说明 PROJECT_SOURCE_DIR 工程的根目录 PROJECT_BINARY_DIR 运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build PROJECT_NAME 返回通过 project 命令定义的项目名称 CMAKE_CURRENT_SOURCE_DIR 当前处理的 CMakeLists.txt 所在的路径 CMAKE_CURRENT_BINARY_DIR target 编译目录 CMAKE_CURRENT_LIST_DIR CMakeLists.txt 的完整路径 CMAKE_CURRENT_LIST_LINE 当前所在的行 CMAKE_MODULE_PATH 定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块 EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置 LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置 构建 C/C++ Android 项目 以静态库构建项目 定义 native 接口 123456789101112131415161718public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); testCmake(); } /** * 测试 cmake 构建程序 */ public native static void testCmake();} 编写 cpp 123456789101112131415// extern int main(); 这样写有坑，因为 main 方法是属于 c 的，而当前是 CPPextern \"C\" { //必须这样定义 int main();}extern \"C\" JNIEXPORT void JNICALLJava_com_devyk_cmake_1application_MainActivity_testCmake( JNIEnv *env, jobject /* this */) { std::string hello = \"Hello from C++\"; __android_log_print(ANDROID_LOG_DEBUG, \"DevYK\", \"main---&gt;:%d\", main());} 编写 CmakeLists.txt 文件 1234567891011121314151617181920212223242526272829303132333435cmake_minimum_required(VERSION 3.4.1)# 打印日志message(\"当前CMake的路径是：${CMAKE_SOURCE_DIR}\")message(\"当前 CMAKE_ANDROID_ARCH_ABI 的路径是：${CMAKE_ANDROID_ARCH_ABI}\")# 批量引入源文件file(GLOB allCpp *.cpp)# 加入cpp源文件add_library( native-lib SHARED # native-lib.cpp 替换 ${allCpp} 批量导入文件 ${allCpp})# 导入静态库add_library(test_a STATIC IMPORTED)# 开始真正的导入set_target_properties(test_a PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/libtest.a)# 只能找系统的find_library( log-lib log) message(\"当前的log路径在哪里啊 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ${log-lib}\")#开始链接指定的库target_link_libraries( native-lib ${log-lib} test_a) app/build.gradle cmake 配置 123456789101112131415161718192021222324252627282930android {... defaultConfig {... externalNativeBuild { cmake { // cppFlags \"\" // 默认包含四大平台 abiFilters 'armeabi-v7a'//编译armeabi-v7a平台 } } ndk { //过滤，只使用这个版本的库,否则默认的可是4个平台 abiFilters 'armeabi-v7a' } }... externalNativeBuild { cmake { path \"src/main/cpp/CMakeLists.txt\" //指定 CMakeLists 路径 } }} 测试结果 以动态库构建项目 代码加载 so 库到手机中 1234static { System.loadLibrary(\"Test\"); System.loadLibrary(\"native-lib\");} so 库导入在 main/jniLibs 下 CmakeLists.txt 配置 1234567891011121314151617181920212223242526272829303132333435363738394041cmake_minimum_required(VERSION 3.4.1)# 打印日志message(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&gt;&gt;&gt;\")message(\"当前CMake的路径是：${CMAKE_SOURCE_DIR}\")message(\"当前 CMAKE_ANDROID_ARCH_ABI 的路径是：${CMAKE_ANDROID_ARCH_ABI}\")# 批量引入源文件file(GLOB allCpp *.cpp)# 加入cpp源文件add_library( native-lib SHARED # native-lib.cpp ${allCpp})# 导入静态库#add_library(test_a STATIC IMPORTED)# 开始真正的导入#set_target_properties(test_a PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/libtest.a)# 导入动态库add_library(test_so SHARED IMPORTED)# 早起的cmake ANDROID_ABI == 当前CPU平台set_target_properties(test_so PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../jniLibs/${CMAKE_ANDROID_ARCH_ABI}/libTest.so)# 只能找系统的find_library( log-lib log)message(\"当前的log路径在哪里啊 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ${log-lib}\")# CMAKE_SOURCE_DIR == D:\\NDK\\CoursewareCreate\\ndk_12\\project\\ndk12_cmake\\app\\src\\main\\cpp\\CMakeLists.txttarget_link_libraries( native-lib ${log-lib} test_so) 测试 到这里，mk 和 cmake 入门基础知识就讲完了，想要全部掌握还需要自己多动手实践一翻。 总结该篇文章主要讲解了如何利用 NDK 对 C 程序进行交叉编译，以及交叉编译后的动态静态库在 Android 项目中的使用，还有 makefile 和 cmake 在 Android 的使用，本篇文章也是比较基础的，对于后续使用或者编译 FFmpeg 打下基础。 文章中所有代码已上传 GitHub 仓库","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%85%A5%E9%97%A8/"},{"title":"音视频学习 (十二) FFmpeg + OpenSL ES 实现音频播放器","text":"前言 唠叨一句: 说实话现在搞 Android 开发的要求是越来越高，初级都要被淘汰的感觉。所以想要一直往 Android 的道路上走，深入 音视频领域 是一个不错的选择。虽然现在跨平台 Flutter 很火，但终究它还是一个写 UI 的(个人看法)。程序员随着年龄的增长不可能一直写 UI 。但是深入 C/C++ 就不一样了。它可以给移动端甚至 Flutter 提供底层 SDK 和技术支持这难道不香吗？所以想要或者准备学习音视频知识的，那么该篇文章可以助你快速入门。 五一假期即将结束，不知道大家玩的怎么样，我了也趁着这个假期抽出了一天时间去爬了长城，有句话不是说，不到长城非好汉嘛。何况来北京好些年了一直没机会去。之后利用剩下的这 4 天写了一个音频处理库，目前包含如下功能: 功能 是否完成 读取任意格式音频流 Yes FFmpeg 音频解码为 PCM Yes 音频 Native OpenSL ES 渲染 Yes 音量控制 Yes seek 控制 Yes 声道切换 Yes 变调变速 Yes 变声 No 裁剪音频输出 MP3/PCM 等格式 pcm-ok 边播边录制 No 音频编码为 AAC、MP3、WAV No 其实音频处理的库在 GitHub 搜都是一大堆，那为什么我自己还要写一个呢？原因是我不想当伸手党，如果每次都这样，那自己的技术何来进步，是吧？而且自己写的库也便于自己修改和增加一些特殊的功能。下面我就大概来说一下具体每个功能是如何实现及做一个音频处理的库需要搭建怎样的一个架构。当然我也不是一时兴起就来写一个音频处理库。 还是有一个小目标的: 打造一个万能音频播放器。不管是直播源还是网络/本地源，只要给我一个路径我就能播放。 增加一些特殊的处理比如，变调变速、变声、裁剪… 一切皆有可能。 可以看下效果图: 介绍编码环境 FFmpeg : 4.2.2 NDK: 17c OS: MAC 实现流程: 粗略架构组成: kotlin: Kotlin 语言是由 JetBrains 公司开发，2010 面世，2017 年正式在谷歌 I/O 大会上推荐 Kotlin 作为 Android 开发语言。 FFmpeg: FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。 SoundTouch: 可以在 PCM 音频裸流基础上对音频变调变速 OpenSLES: OpenSL ES（嵌入式系统的开放声音库）是一种免版税，跨平台，硬件加速的 C语言 音频API，用于2D和3D音频。它提供对3D位置音频和MIDI播放等功能的访问。它是为移动和游戏行业的开发人员设计的，致力于使跨多个平台的应用程序轻松移植。 FFmpeg 初始化编译 FFmpeg 可以参考我之前写的文章音视频学习 (六) 一键编译 32/64 位 FFmpeg 4.2.2 这里我们就按照 FFmpeg 初始化流程来进行介绍 API 如下所示: 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1. 分配一个 AVFormatContext。AVFormatContext *avformat_alloc_context(void);//对应的释放void avformat_free_context(AVFormatContext *s);//2. 打开输入流，读取头部信息，一般包含有音频，视频流信息也可能有弹幕信息int avformat_open_input(AVFormatContext **ps, const char *url, ff_const59 AVInputFormat *fmt, AVDictionary **options);//对应的关闭流信息，释放所有内容资源void avformat_close_input(AVFormatContext **s); //3. 读取媒体文件的数据包以获取流信息。返回 &gt;=0 则成功int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);//3.1 拿到当前流的数量信息，一般会有音频，视频，或者弹幕int number = (*AVFormatContext)-&gt;nb_streams//3.2 遍历拿到对应的 stream//视频流if ((*pFormatCtx)-&gt;streams &amp;&amp; (*pFormatCtx)-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)//语音流 if ((*pFormatCtx)-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO)//其它流类型enum AVMediaType { AVMEDIA_TYPE_UNKNOWN = -1, ///&lt; Usually treated as AVMEDIA_TYPE_DATA AVMEDIA_TYPE_VIDEO, AVMEDIA_TYPE_AUDIO, AVMEDIA_TYPE_DATA, ///&lt; Opaque data information usually continuous AVMEDIA_TYPE_SUBTITLE, AVMEDIA_TYPE_ATTACHMENT, ///&lt; Opaque data information usually sparse AVMEDIA_TYPE_NB};//4. 根据 AVCodecID 拿到已经注册的解码器AVCodec *avcodec_find_decoder(enum AVCodecID id);//5. 分配一个 AVCodecContext AVCodecContext *avcodec_alloc_context3(const AVCodec *codec);//对应的释放void avcodec_free_context(AVCodecContext **avctx);//6. 给解码器设置参数int avcodec_parameters_to_context(AVCodecContext *codec, const AVCodecParameters *par);//7. 打开解码器 is 0 successint avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options); 以上 7 步如果没有问题证明编解码器打开成功，可以进行下一步操作。 FFmpeg 读取音频帧这里还是介绍 API 使用: 1234567//1. 分配一个 AVPacket AVPacket *av_packet_alloc(void);//结果必须释放void av_packet_free(AVPacket **pkt);//2. 读取待解码数据包int av_read_frame(AVFormatContext *s, AVPacket *pkt); 对，就是这么简单，就调用 3 个 API 然后循环读取，送入待解码队列中。 FFmpeg 解码音频为 PCM这里相当于是读取待解码队列中的数据，进行解码为 PCM 数据 1234567891011121314151617181920212223//1. 将待解码数据 AVPacket 送入解码器 0 is okint avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt);//2. 分配一个 AVFrame 用于接收解码之后的数据AVFrame *av_frame_alloc(void);//对应的释放 APIvoid av_frame_free(AVFrame **frame);//3. 接收解码之后的数据 0 is okint avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame);//对解码之后的 PCM 进行统一重采样。规定一些格式，避免不统一而渲染异常//4. 根据传入的参数来分配一个 SwrContextstruct SwrContext *swr_alloc_set_opts(struct SwrContext *s, int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate, int64_t in_ch_layout, enum AVSampleFormat in_sample_fmt, int in_sample_rate, int log_offset, void *log_ctx);//4.1 对 SwrContext 进行初始化int swr_init(struct SwrContext *s);//4.2 开始重采样int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in , int in_count); OpenSLES 渲染 PCM这里还是以流程的形式介绍 API 含义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//1. 创建播放引擎result = slCreateEngine(&amp;engineObject, 0, NULL, 0, NULL, NULL);result = (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE);result = (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineEngine);//2. 创建混音器const SLInterfaceID mids[1] = {SL_IID_ENVIRONMENTALREVERB};const SLboolean mreq[1] = {SL_BOOLEAN_FALSE};result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE);result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB, &amp;outputMixEnvironmentalReverb); if (SL_RESULT_SUCCESS == result) { result = (*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties( outputMixEnvironmentalReverb, &amp;reverbSettings); (void) result; }SLDataLocator_OutputMix outputMix = {SL_DATALOCATOR_OUTPUTMIX, outputMixObject};SLDataSink audioSnk = {&amp;outputMix, 0};//3. 配置PCM格式信息SLDataLocator_AndroidSimpleBufferQueue android_queue = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 2}; SLDataFormat_PCM pcm = { SL_DATAFORMAT_PCM,//播放pcm格式的数据 2,//2个声道（立体声） static_cast&lt;SLuint32&gt;(getCurSampleRate(sample_rate)),//44100hz的频率 SL_PCMSAMPLEFORMAT_FIXED_16,//位数 16位 SL_PCMSAMPLEFORMAT_FIXED_16,//和位数一致就行 SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT,//立体声（前左前右） SL_BYTEORDER_LITTLEENDIAN//结束标志 }; SLDataSource slDataSource = {&amp;android_queue, &amp;pcm}; const SLInterfaceID ids[3] = {SL_IID_BUFFERQUEUE, SL_IID_VOLUME, SL_IID_MUTESOLO}; const SLboolean req[3] = {SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE}; result = (*engineEngine)-&gt;CreateAudioPlayer(engineEngine, &amp;pcmPlayerObject, &amp;slDataSource, &amp;audioSnk, sizeof(ids) / sizeof(ids[0]), ids, req);//4. 初始化播放器result = (*pcmPlayerObject)-&gt;Realize(pcmPlayerObject, SL_BOOLEAN_FALSE);result = (*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_PLAY, &amp;pcmPlayerPlay);//5. 注册回调缓冲区 获取缓冲队列接口(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_BUFFERQUEUE, &amp;pcmBufferQueue);(*pcmBufferQueue)-&gt;RegisterCallback(pcmBufferQueue, pcmBufferCallBack, this);//6. 设置播放状态(*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PLAYING);//7. 手动激活回调接口pcmBufferCallBack(pcmBufferQueue, this); 初始化就是这 7 大步，那么渲染的话，就是在 pcmBufferCallBack 中进行设置，直接上代码吧: 123456789101112131415161718void pcmBufferCallBack(SLAndroidSimpleBufferQueueItf bf, void *pVoid) { auto audioPlayer = static_cast&lt;BaseAudioChannel *&gt;(pVoid); if (!audioPlayer) return; if (audioPlayer-&gt;status &amp;&amp; audioPlayer-&gt;status-&gt;exit) LOGE(\"looper pcmBufferCallBack start\"); //拿到 PCM 原始数据 int size = audioPlayer-&gt;getPCMData(); //对 PCM 做变速变调操作。 size = audioPlayer-&gt;setSoundTouchData();... //8. 放入缓存，开始播放声音 (*audioPlayer-&gt;pcmBufferQueue)-&gt;Enqueue(audioPlayer-&gt;pcmBufferQueue, audioPlayer-&gt;out_pcm_buffer, size);...} 对，没错。第八步就是真正将 PCM 放入 OpenSL ES 缓冲队列中，这里要注意，一点要等它的上一帧渲染完在放入下一帧 PCM 数据。 功能点实现:声道选择声道操作直接操作的是 OpenSLES 接口，具体 API 如下: 12345678910111213141516171819202122232425//1. 得到音频声道通道接口(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_MUTESOLO, &amp;pcmChannelModePlay);//2. 设置音频通道/** * 设置音频通道 * @param channelMode */void BaseAudioChannel::setChannelMode(int channelMode) { this-&gt;mChannelMode = channelMode; if (pcmChannelModePlay != NULL) { if (channelMode == 0)//右声道 { (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, 1, false); (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, 0, true); } else if (channelMode == 1)//左声道 { (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, 1, true); (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, 0, false); } else if (channelMode == 2)//立体声 通道为 2 也就是我们重采样设置的 AV_CH_LAYOUT_STEREO { (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, 1, false); (*pcmChannelModePlay)-&gt;SetChannelMute(pcmChannelModePlay, 0, false); } }} 音量控制声音音量控制这里还是基于的是 OpenSLES 接口，对应 API 如下: 12345678910111213141516171819202122232425262728293031//1. 拿到音频声音控制接口(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_VOLUME, &amp;pcmVolumePlay);//2. 设置声音/** * 平滑设置当前音量 * @param volume */void BaseAudioChannel::setVolume(int percent) { this-&gt;curVolume = percent; if (pcmVolumePlay != NULL) { if (percent &gt; 30) { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -20); } else if (percent &gt; 25) { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -22); } else if (percent &gt; 20) { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -25); } else if (percent &gt; 15) { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -28); } else if (percent &gt; 10) { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -30); } else if (percent &gt; 5) { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -34); } else if (percent &gt; 3) { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -37); } else if (percent &gt; 0) { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -40); } else { (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -100); } }} 语调语速设置语调语速功能这里用的开源的 SoundTouch ，具体实现如下: 123456789101112131415161718192021222324int BaseAudioChannel::setSoundTouchData() { int num = 0; while (status &amp;&amp; !status-&gt;exit) { if (finished) { finished = false; if (this-&gt;mBufSize &gt; 0 &amp;&amp; this-&gt;out_pcm_buffer) { pthread_mutex_lock(&amp;mutexSpeed); soundTouch-&gt;putSamples(reinterpret_cast&lt;const SAMPLETYPE *&gt;(this-&gt;out_pcm_buffer), this-&gt;oldSize); num = soundTouch-&gt;receiveSamples(reinterpret_cast&lt;SAMPLETYPE *&gt;(this-&gt;out_pcm_buffer), this-&gt;mBufSize / 4); pthread_mutex_unlock(&amp;mutexSpeed); } else { soundTouch-&gt;flush(); } } if (num == 0) { finished = true; continue; } return num * 2 * 2; } return 0;} seek 指定在某个时间段播放seek 功能直接调取的 FFmpeg API ，操作如下: 12345678910void BaseDecodec::seek(int number) { if (duration &lt;= 0) { return; } if (number &gt;= 0 &amp;&amp; number &lt;= number) { int64_t rel = number * AV_TIME_BASE; avcodec_flush_buffers(this-&gt;avCodecContext); avformat_seek_file(this-&gt;avFormatContext, -1, INT64_MIN, rel, INT64_MAX, 0); }} 截取 PCM截取 PCM 原理其实很简单，比如一段音频的总长为 500s ，我想要截取 300 - 400s 部分，那么我首先 seek(300)作为起点，如果解码帧的时间到了 500 那么就直接退出就 OK 了，是不是很简单。 这里我说下怎么获取时间: 1234567891011//这是基本的时间单位（以秒为单位）表示其中的帧时间戳。this-&gt;time_base = (*pFormatCtx)-&gt;streams[i]-&gt;time_base;//1. 初始化 FFmpeg 读取流 header 信息可以获取int audioDuration = (*pFormatCtx)-&gt;streams[i]-&gt;duration / AV_TIME_BASE;//2. 读取待解码 AVPacket 包获取时间int readCurAudioTime = avPacket-&gt;pts * av_q2d(time_base);//3. 解码获取时间int decodeAudioCurTime = avFrame-&gt;pts * av_q2d(time_base); 总结到这里我们的音频处理库就讲解完了，对于音视频感兴趣的可以作为学习资料，因为我本人不喜欢弄 UI ，不然我可以仿照一个 网易云音乐的 UI + 我自己的音频处理库来做一个音频 APP 。当然你可以这样来搞。 文章中所有的代码已上传 GitHub 关于我 Email: yang1001yk@gmail.com 个人博客: https://www.devyk.top GitHub: https://github.com/yangkun19921001 掘金博客: https://juejin.im/user/578259398ac2470061f3a3fb/posts 扫码关注我的公众号，让我们离得更近一些!","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%8D%81%E4%BA%8C-FFmpeg-OpenSL-ES-%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"},{"title":"音视频学习 (一) C 语言入门","text":"前言现在 Android 初中级开发工程师想找一份满意的工作是越来越难了，当然有实力的是不愁好工作的。如果正巧你是初中级工程师想要进阶音视频方向或者对 NDK 技术感兴趣的，那么关注我准没错。在 5G 时代的到来，我相信音视频方向的工程师会越来越吃香。那么想要学习音视频技术首先就得具备 C/C++ 语言基础，下面我们就先来学习 C 语言基础。 ps: 音视频方向计划写一个系列文章 (初步计划以 C/C++ 语言基础、JNI 、MakeFile/Cmake 、利用 FFmpeg 开发音视频播放器 、RTMP 直播、OpenCV 人脸/车牌识别、OpenGL 视频处理、视频特效、WebRTC 音视频通话等技术文章)，该系列我也会持续更新 。C/C++ 基础文章本来我是不打算写的，看过我的文章都知道我写的几乎是系列文章，如果缺胳膊少腿的看起来也不那么清晰流程，所以 C/C++ 基础我就参考网上的来写了，因为基础这个东西，网上好的入门资料太多了，该篇就当复习参考了。有这方面基础的可以直接翻篇了😂。 就不说那么多废话了，下面我们就一起来学习音视频方向的技术，让我们一起沉浸在学习中无法自拔😁。 C 简介C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。 在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。 UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。 易于学习。 结构化语言。 它产生高效率的程序。 它可以处理底层的活动。 它可以在多种计算机平台上编译。 环境设置这是只说明在 MAC 上怎么使用 C 语言来进行开发，环境的话需要用到 GCC 进行编译，你可以下载并安装 Xcode 工具，一旦安装上 Xcode，您就能使用 GNU 编译器。开发工具你可以使用 Xcode 或者 CLion 都可以，看个人喜好。我这里用的是 CLion 工具，你可以发现 CLion 页面跟使用风格包括快捷键都跟 AndroidStudio 一样。上手极其容易。 C 语言入门不知道大家在学习一门新的开发语言敲的第一行代码是什么？应该百分之 90 % 以上都是打印 ”HelloWorld“ 吧，我们就以打印 ”HelloWorld“ 为例来正式进入 C 语言的学习吧。 1. 程序结构我们先来看一下最简单的一个 C 程序，先来打印一个 “HelloWorld”。代码如下: 123456789#include &lt;stdio.h&gt;/** * C 语言入口程序 * @return */int main() {//主函数，程序从这里开始执行 printf(\"C 语言入门第一行代码 Hello World! \\n\"); return 0;} 可以看到 C 语言的入口函数跟 Java 的类似吧，都是以 main 来定义的入口，接下来我们讲解一下上面这段程序的意思： 程序的第一行 #include &lt;stdio.h&gt; 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。 下一行 /…/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 printf(…) 是 C 中另一个可用的函数，会在屏幕上显示消息 “C 语言入门第一行代码 Hello World!”。 下一行 return 0; 终止 main() 函数，并返回值 0。 当然你可以通过命令来执行,如下所示: 121. 使用 gcc xxx.c2. ./a.out 直接使用上面 2 个步骤就可以进行执行 C 代码了。 2. 基本语法上一小节我们知道了一个简单的小应用由哪些部分组成，这将有助于我们理解 C 语言的其它基本的构建块。 c 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字串符值、或者是一个符号。 下面我们来看一下 C 中的关键字，这些关键字不能作为常量名，变量名或者其它标识符名称（跟 Java 类似）。 关键字 说明 auto 声明自动变量 break 跳出当前循环 case 开关语句分支 char 声明字符型变量或者函数返回值类型 const 声明只具可读变量 continue 结束当前循环，开始下一个循环 default 开关语句中的其它分支 do 循环语句的循环体 double 声明双进度浮点型变量或者函数返回值类型 else 条件语句否定分支 enum 声明枚举类型 extern 声明变量或函数是在其它文件或本文件的其他位置定义 float 声明浮点型变量或者函数返回值类型 for 一种循环语句 goto 无条件跳转语句 if 条件语句 int 声明整型变量或函数 long 声明长整型变量或函数返回值类型 register 声明寄存器变量 return 子程序返回语句 short 声明短整型变量或者函数 signed 声明有符号类型变量或者函数 sizeof 计算数据类型或者变量长度（即所占字节数） static 声明静态变量 struct 声明结构体类型 switch 用于开关语句 typedef 用以给数据类型取别名 unsigned 声明无符号类型变量或函数 union 声明共用体类型 void 声明函数无返回值或无参树，声明无类型指针 volatile 说明变量在程序执行中可被隐含地改变 while 循环语句的循环条件 3. 数据类型在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。 C 中的类型可分为以下几种： 类型 说明 基本类型 它们是算术类型，包括两种类型：整数类型和浮点类型。 枚举类型 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值得变量。 void 类型 类型说明符 void 表名没有可用的值 派生类型 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。 整数类型 下表列出了关于标准整数类型的存储大小和值范围的细节 类型 32 位 64 位 值范围 char 1 1 -128 到 127 或 0 到 255 unsigned char 1 1 0 到 255 int 4 4 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 4 4 0 到 65,535 或 0 到 4,294,967,295 short 2 2 -32,768 到 32,767 unsigned short 2 2 0 到 65,535 long 4 8 -2,147,483,648 到 2,147,483,647 unsigned long 4 8 0 到 4,294,967,295 注意: 各种类型的存储大小与系统位数有关，但目前通用的以 64 为系统为主。 浮点类型 类型 比特（位）数 有效数字 取值范围 float 4 6~7 1.2E-38 到 3.4E+38 double 8 15~16 2.3E-308 到 1.7E+308 long double 16 18~19 3.4E-4932 到 1.1E+4932 他们的字节，精度，取值范围都可以通过代码打印实现，如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void main() { /** * 整数类型 */ printf(\"\\n\\n 整数类型 \\n\"); //char 1 字节 printf(\"char 存储大小: %lu \\n\", sizeof(char)); printf(\"unsinged char 存储大小: %lu \\n\", sizeof(unsigned char)); //short 2 字节 printf(\"short 存储大小: %lu \\n\", sizeof(short)); printf(\"unsinged short 存储大小: %lu \\n\", sizeof(unsigned short)); //int 4 字节 printf(\"int 存储大小: %lu \\n\", sizeof(int)); printf(\"unsinged int 存储大小: %lu \\n\", sizeof(unsigned int)); //long 4/8 字节 printf(\"long 存储大小: %lu \\n\", sizeof(long)); printf(\"unsinged long 存储大小: %lu \\n\", sizeof(unsigned long)); /** * 浮点类型 */ printf(\"\\n\\n 浮点类型 \\n\"); //float 4 字节 ，精度 6 位小数 printf(\"float 存储最大字节数：%lu \\n\", sizeof(float)); printf(\"float 最小值：%e \\n\", FLT_MIN); printf(\"float 最大值：%e \\n\", FLT_MAX); printf(\"float 精度值：%d \\n\", FLT_DIG); //double 8 字节 printf(\"double 存储最大字节数：%d \\n\", sizeof(double)); printf(\"double 最小值：%e \\n\", DBL_MIN); printf(\"double 最大值：%e \\n\", DBL_MAX); printf(\"double 精度值：%d \\n\", DBL_DIG); //long double 16 字节 printf(\"long double 存储最大字节数：%lu byte \\n\", sizeof(long double)); printf(\"long double 最小值：%lg \\n\", LDBL_MIN); printf(\"long double 最大值：%lg \\n\", LDBL_MAX); printf(\"long double 精度值：%d \\n\", LDBL_DIG);} 可以通过 sizeof 关键字来获取数据类型占用内存的大小。上面代码可以看到了打印中出现了很多不识的 scanf() 格式控制符，我总结了一个表，可以参考下: 格式控制符 说明 %c 读取一个单一的字符 %hd、%d、%ld 读取一个十进制整数，并分别赋值给 short、int、long 类型 %ho、%o、%lo 读取一个八进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型 %hx、%x、%lx 读取一个十六进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型 %hu、%u、%lu 读取一个无符号整数，并分别赋值给 unsigned short、unsigned int、unsigned long 类型 %f、%lf 读取一个十进制形式的小数，并分别赋值给 float、double 类型 %e、%le 读取一个指数形式的小数，并分别赋值给 float、double 类型 %g、%lg 既可以读取一个十进制形式的小数，也可以读取一个指数形式的小数，并分别赋值给 float、double 类型 %s 读取一个字符串（以空白符为结束） 4. 变量变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 对大小写敏感的。 C 中的变量定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： 1type list; 在这里，type 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的对象，list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明： 1234int a,b,c;char c1,c2,c3;float f,f1,f2;double d1,d2,d3; 这里其实跟 Java 声明变量差不多，就不再单独解释了。 c 中变量声明 变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 变量的声明有两种情况： 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。 2、另一种是不需要建立存储空间的，通过使用 extern 关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。 除非有 extern 关键字，否则都是变量的定义。 12extern int i;//声明，不是定义int a;//声明，也是定义 例子 1234567891011121314151617181920#include &lt;stdio.h&gt;//函数外定义变量 //如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可int x;int y;int sum() { //函数内声明变量 X , Y 为外部变量 x = 10; y = 15; return x + y;}//入口函数void main() { //打印变量相加 int result; result = sum(); printf(\"x + y = %d\",result);} 输出: 1x + y = 25 5. 常量常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 在 Java 中声明一个常量往往是在数据类型中定义 final 关键字就行了，但是 c 中没有 final 关键字，我们来看看怎么定义，如下所示: 整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 12345212 /* 合法的 */215u /* 合法的 */0xFeeL /* 合法的 */078 /* 非法的：8 不是八进制的数字 */032UU /* 非法的：不能重复后缀 */ 浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 123453.14159 /* 合法的 */314159E-5L /* 合法的 */510E /* 非法的：不完整的指数 */210f /* 非法的：没有小数或指数 */.e55 /* 非法的：缺少整数或分数 */ 定义常量 在 C 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 下面是使用 #define 预处理器定义常量的形式： 1#define identifier value 例子: 12345678#define name 10L#define age 27Uvoid main() { int person; person = name + age; printf(\"values :%d\",person);} const 关键字 您可以使用 const 前缀声明指定类型的常量，如下所示： 1const type variable = value; 例子: 12345678void main() { const int LEGTH = 10; const int WIDTH = 5; const char NEWLINE = '\\n'; int area; area = LEGTH * WIDTH; printf(\"value of area: %d\", area);} 6. 存储类存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类： auto register static extern auto 存储类 auto 存储类时所有局部变量默认的存储类。 12int month;auto int month; 上面定义了两个带有相同存储类，auto 只能用在函数内，即 auto 只能修饰局部变量。 register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。 1register int miles; 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 register并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。 例子: 1234567891011121314151617//函数声明void func1(void);static int count = 10; //全局变量 - static 默认的void main() { while (count--) { func1(); }}void func1(void) {// 'thingy' 是 'func1' 的局部变量 - 只初始化一次// * 每次调用函数 'func1' 'thingy' 值不会被重置。 static int thingy = 5; thingy++; printf(\"thingy 为 %d, count 为 %d \\n\", thingy, count);} 输出: 12345678910thingy 为 6, count 为 9 thingy 为 7, count 为 8 thingy 为 8, count 为 7 thingy 为 9, count 为 6 thingy 为 10, count 为 5 thingy 为 11, count 为 4 thingy 为 12, count 为 3 thingy 为 13, count 为 2 thingy 为 14, count 为 1 thingy 为 15, count 为 0 实例中 count 作为全局变量可以在函数内使用，thingy 在局部使用 static 修饰后，不会在每次调用时重置。 extern 存储类 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件 ndk_day1.c 123456#include &lt;stdio.h&gt; //stdio.h 是一个头文件（标准输入输出头文件）,#include 是一个预处理命令，用来引入头文件。#include \"support.h\" //引入自己的头文件int main() { int sum = add(2, 5); printf(\"extern 使用 :%d\", sum);} 声明 support.h 头文件 12345678910//// Created by 阳坤 on 2019/12/13.//#ifndef NDK_SAMPLE_SUPPORT_H#define NDK_SAMPLE_SUPPORT_H#endif //NDK_SAMPLE_SUPPORT_Hextern int add(int num1,int num2); 头文件的实现 support.c 123int add(int num1,int num2){ return num1 * num2;} 输出: 1extern 使用 :10 7. 运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 例子: 1234567891011121314151617181920212223242526272829void main(){ int a = 21; int b = 10; int c; c = a + b; printf(\"a + b = %d \\n\", c); c = a - b; printf(\"a - b = %d \\n\", c); c = a * b; printf(\"a * b = %d \\n\", c); c = a / b; printf(\"a / b = %d \\n\", c); c = a % b; printf(\"a % b = %d \\n\", c); c = ++a; printf(\"++a = %d , %d \\n\", c, a); c = b++; printf(\"b++ = %d , %d \\n\", c, b); c = b--; printf(\"b-- = %d \\n\", c);} 输出: 12345678a + b = 31 a - b = 11 a * b = 210 a / b = 2 a b = 1 ++a = 22 , 22 b++ = 10 , 11 b-- = 11 关系运算符 下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 为假。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &gt; B) 为假。 &lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &lt; B) 为真。 &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &gt;= B) 为假。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &lt;= B) 为真。 逻辑运算符 下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 &amp;&amp; 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A &amp;&amp; B) 为假。 || 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A &amp;&amp; B) 为真。 1234567891011121314151617181920212223242526272829303132333435void main(){ int a1 = 5; int b1 = 5; int c1; //如果两个操作数都非零，则条件为真。 if (a1 &amp;&amp; b1) { printf(\"a1 &amp;&amp; b1 %d \\n\", true); } else { printf(\"a1 &amp;&amp; b1 %d \\n\", false); } //如果两个操作数中有任意一个非零，则条件为真。 if (a1 || b1) { printf(\"a1 || b1 %d \\n\", true); } else { printf(\"a1 || b1 %d \\n\", false); } //改变 a1 b1 的值 a1 = 0; b1 = 10; //如果两个操作数都非零，则条件为真。 if (a1 &amp;&amp; b1) { printf(\"a1 &amp;&amp; b1 %d \\n\", true); } else { printf(\"a1 &amp;&amp; b1 %d \\n\", false); } if (!(a1 &amp;&amp; b1)) { printf(\"!(a1 &amp;&amp; b1) %d \\n\", true); } else { printf(\"a1 || b1 %d \\n\", false); }} 输出: 1234a1 &amp;&amp; b1 1 a1 || b1 1 a1 &amp;&amp; b1 0 !(a1 &amp;&amp; b1) 1 位运算符 p q p &amp; q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 123456789101112131415161718192021222324void main(){ //位运算符 &amp; | ^ ~ int wA = 60; //0011 1100 int wB = 13; //0000 1101 int wC = 10; //都为真，才是真 0000 1100 printf(\"wA &amp; wB=？%d\\n\", wA &amp; wB); //其中一个为真，就为真 0011 1101 printf(\"wA | wB=？%d\\n\", wA | wB); //一个为真则为真，2个为真这为假 00110001 printf(\"wA ^ wB=？%d\\n\", wA ^ wB); printf(\"~wB=？%d\\n\", ~wB); //二进制左移运算符 左 * 4 = 40 printf(\"wC&lt;&lt;2=？%d\\n\", wC &lt;&lt; 2); //二进制右移运算符 右 / 4 printf(\"wC&gt;&gt;2=？%d\\n\", wC &gt;&gt; 2);} 输出: 123456wA &amp; wB=？12wA | wB=？61wA ^ wB=？49~wB=？-14wC&lt;&lt;2=？40wC&gt;&gt;2=？2 下表显示了 C 语言支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 &amp; 按位与操作，按二进制位进行”与”运算。运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1; (A &amp; B) 将得到 12，即为 0000 1100 | 按位或运算符，按二进制位进行”或”运算。运算规则：`0 0=0; 0 ^ 异或运算符，按二进制位进行”异或”运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行”取反”运算。运算规则：~1=0; ~0=1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 &lt;&lt; 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A &lt;&lt; 2 将得到 240，即为 1111 0000 &gt;&gt; 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A &gt;&gt; 2 将得到 15，即为 0000 1111 赋值运算符 下表列出了 C 语言支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移且赋值运算符 C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2 &gt;&gt;= 右移且赋值运算符 C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2 &amp;= 按位与且赋值运算符 C &amp;= 2 等同于 C = C &amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 例子: 12345678910111213141516171819202122232425262728293031323334353637void main(){int wAA = 21; int wBB; wBB = wAA; printf(\"= %d\\n\", wBB); wBB += wAA; printf(\"+= %d\\n\", wBB); wBB -= wAA; printf(\"-= %d\\n\", wBB); wBB *= wAA; printf(\"*= %d\\n\", wBB); wBB /= wAA; printf(\"/= %d\\n\", wBB); wBB %= wAA; printf(\"%= %d\\n\", wBB); wBB &lt;&lt;= wAA; printf(\"&lt;&lt;= %d\\n\", wBB); wBB &lt;&lt;= wAA; printf(\"&gt;&gt;= %d\\n\", wBB); wBB &amp;= wAA; printf(\"&amp;= %d\\n\", wBB); wBB ^= wAA; printf(\"^= %d\\n\", wBB); wBB |= wAA; printf(\"|= %d\\n\", wBB);} 输出: 1234567891011= 21+= 42-= 21*= 441/= 21= 0&lt;&lt;= 0&gt;&gt;= 0&amp;= 0^= 21|= 21 杂项运算符 sizeof、&amp;、三元 下表列出了 C 语言支持的其他一些重要的运算符，包括 sizeof 和 ? :。 运算符 描述 实例 sizeof() 返回变量的大小。 sizeof(a) 将返回 4，其中 a 是整数。 &amp; 返回变量的地址。 &a; 将给出变量的实际地址。 * 指向一个变量。 *a; 将指向一个变量。 ? : 条件表达式 如果条件为真 ? 则值为 X : 否则值为 Y 例子: 123456789101112131415161718192021222324void main(){ int zxA = 4; short zxB; double zxC; int *ptr; //sizeOf 运算符实例 ,lu 32位无符号整数 printf(\"zxA sizeOf = %lu \\n\", sizeof(zxA)); printf(\"zxB sizeOf = %lu \\n\", sizeof(zxB)); printf(\"zxC sizeOf = %lu \\n\", sizeof(zxC)); //&amp; 和 * 运算符实例 ptr = &amp;zxA; //将 zxA 的地址值复制给 ptr 指针 printf(\"zxA 的值为：%d \\n\", zxA); printf(\"*ptr 的值为：%d \\n\", *ptr); //三元运算符 zxA = 10; zxB = (zxA == 1) ? 20 : 30; printf(\"zxb 的值为：%d \\n\", zxB); zxB = (zxA == 10) ? 20 : 30; printf(\"zxb 的值为：%d \\n\", zxB);} 输出: 1234567zxA sizeOf = 4 zxB sizeOf = 2 zxC sizeOf = 8 zxA 的值为：4 *ptr 的值为：4 zxb 的值为：30 zxb 的值为：20 8. 判断C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。 C 语言提供了以下类型的判断语句。点击链接查看每个语句的细节。 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ?:运算符 跟 Java 一样 123456void main(){ int pdNumber; printf(\"输入一个数字：\"); scanf(\"%d\", &amp;pdNumber); (pdNumber % 2 == 0) ? printf(\"偶数\") : printf(\"基数\");} 9. 循环C 语言提供了以下几种循环类型。点击链接查看每个类型的细节。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 循环控制语句 循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。 C 提供了下列的循环控制语句。点击链接查看每个语句的细节。 控制语句 描述 break 语句 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。 continue 语句 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 使用方法可以参考 Java ，下面给出循环的例子: 12345678910void main(){ //限制 for (int i = 0; i &lt; 6; i++) { printf(\"限制循环,%d \\n\",i); } //无限循环 for (;;) { printf(\"该循环会一直执行下去！\\n\"); }} 10. 函数函数定义 C 语言中的函数定义的一般形式如下： 1234return_type function_name( parameter list ){ body of the function} 在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 例子: 12345678910111213/* 函数返回两个数中较大的那个数 */int max(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } 函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： 1return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： 1int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： 1int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。 调用函数 123456789101112131415//函数声明int max(int num1, int num2);/** *C 函数 */void main() { //找出函数中最大值 printf(\"找出函数中最大值，%d \\n\",max(66,88));}int max(int num1, int num2) { return (num1 &gt; num2) ? num1 : num2;} 输出: 1找出函数中最大值，88 函数参数 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 11. 作用域规则任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量： 在函数或块内部的局部变量 在所有函数外部的全局变量 在形式参数的函数参数定义中 让我们来看看什么是局部变量、全局变量和形式参数。 局部变量 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。下面是使用局部变量的实例。在这里，所有的变量 a、b 和 c 是 main() 函数的局部变量。 1234567891011void main(){ //局部变量 int a, b; int c; //初始化局部变量 a = 10; b = 20; c = a + b; //%d:以十进制形式输出带符号整数(正数不输出符号) printf(\"values of a = %d,b = %d and c = %d \\n\", a, b, c);} 输出: 1values of a = 10,b = 20 and c = 30 全局变量 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。 全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例： 1234567891011//全局变量声明int g;void main(){ int a, b; //初始化局部变量 a = 10; b = 20; //全部变量赋值 g = a + c; printf(\"values of a = %d,bc = %d and g = %d \\n\", a, c, g);} 输出: 1values of a = 10,bc = 30 and g = 40 形式参数 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。下面是一个实例： 1234567891011121314int sumA(int a, int b) { printf(\"value of a in sum() = %d\\n\", a); printf(\"value of b in sum() = %d\\n\", b); return x + y;}void main(){ int a, b,c; //初始化局部变量 a = 10; b = 20; c = sumA(a, b); printf(\"value of c in main() = %d\\n\", c);} 输出: 1value of a in main() = 30 全局变量和局部变量的区别 全局变量保存在内存的全局存储区中，占用静态的存储单元； 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。 初始化局部变量和全局变量的默认值 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL 12. 数组C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 声明数组 在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： 1type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下： 1double balance[10]; 初始化数组 123void main(){ double balance[10] = {1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0}} 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果： 123void main(){ double balance[] = {1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0}} 您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例： 1balance[1] = 50.5; 访问数组元素 12//跟 Java 一样double value = balance[1] 例子: 1234567891011121314151617181920212223void main() { //定义一个长度为 10 的整数数组 int n[10]; int i, j; //初始化数组元素 for (i = 0; i &lt; 10; i++) { n[i] = 2 * i; } //输出元素中的数据 for (int k = 0; k &lt; 10; ++k) { printf(\"Element[%d] = %d \\n\", k, n[k]); } //总的大小除以其中一个大小就得到了 数组长度 printf(\"整数数组 n 的长度： %d \\n\", sizeof(n) / sizeof(n[0])); //输出元素中的数据 for (int k = 0; k &lt; sizeof(n) / sizeof(n[0]); ++k) { printf(\"Element[%d] = %d \\n\", k, n[k]); }} 输出: 123456789101112131415161718192021Element[0] = 0 Element[1] = 2 Element[2] = 4 Element[3] = 6 Element[4] = 8 Element[5] = 10 Element[6] = 12 Element[7] = 14 Element[8] = 16 Element[9] = 18 整数数组 n 的长度： 10 Element[0] = 0 Element[1] = 2 Element[2] = 4 Element[3] = 6 Element[4] = 8 Element[5] = 10 Element[6] = 12 Element[7] = 14 Element[8] = 16 Element[9] = 18 C 中数组详解 在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念： 概念 描述 多维数组 C 支持多维数组。多维数组最简单的形式是二维数组。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C 允许从函数返回数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 13. 枚举枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。 枚举语法定义格式为： 1enum 枚举名 {枚举元素1,枚举元素2,……}; 接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名： 1234567#define MON 1#define TUE 2#define WED 3#define THU 4#define FRI 5#define SAT 6#define SUN 7 这个看起来代码量就比较多，接下来我们看看使用枚举的方式： 1234enum DAY{ MON=1, TUE, WED, THU, FRI, SAT, SUN}; 这样看起来是不是更简洁了。 注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。 可以在定义枚举类型时改变枚举元素的值： 12enum season {spring, summer=3, autumn, winter}; 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5 枚举变量的定义 前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。 我们可以通过以下三种方式来定义枚举变量 1、先定义枚举类型，再定义枚举变量 12345enum DAY{ MON=1, TUE, WED, THU, FRI, SAT, SUN};enum DAY day; 2、定义枚举类型的同时定义枚举变量 1234enum DAY{ MON=1, TUE, WED, THU, FRI, SAT, SUN} day; 3、省略枚举名称，直接定义枚举变量 1234enum{ MON=1, TUE, WED, THU, FRI, SAT, SUN} day; 例子: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void main() { //遍历一周 for (day = MON; day &lt;= SUN; day++) { printf(\"周: %d \\n\", day); } enum color { red=1, green, blue ,black}; enum color favorite_color;// ask user to choose color printf(\"请输入你喜欢的颜色: (1. red, 2. green, 3. blue): \"); scanf(\"%d\", &amp;favorite_color);// 输出结果 switch (favorite_color) { case red: printf(\"你喜欢的颜色是红色\"); break; case green: printf(\"你喜欢的颜色是绿色\"); break; case blue: printf(\"你喜欢的颜色是蓝色\"); break; case black: printf(\"你喜欢的颜色是黑色\"); break; default: printf(\"你没有选择你喜欢的颜色\"); } //将整数转换为枚举 enum day { saturday, sunday, monday, tuesday, wednesday, thursday, friday } ; int a = 1; enum day weekend; weekend = (enum day)a; printf(\"weekend:%d \\n\",weekend);} 输出: 123456789周: 1 周: 2 周: 3 周: 4 周: 5 周: 6 周: 7 请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1你喜欢的颜色是红色weekend:1 14. 指针学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： 1234567void main(){ int var1; char var2[10]; //%p ： 输出指针地址 printf(\"var1 变量的地址：%p \\n\", &amp;var1); printf(\"var2 变量的地址：%p \\n\", &amp;var2);} 输出: 12var1 变量的地址：0x7ffee7e976b8 var2 变量的地址：0x7ffee7e976be 通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。 什么是指针? 指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： 1type *var-name 在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *i; //一个整型的指针 double *d;//double 型指针float *f;//浮点型指针char *ch//字符型指针 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 如何使用指针? 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： 例子: 123456789101112131415//如何使用指针int var = 66;//实际变量的声明int *ip;//指针变量的声明ip = &amp;var; //指针变量中存储 var 的地址printf(\"var 的地址 : %p \\n\", var);//在指针变量中存储的地址printf(\"ip 的地址：%p \\n\", ip);//使用指针访问地址printf(\"ip 指针对应的地址：%p \\n\", *ip);//使用指针访问地址对应的值printf(\"ip 指针对应的地址：%d \\n\", *ip); 输出: 1234var 的地址 : 0x42 ip 的地址：0x7ffee96eb6b4 ip 指针对应的地址：0x42 ip 指针对应的地址：66 C 中的 NULL 指针 在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序： 12345678void main(){ //赋值一个 NULL 指针 int *ptr = NULL; printf(\"ptr 的地址是： %p \\n\", ptr); //检查一个空指针 if (ptr) printf(\"如果 ptr 不是空指针，则执行\"); else printf(\"如果 ptr 是空指针，则执行\");} 输出: ptr 的地址是： 0x0ptr 是空指针 C 指针详解 在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念： 概念 描述 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- 指针数组 可以定义用来存储指针的数组。 指向指针的指针 C 允许指向指针的指针。 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 从函数返回指针 C 允许函数返回指针到局部变量、静态变量和动态内存分配。 15. 函数指针与回调函数函数指针是指向函数的指针变量。 通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。 函数指针可以像一般函数一样，用于调用函数、传递参数。 函数指针变量的声明： 1typedef int (*fun_ptr)(int,int)//声明一个指向同样参数，返回值得函数指针类型 例子: 1234567891011121314151617int max(int num1, int num2) { return (num1 &gt; num2) ? num1 : num2;}void main() { //定义一个返回值为 int 类型，参数为 （int,int） 形式的函数指针 int (*p)(int, int) = *max; int a, b, c, d; printf(\"请输入三个数字:\\n\"); scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); //与直接调用函数等价，d = max(max(a,b),c); d = p(p(a, b), c); printf(\"最大数字是: %d \\n\", d);} 回调函数 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。 简单讲：回调函数是由别人的函数执行时调用你实现的函数。 例子: 例子中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。 实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。 populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。 123456789101112131415161718192021222324252627#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt;//回调函数void populate_array(int *array, size_t arraySize, int(*getNextValue)(void)) { printf(\"array 地址：%p \\n\", array); for (size_t i = 0; i &lt; arraySize; i++) { array[i] = getNextValue(); printf(\" array[%d] ,存储值：%d \\n\", i, array[i]); }}//获取一个随机数int getNextRandomValue(void) { return rand();}void main() { //回调函数 int array[10]; printf(\"Int array 地址：%p \\n\", array); populate_array(array, sizeof(array)/sizeof(array[0]), getNextRandomValue); for (int i = 0; i &lt; sizeof(array)/sizeof(array[0]); ++i) { printf(\" array[%d] , 对应值为：%d \\n\", i, array[i]); }} 输出: 12345678910111213141516171819202122Int array 地址：0x7ffeebf1a650 array 地址：0x7ffeebf1a650 array[0] ,存储值：16807 array[1] ,存储值：282475249 array[2] ,存储值：1622650073 array[3] ,存储值：984943658 array[4] ,存储值：1144108930 array[5] ,存储值：470211272 array[6] ,存储值：101027544 array[7] ,存储值：1457850878 array[8] ,存储值：1458777923 array[9] ,存储值：2007237709 array[0] , 对应值为：16807 array[1] , 对应值为：282475249 array[2] , 对应值为：1622650073 array[3] , 对应值为：984943658 array[4] , 对应值为：1144108930 array[5] , 对应值为：470211272 array[6] , 对应值为：101027544 array[7] , 对应值为：1457850878 array[8] , 对应值为：1458777923 array[9] , 对应值为：2007237709 16. 字符串在 C 语言中，字符串实际上是使用 null 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。 1char ch[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; 也可以使用以下简写模式: 1char ch[6] = \"Hello\" 字符串在 C/C++ 中内存表示: 其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 ‘\\0’ 放在字符串的末尾。让我们尝试输出上面的字符串： 12345678void main(){ //定义一个 char 数组 char string[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; //简写 char string2[6] = \"Hello\"; //%s:输出字符串 printf(\"string message : %s\\n\", string);} 输出: 1string message : Hello C 中对字符串操作的 API 序号 函数 &amp; 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 例子: 12345678910111213141516171819void main(){ //字符串操作 char str1[12] = \"Hello\"; char str2[12] = \"World\"; char str3[12]; int len; //将 str1 复制到 str3 strcpy(str3, str1); printf(\"strcpy (str3,str1) :%s\\n\", str3); //拼接字符串 str1 + str2 strcat(str1, str2); printf(\"strcat(str1,str2) :%s\\n\", str1); //返回字符串的长度 len = strlen(str1); printf(\"strlen(str1) :%d\\n\", len);} 输出: 123strcpy (str3,str1) :Hellostrcat(str1,str2) :HelloWorldstrlen(str1) :10 17. 结构体C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。 结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性： Title Author Subject Book ID 定义结构 为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： 12345struct name{ member-list; member-list; ...}name_tag, name 是结构的标签。 member-list 是标准的变量定义，比如 int i;或者 float f,或者其它有效的变量定义。 name_tag 结构变量，定义在结构的末尾，最后一个分号之前，你可以指定一个或多个结构变量，下面是声明 Book 的结构方式： 123456struct Books{ char title[50]; char author[50]; char subject[100]; int book_id;} book; 注意：在定义结构体的时候name、member-list、name_tag 这 3 部分至少要出现 2 个。 结构体变量的初始化 和其它类型变量一样，在初始化的时候可以指定初始值。 123456789101112131415//定义一个 Books 结构，类似于 Java 中的数据 beanstruct Books { char title[50]; char author[50]; char subject[100]; int book_id; double rmb;} book = {\"Java\", \"Android\", \"C 语言\", 666, 55.5};void main(){ //打印 Books printf(\"title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\nrmb: %f\\n\", book.title, book.author, book.subject, book.book_id, book.rmb);} 输出: 12345title : Javaauthor: Androidsubject: C 语言book_id: 666rmb: 55.500000 访问结构成员 1234567891011121314151617181920212223242526272829303132333435struct Books2 { char title[50]; char author[50]; char subject[100]; int book_id;};void main(){ //访问 Books2 结构成员 struct Books2 Books2A;//声明 Books2A 类型为 Books2 struct Books2 Books2B;//声明 Books2B 类型为 Books2 //Books2A 详述 strcpy(Books2A.title, \"C Plus\"); strcpy(Books2A.author, \"Nuha Ali\"); strcpy(Books2A.subject, \"C\"); Books2A.book_id = 666888; //Books2B 详述 strcpy(Books2B.title, \"C++ Plus\"); strcpy(Books2B.author, \"DevYK\"); strcpy(Books2B.subject, \"C++\"); Books2B.book_id = 666999; // 输出 Book1 信息 printf(\"Book 1 title : %s\\n\", Books2A.title); printf(\"Book 1 author : %s\\n\", Books2A.author); printf(\"Book 1 subject : %s\\n\", Books2A.subject); printf(\"Book 1 book_id : %d\\n\", Books2A.book_id); // 输出 Book2 信息 printf(\"Book 2 title : %s\\n\", Books2B.title); printf(\"Book 2 author : %s\\n\", Books2B.author); printf(\"Book 2 subject : %s\\n\", Books2B.subject); printf(\"Book 2 book_id : %d\\n\", Books2B.book_id);} 输出: 12345678Book 1 title : C PlusBook 1 author : Nuha AliBook 1 subject : CBook 1 book_id : 666888Book 2 title : C++ PlusBook 2 author : DevYKBook 2 subject : C++Book 2 book_id : 666999 结构作为函数参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445//函数声明void printBook(struct Books2 books2);void main(){ //访问 Books2 结构成员 struct Books2 Books2A;//声明 Books2A 类型为 Books2 struct Books2 Books2B;//声明 Books2B 类型为 Books2 //Books2A 详述 ，将 CPlus copy 到 title 中 strcpy(Books2A.title, \"C Plus\"); strcpy(Books2A.author, \"Nuha Ali\"); strcpy(Books2A.subject, \"C\"); Books2A.book_id = 666888; //Books2B 详述 strcpy(Books2B.title, \"C++ Plus\"); strcpy(Books2B.author, \"DevYK\"); strcpy(Books2B.subject, \"C++\"); Books2B.book_id = 666999; // 输出 Book1 信息 printf(\"Book 1 title : %s\\n\", Books2A.title); printf(\"Book 1 author : %s\\n\", Books2A.author); printf(\"Book 1 subject : %s\\n\", Books2A.subject); printf(\"Book 1 book_id : %d\\n\", Books2A.book_id); // 输出 Book2 信息 printf(\"Book 2 title : %s\\n\", Books2B.title); printf(\"Book 2 author : %s\\n\", Books2B.author); printf(\"Book 2 subject : %s\\n\", Books2B.subject); printf(\"Book 2 book_id : %d\\n\", Books2B.book_id); printf(\"\\n\\n\\n\"); //结构作为函数参数 printBook(Books2A); printBook(Books2B);}void printBook(struct Books2 book) { printf(\"Book title : %s\\n\", book.title); printf(\"Book author : %s\\n\", book.author); printf(\"Book subject : %s\\n\", book.subject); printf(\"Book book_id : %d\\n\", book.book_id);} 输出: 12345678910111213141516171819Book 1 title : C PlusBook 1 author : Nuha AliBook 1 subject : CBook 1 book_id : 666888Book 2 title : C++ PlusBook 2 author : DevYKBook 2 subject : C++Book 2 book_id : 666999Book title : C PlusBook author : Nuha AliBook subject : CBook book_id : 666888Book title : C++ PlusBook author : DevYKBook subject : C++Book book_id : 666999 指向结构的指针 您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： 1struct Books *struct_pointer; 现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示： 1struct_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示： 1struct_pointer-&gt;title; 例子: 1234567891011121314151617181920212223242526272829303132333435//定义指向结构的指针void printBookZZ(struct Books2 *books2);void main(){ //访问 Books2 结构成员 struct Books2 Books2A;//声明 Books2A 类型为 Books2 struct Books2 Books2B;//声明 Books2B 类型为 Books2 //Books2A 详述 ，将 CPlus copy 到 title 中 strcpy(Books2A.title, \"C Plus\"); strcpy(Books2A.author, \"Nuha Ali\"); strcpy(Books2A.subject, \"C\"); Books2A.book_id = 666888; //Books2B 详述 strcpy(Books2B.title, \"C++ Plus\"); strcpy(Books2B.author, \"DevYK\"); strcpy(Books2B.subject, \"C++\"); Books2B.book_id = 666999; //通过内存地址传递信息，为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面 printBookZZ(&amp;Books2A); printBookZZ(&amp;Books2B);} /** * 为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示： * @param book */void printBookZZ(struct Books2 *book) { printf(\"Book -&gt; title : %s\\n\", book-&gt;title); printf(\"Book -&gt; author : %s\\n\", book-&gt;author); printf(\"Book -&gt; subject : %s\\n\", book-&gt;subject); printf(\"Book -&gt; book_id : %d\\n\", book-&gt;book_id);} 位域 有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。 所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。 典型的实例： 用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。 读取外部文件格式——可以读取非标准的文件格式。 位域ed 定义: 123struct 位域结构名称{ 位域列表}; 位域列表的形式为: 1类型说明符 位域名：位域长度 例如: 12345struct bean { int a:8; int b:4; int c:4;}data; 说明 data 为 bean 变量，共占 2个字节。其中位域 a 占 8 位，位域 b 占 4 位，位域 c 占 4 位。 注意: 一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如： 123456struct bean{ unsigned a:4; unsigned :4;//空域 unsigned b:4;//从下一个单元开始存放 unsigned c:4;} 在这个位域定义中共占用 2 个字节，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。 位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如： 1234567struct k{ int a:1; int :2; /* 该 2 位不能使用 */ int b:3; int c:2;}; 从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。 位域的使用 位域的使用和结构成员的使用相同，其一般形式为: 位域变量名.位域名 位域变量名-&gt;位域名 位域允许用各种格式输出。 例子: 12345678910111213141516171819void main(){ //位域 struct bs { unsigned int a:1;//占 位段a 1 位 unsigned b:6;//占 位段b 3 位 unsigned c:7;//占 位段c 4 位 } bit, *pbit; // 给位域赋值（应注意赋值不能超过该位域的允许范围） bit.a = 1; //以二进制 1 表示 1 bit位 bit.b = 50;//以二进制 110010 表示 6 bit位 bit.c = 100;//以二进制 1100100 标志 7 bit位 printf(\"%d,%d,%d\\n\",bit.a,bit.b,bit.c); // 以整型量格式输出三个域的内容 pbit=&amp;bit; //把位域变量 bit 的地址送给指针变量 pbit pbit-&gt;a=0; //用指针方式给位域 a 重新赋值，赋为 0 pbit-&gt;b&amp;=3; //使用了复合的位运算符 \"&amp;=\"，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 50，与 3 作按位与运算的结果为 2（110010&amp;011=010，十进制值为 2） pbit-&gt;c|=1; //使用了复合位运算符\"|=\"，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 （1100100 | 0000001）= 1100101 = 101 printf(\"%d,%d,%d\\n\",pbit-&gt;a,pbit-&gt;b,pbit-&gt;c); //用指针方式输出了这三个域的值} 输出: 121,50,1000,2,101 18. 共用体共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。 定义共同体 为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下： 1234567union [union tag]{member definition;member definition;...member definition;}[one or more union variables]; union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str： 123456union Data{int i;float f;char str[20];} 现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。 共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小： 123456789union Data { int i; float f; char str[20];};void main(){ union Data data; printf(\"Memory size occupied by data: %d\\n\", sizeof(data));} 输出: 1Memory size occupied by data: 20 访问共同体成员 为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法： 12345678910111213141516171819202122232425union Data { int i; float f; char str[20];};void main() { //1. 访问共同体 no data.i = 10; data.f = 1314.520; strcpy(data.str,\"C/C++\"); printf( \"data.i : %d\\n\", data.i); printf( \"data.f : %f\\n\", data.f); printf( \"data.str : %s\\n\", data.str); printf(\"\\n\\n\\n\"); //2. 访问共同体 yes data.i = 10; printf( \"data.i : %d\\n\", data.i); data.f = 1314.520; printf( \"data.f : %f\\n\", data.f); strcpy(data.str,\"C/C++\"); printf( \"data.str : %s\\n\", data.str); } 输出: 123456789data.i : 725823299data.f : 0.000000data.str : C/C++data.i : 10data.f : 1314.520020data.str : C/C++ 在这里，我们可以看到上面注释 1 共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。我们看注释 2 ，这次我们在同一时间只使用一个变量成员，所以都能完好输出。 19. 位域参考 17.(位域的介绍) 20. typedefC 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE： 1typedef unsigned char BYTE; 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如： 1BYTE b1, b2; 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下： 1typedef unsigned char byte; 您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下： 123456789101112131415161718192021222324typedef struct Books { char title[50]; char author[50]; char subject[50]; int book_id;} Book;#define TRUE 1#define FALSE 0 void main(){ Book book; strcpy( book.title, \"C 教程\"); strcpy( book.author, \"Runoob\"); strcpy( book.subject, \"编程语言\"); book.book_id = 12345; printf( \"书标题 : %s\\n\", book.title); printf( \"书作者 : %s\\n\", book.author); printf( \"书类目 : %s\\n\", book.subject); printf( \"书 ID : %d\\n\", book.book_id); printf( \"TRUE 的值: %d\\n\", TRUE); printf( \"FALSE 的值: %d\\n\", FALSE); } 输出: 123456书标题 : C 教程书作者 : Runoob书类目 : 编程语言书 ID : 12345TRUE 的值: 1FALSE 的值: 0 typedef vs define define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同： typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。 typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。 例子可以参考上面是 #define 使用。 21. 输入 &amp; 输出当我们提到输入时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。 当我们提到输出时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。 标准输出 C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。 标准文件 文件指针 设备 标准输入 stdin 键盘 标准输出 stdout 屏幕 标准错误 stderr 您的屏幕 文件指针是访问文件的方式，本节将讲解如何从屏幕读取值以及如何把结果输出到屏幕上。 C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。 scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。 例子: 1234567void main(){ float f; printf(\"Enter a float number: \\n\"); // %f 匹配浮点型数据 scanf(\"%f\",&amp;f); printf(\"Value = %f\", f);} 输出: 123Enter a float number: 12.3Value = 12.300000 getchar()&amp;putchar() 函数 int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。 int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。 123456789void main(){ int c; printf( \"\\nEnter a value :\"); //函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。 c = getchar( ); printf( \"\\nYou entered: \"); //读取第一个字符 putchar( c );} 输出: 123Enter a value :abcdefYou entered: a gets() &amp; puts() 函数 char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。 int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。 12345678910void main(){ char str[100]; printf( \"\\nEnter a value :\"); //读取一行 gets( str ); printf( \"\\nYou entered: \"); puts( str );} 输出: 123Enter a value :大家好，才是真的好！You entered: 大家好，才是真的好！ 22. 文件读写上一节我们讲解了 C 语言处理的标准输入和输出设备。本章我们将介绍 C 程序员如何创建、打开、关闭文本文件或二进制文件。 一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。本章将讲解文件管理的重要调用。 打开文件 您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型： 1FILE *fopen( const char * filename, const char * mode ); 在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个： 模式 描述 r 打开一个已有的文本文件，允许读取文件。 w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 r+ 打开一个文本文件，允许读写文件。 w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 如果处理的是二进制文件，则需要使用下面的访问模式来取代上面的访问模式: 1\"rb\", \"wb\", \"ab\", \"rb+\", \"r+b\", \"wb+\", \"w+b\", \"ab+\", \"a+b\" 关闭文件 为了关闭文件，请使用 fclose( ) 函数。函数的原型如下： 1int fclose( FILE *fp ); 如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。 C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。 写入文件 下面是把字符串写入到流中的最简单的函数: 1int fputc(int c,FILE *fp); 函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中： 1int fputs( const char *s, FILE *fp ); 函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。尝试下面的实例： 12345678910111213void main(){ //定义一个空指针文件 FILE *fp = NULL; //打开文件，打开一个文本文件，允许读写文件。 // 如果文件不存在，则会创建一个新文件。 // 读取会从文件的开头开始，写入则只能是追加模式。 fp = fopen(\"/Users/devyk/Data/ClionProjects/NDK_Sample/README.md\",\"a+\"); fprintf(fp, \" fprintf 我是添加进来的1\\n\"); fprintf(fp, \"fprintf 我是添加进来的2\\n\"); fputs(\"fputs 我是添加进来的1\\n\", fp); fputs(\"fputs 我是添加进来的2\\n\", fp); fclose(fp);} 读取文件 下面是从文件读取单个字符的最简单的函数： 1int fgetc( FILE * fp ); fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面的函数允许您从流中读取一个字符串： 1char *fgets( char *buf, int n, FILE *fp ); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。 如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 int fscanf(FILE *fp, const char *format, …) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。 例子: 123456789101112131415void main(){ FILE *fp = NULL; //读取文件 char buff[255]; fp = fopen(\"/Users/devyk/Data/ClionProjects/NDK_Sample/README.md\",\"r\"); fscanf(fp,\"%s\",buff); printf(\"1: %s\\n\", buff); fgets(buff, 255, (FILE*)fp); printf(\"2: %s\\n\", buff); fgets(buff, 255, (FILE*)fp); printf(\"3: %s\\n\", buff ); fclose(fp);} 23. 预处理器C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。 所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令： 指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 例子: 分析下面的实例来理解不同的指令。 1#define MAX_ARRAY_LENGTH 20 这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 #define 定义常量来增强可读性。 12#include &lt;stdio.h&gt;#include &quot;utils.h&quot; 这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 utils.h，并添加内容到当前的源文件中。 12#undef FILE_SIZE#define FILE_SIZE 42 这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。 123#ifndef MESSAGE #define MESSAGE &quot;You wish!&quot;#endif 这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。 123#ifdef DEBUG /* Your debugging statements here */#endif 这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。 预定义宏 ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。 宏 描述 DATE 当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。 TIME 当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。 FILE 这会包含当前文件名，一个字符串常量。 LINE 这会包含当前行号，一个十进制常量。 STDC 当编译器以 ANSI 标准编译时，则定义为 1。 例子: 123456789101112void main() { //这会包含当前文件名，一个字符串常量。 printf(\"File :%s\\n\", __FILE__); //当前日期，一个以 \"MMM DD YYYY\" 格式表示的字符常量。 printf(\"Date :%s\\n\", __DATE__); //当前时间，一个以 \"HH:MM:SS\" 格式表示的字符常量。 printf(\"Time :%s\\n\", __TIME__); //这会包含当前行号，一个十进制常量。 printf(\"Line :%d\\n\", __LINE__); //当编译器以 ANSI 标准编译时，则定义为 1。 printf(\"ANSI :%d\\n\", __STDC__);} 输出: 12345File :/Users/devyk/Data/ClionProjects/NDK_Sample/day_1/ndk_day1.cDate :Dec 17 2019Time :14:23:47Line :954ANSI :1 预处理器运算符 C 预处理器提供了下列的运算符来帮助您创建宏： 宏延续运算符() 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\\）。例如： 12#define message_for(a, b) \\ printf(#a &quot; and &quot; #b &quot;: We love you!\\n&quot;) 字符串常量化运算符(#) 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如： 12345678910#include &lt;stdio.h&gt;#define message_for(a, b) \\ printf(#a \" and \" #b \": We love you!\\n\")int main(void){ message_for(Carole, Debra); return 0;} 当上面的代码被编译和执行时，它会产生下列结果： 1Carole and Debra: We love you! 标记粘贴运算符(##) 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如： 1234567891011#include &lt;stdio.h&gt;#define tokenpaster(n) printf (\"token\" #n \" = %d\", token##n)int main(void){ int token34 = 40; tokenpaster(34); return 0;} 当上面的代码被编译和执行时，它会产生下列结果： 1token34 = 40 这是怎么发生的，因为这个实例会从编译器产生下列的实际输出： 1printf (&quot;token34 = %d&quot;, token34); 这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。 defined() 运算符 预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法： 1234567891011#include &lt;stdio.h&gt;#if !defined (MESSAGE) #define MESSAGE \"You wish!\"#endifint main(void){ printf(\"Here is the message: %s\\n\", MESSAGE); return 0;} 当上面的代码被编译和执行时，它会产生下列结果： 1Here is the message: You wish! 参数化的宏 CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方： 123int square(int x) { return x * x;} 我们可以使用宏重写上面的代码，如下： 1#define square(x) ((x) * (x)) 在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如： 123456789#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main(void){ printf(\"Max between 20 and 10 is %d\\n\", MAX(10, 20)); return 0;} 当上面的代码被编译和执行时，它会产生下列结果： 1Max between 20 and 10 is 20 24. 头文件头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。 在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。 引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。 A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。 引用头文件的语法 使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种： 1#include &lt;file&gt; 这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 1#include \"file\" 这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 引用头文件的操作 #include 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 #include 指令之后的文本输出。例如，如果您有一个头文件 char_manger.h，如下： 1char *test(void); 和一个使用了头文件的主程序 char_manager.c,如下: 123456#include \"char_manger.h\"int x;int main (void){ puts (test ());} 编辑器会看到如下的代码信息: 12345678char *test (void);int x;int main (void){ puts (test ());} 只引用一次头文件 如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下： 123456#ifndef HEADER_FILE#define HEADER_FILEthe entire header file file#endif 这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。 有条件引用 有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下： 1234567#if SYSTEM_1 # include \"system_1.h\"#elif SYSTEM_2 # include \"system_2.h\"#elif SYSTEM_3 ...#endif 但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可： 123#define SYSTEM_H \"system_1.h\"...#include SYSTEM_H SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义 25. 强制类型转换强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型，如下所示： 1(type_name) expression 请看下面的实例，使用强制类型转换运算符把一个整数变量除以另一个整数变量，得到一个浮点数： 123456789void main(){ void main(){ int sum = 20,count = 3; double value,value2; value = (double)sum / count; value2 = sum / count; printf(\"Value 强转 : %f Value2 wei强转 : %f\\n \", value ,value2); }} 输出： 1Value 强转 : 6.666667 Value2 wei强转 : 6.000000 整数提升 整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符： 12345678910void main(){ //整数提升 int i= 17; char c = 'c'; //在 ascii 中的值表示 99 int sum2; sum2 = i + c; printf(\"Value of sum : %d\\n\", sum2 );} 输出: 1Value of sum : 116 在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。 26. 错误处理C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。 所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。 errno、perror() 和 strerror() C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。 perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。 strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。 让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。 例子: 12345678910111213void main(){ int dividend = 20; int divsor = 0; int quotient; if (divsor == 0){ fprintf(stderr,\"除数为 0 退出运行。。。\\n\"); exit(EXIT_FAILURE); } quotient = dividend / divsor; fprintf(stderr,\"quotient 变量的值为 : %d\\n\", quotient); exit(EXIT_SUCCESS);} 输出： 1除数为 0 退出运行。。。 27. 递归递归指的是在函数的定义中使用函数自身的方法。 语法格式如下: 123456789101112void recursion(){ statements; ... ... ... recursion(); /* 函数调用自身 */ ... ... ...} int main(){ recursion();} 数的阶乘 12345678910double factorial(unsigned int i){ if (i &lt;= 1){ return 1; } return i * factorial(i - 1);}void main(){ int i = 15; printf(\"%d 的阶乘 %ld \\n\",i ,factorial(i));} 输出: 115 的阶乘 140732727129776 斐波拉契数列 12345678910111213141516//斐波拉契数列int fibonaci(int i){ if (i == 0){ return 0; } if (i == 1){ return 1; } return fibonaci(i - 1) + fibonaci( i -2);}void main(){ for (int j = 0; j &lt; 10; j++) { printf(\"%d\\t\\n\", fibonaci(j)); }} 输出: 1234567891001 1 2 3 5 8 13 21 34 28. 可变参数有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。下面的实例演示了这种函数的定义。 123456789101112int func(int, ... ) { . . .} int main(){ func(2, 2, 3); func(3, 2, 3, 4);} 请注意，函数 func() 最后一个参数写成省略号，即三个点号（…），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下： 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。 使用宏 va_end 来清理赋予 va_list 变量的内存。 现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值： 例子: 12345678910111213141516171819double average(int num,...){ va_list vaList; double sum = 0.0; int i ; //为 num 个参数初始化 valist va_start(vaList,num); //访问所有赋给 vaList 的参数 for (int j = 0; j &lt; num; j++) { sum += va_arg(vaList, int); } //清理为valist 保留的内存 va_end(vaList); return sum/num;}void main(){ printf(\"Average of 2, 3, 4, 5 = %f\\n\", average(4, 2,3,4,5)); printf(\"Average of 5, 10, 15 = %f\\n\", average(3, 5,10,15));} 输出: 12Average of 2, 3, 4, 5 = 3.500000Average of 5, 10, 15 = 10.000000 29. 内存管理本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 &lt;stdlib.h&gt; 头文件中找到。 序号 函数和描述 void *calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 numsize 个字节长度的内存空间，并且每个字节的值都是0。 void free(void *address); 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 void *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 void *realloc(void *address, int newsize); 该函数重新分配内存，把内存扩展到 newsize。 *注意: * void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。 动态分配内存 编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示： 1char name[100]; 但是，如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示： 12345678910111213141516171819void main() { char name[100]; char *description; //将字符串 copy 到 name 中 strcpy(name, \"迎娶白富美！\"); //开始动态分配内存 description = (char *) malloc(200 * sizeof(char)); if (description == NULL) { fprintf(stderr, \"Error - unable to allocate required memory\\n\"); } else { strcpy(description, \"开始添加数据到 description 中\"); } printf(\"Name = %s\\n\", name ); printf(\"Description: %s sizeOf 大小 ：%d\\n\", description , sizeof(description));// 使用 free() 函数释放内存 free(description);} 输出: 12Name = 迎娶白富美！Description: 开始添加数据到 description 中 sizeOf 大小 ：8 30. 命令行参数执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。 命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作： 12345678910void main(int argc , char *argv[]){ if (argc ==1){ printf(\"argv[%d] == %d\",0,*argv[0]); } else if (argc ==2){ printf(\"argv[%d] == %d\",1,*argv[1]); } else{ printf(\"匹配失败...\"); }} 输出: 1argv[0] == 47 总结不知道大家在看完 C 基础内容之后在对比下 Java 语法，是不是大部分都差不多，之前有的人说学了 C 在学其它语言都是小菜一碟，现在看来好像是这么回事。个人觉得其实只要会编程语言中的任何一门在学其它语言都会比较容易上手。 C 语言基础加强学习资料 C 语言 排序算法 C 语言 基础实例代码 C 语言 100 道练习题 参考 https://www.runoob.com/cprogramming/c-tutorial.html","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0(%E4%B8%80)%20C%20%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"title":"音视频学习 (二) C++ 语言入门","text":"前言上一篇文章我们学习了 C 语言基础，那么按照咱们的学习计划该学习 C++ 语言基础了，如果没有 C/C++ 基础了可以按照我的文章序列跟着敲一篇，不会没什么可怕的，可怕的是不会还不练习，光看是学不会的。前面几篇学习语言基础我知道很枯燥，但是没有 C/C++ 语言基础到时候学习 NDK 的内容你就更看不懂了，完全就像是在看科幻片一样。所以，我们一起加油，一起学习，共同进步 。 简介C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。 环境配置如果您使用的是 Mac ，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。 开发工具我这里还是使用的 CLion , 下一篇文章讲解 JNI 技术就开始用 AndroidStudio 。 C++ 语言入门还是以 ”HelloWorld“ 打开 C++ 的门。 1. 基本语法123456789101112131415#include &lt;iostream&gt; // 空间命名using namespace std;int main(){//跟 C 一样入口都是 main 函数 test1(); return 0;}void test1() { //1. 使用命名空间// cout &lt;&lt; \"C++ 语言入门第一行代码 Hello World!\" &lt;&lt; endl; //就是一个对 C++ 打印的封装 println(\"\", \"C++ 语言入门第一行代码 Hello World!\"); //未使用命名空间// std::cout &lt;&lt; \"C++ 语言入门第一行代码 Hello World!\" &lt;&lt; std::endl;} 输出: 1C++ 语言入门第一行代码 Hello World! 下面我们就来解释一下上面这段最简单的程序的组成部分 C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 下一行是一个 // 的注释。 下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 int main() 是主函数，程序从这里开始执行。 下一行调用 test1() 函数 下一行 cout &lt;&lt; “C++ 语言入门第一行代码 Hello World!” &lt;&lt; endl; 会在屏幕上显示消息 “C++ 语言入门第一行代码 Hello World!”。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 中间忽略了一些注释讲解，我相信这还是能看懂的。; 1. 使用 g++ 编译 12$ g++ *.cpp *.h$ ./a.out g++ 后面跟用到了的 cpp h 文件 2. 使用 Clion 工具编译 直接点击 run,如下所示: 跟 C，Java 一样。 2. C++ 关键字下面表格描述了 C++ 中的关键字。这些关键字跟 C/Java 一样都不能作为常量名，变量名或其它标识符名称。 关键字 说明 关键字 说明 asm 允许在 C++ 程序中嵌入汇编代码 auto （自动，automatic）是存储类型标识符，表明变量”自动”具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。 bool bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。 break break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。 case 用于 switch 语句中，用于判断不同的条件类型。 namespace namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。 catch catch 和 try 语句一起用于异常处理。 new new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建 char char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ‘ 括起来。 operator operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。 class class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。 private private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。 const const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。 protected protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。 const_cast 该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 public public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类 continue continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是”继续循环”之意，不是 break（跳出）。 register register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。 default default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。 reinterpret_cast type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。 delete delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。 return return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。 do do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。 short short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。 double double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。 signed signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。 dynamic_cast dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。 sizeof 由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 sizeof 运算符获得该数据类型占用的字节数。 else else 紧跟在 if 后面，用于对 if 不成立的情况的选择。 static static（静态的）静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。静态变量或静态函数，只有本文件内的代码才可访问它，它的名字（变量名或函数名）在其它文件中不可见。因此也称为”文件作用域”。在 C++ 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private 类型的也不例外。 enum enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。 static_cast 该运算符把 expression 转换为 type-id 类型，但没有运行时类型检查来保证转换的安全性。 explicit explicit（显式的）的作用是”禁止单参数构造函数”被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。 struct struct（结构）类型，类似于 class 关键字，与 C 语言兼容（class 关键字是不与 C 语言兼容的），可以实现面向对象程序设计。 export 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。 switch switch（转换）类似于 if-else-if 语句，是一种多分枝语句。它提供了一种简洁的书写，并且能够生成效率更好的代码。但是，switch 后面的判断只能是int（char也可以，但char本质上也是一种int类型）。switch 语句最后的 default 分支是可选的。 extern extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。 template template（模板），C++ 中泛型机制的实现。 false false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。 this this 返回调用者本身的指针。 float float（浮点数），C++ 中的基本数据结构，精度小于 double。 throw throw（抛出）用于实现 C++ 的异常处理机制，可以通过 throw 关键字”抛出”一个异常。 for for 是 C++ 中的循环结构之一。 true true（真的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的非 0 值。 friend friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。 try try（尝试）用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理。 goto goto（转到），用于无条件跳转到某一标号处开始执行。 typedef 类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。 if if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。 typeid 指出指针或引用指向的对象的实际派生类型。 inline inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。 typename typename（类型名字）关键字告诉编译器把一个特殊的名字解释成一个类型。 int int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。 union union（联合），类似于 enum。不同的是 enum 实质上是 int 类型的，而 union 可以用于所有类型，并且其占用空间是随着实际类型大小变化的。 long long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。 unsigned unsigned（无符号），表明该类型是无符号数，和 signed 相反。 mutable mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。 using 表明使用 namespace。 virtual virtual（虚的），C++ 中用来实现多态机制。 void void（空的），可以作为函数返回值，表明不返回任何数据；可以作为参数，表明没有参数传入（C++中不是必须的）；可以作为指针使用。 volatile volatile（不稳定的）限定一个对象可被外部进程（操作系统、硬件或并发线程等）改变 wchar_t wchar_t 是宽字符类型，每个 wchar_t 类型占 2 个字节，16 位宽。汉字的表示就要用到 wchar_t。 4. 数据类型基本的内置类型 C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型： 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t (wchar_t 实际上的空间是和 short int 一样) 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 注意：不同系统会有所差异。 类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 到 18,446,744,073,709,551,615 float 4 个字节 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) double 8 个字节 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) long double 16 个字节 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 wchar_t 2 或 4 个字节 1 个宽字符 从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。 下面实例会输出您电脑上各种数据类型的大小。 123456789101112131415161718192021222324252627282930313233343536373839void test2() { println(\"C++\\t\\t\", \"**************基本数据类型 Size ***********\\n\"); println(\"bool\\t\\t\", \"所占字节数:\", sizeof(bool), \"\\t\\t最大值:\", (numeric_limits&lt;bool&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;bool&gt;::min)()); println(\"char\\t\\t\", \"所占字节数:\", sizeof(char), \"\\t\\t最大值:\", (numeric_limits&lt;char&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;char&gt;::min)()); println(\"unsigned char\\t\\t\", \"所占字节数:\", sizeof(unsigned char), \"\\t\\t最大值:\", (numeric_limits&lt;unsigned char&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;unsigned char&gt;::min)()); println(\"signed char\\t\\t\", \"所占字节数:\", sizeof(signed char), \"\\t\\t最大值:\", (numeric_limits&lt;signed char&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;signed char&gt;::min)()); println(\"int\\t\\t\", \"所占字节数:\", sizeof(int), \"\\t\\t最大值:\", (numeric_limits&lt;int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;int&gt;::min)()); println(\"unsigned int\\t\\t\", \"所占字节数:\", sizeof(unsigned int), \"\\t\\t最大值:\", (numeric_limits&lt;unsigned int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;unsigned int&gt;::min)()); println(\"signed int\\t\\t\", \"所占字节数:\", sizeof(signed int), \"\\t\\t最大值:\", (numeric_limits&lt;signed int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;signed int&gt;::min)()); println(\"short int\\t\\t\", \"所占字节数:\", sizeof(short int), \"\\t\\t最大值:\", (numeric_limits&lt;short int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;short int&gt;::min)()); println(\"unsigned short int\\t\\t\", \"所占字节数:\", sizeof(unsigned short int), \"\\t\\t最大值:\", (numeric_limits&lt;unsigned short int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;unsigned short int&gt;::min)()); println(\"signed short int\\t\\t\", \"所占字节数:\", sizeof(signed short int), \"\\t\\t最大值:\", (numeric_limits&lt;signed short int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;signed short int&gt;::min)()); println(\"long int\\t\\t\", \"所占字节数:\", sizeof(long int), \"\\t\\t最大值:\", (numeric_limits&lt;long int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;long int&gt;::min)()); println(\"signed long int\\t\\t\", \"所占字节数:\", sizeof(signed long int), \"\\t\\t最大值:\", (numeric_limits&lt;signed long int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;signed long int&gt;::min)()); println(\"unsigned long int\\t\\t\", \"所占字节数:\", sizeof(unsigned long int), \"\\t\\t最大值:\", (numeric_limits&lt;unsigned long int&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;unsigned long int&gt;::min)()); println(\"float\\t\\t\", \"所占字节数:\", sizeof(float), \"\\t\\t最大值:\", (numeric_limits&lt;float&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;float&gt;::min)()); println(\"double\\t\\t\", \"所占字节数:\", sizeof(double), \"\\t\\t最大值:\", (numeric_limits&lt;double&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;double&gt;::min)()); println(\"long double\\t\\t\", \"所占字节数:\", sizeof(long double), \"\\t\\t最大值:\", (numeric_limits&lt;long double&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;long double&gt;::min)()); println(\"wchar_t\\t\\t\", \"所占字节数:\", sizeof(wchar_t), \"\\t\\t最大值:\", (numeric_limits&lt;wchar_t&gt;::max)(), \"\\t\\t最小值:\", (numeric_limits&lt;wchar_t&gt;::min)());} 输出: 12345678910111213141516171819/** * bool 所占字节数:1 最大值:1 最小值:0 * char 所占字节数:1 最大值:127 最小值:-128 * unsigned char 所占字节数:1 最大值:255 最小值:0 * signed char 所占字节数:1 最大值:127 最小值:-128 * int 所占字节数:4 最大值:2147483647 最小值:-2147483648 * unsigned int 所占字节数:4 最大值:-1 最小值:0 * signed int 所占字节数:4 最大值:2147483647 最小值:-2147483648 * short int 所占字节数:2 最大值:32767 最小值:-32768 * unsigned short int 所占字节数:2 最大值:65535 最小值:0 * signed short int 所占字节数:2 最大值:32767 最小值:-32768 * long int 所占字节数:8 最大值:-1 最小值:0 * signed long int 所占字节数:8 最大值:-1 最小值:0 * unsigned long int 所占字节数:8 最大值:-1 最小值:0 * float 所占字节数:4 最大值:-2147483648 最小值:0 * double 所占字节数:8 最大值:-2147483648 最小值:0 * long double 所占字节数:16 最大值:-2147483648 最小值:0 * wchar_t 所占字节数:4 最大值:2147483647 最小值:-2147483648*/ typedef 声明 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： 123//格式: typedef type newname; //例子typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： 1feet distance; 枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum 跟 Java 语法差不多。枚举类型的一般形式为： 123456enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数]} 枚举变量; 如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。 例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。 12enum color { red, green, blue } c;c = blue; 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。 1enum color { red, green=5, blue }; 在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。 5. 变量类型变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。 下面我们将讲解如何定义、声明和使用各种类型的变量。 定义: 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： 12345678//格式：type variable_list;//在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。//例子:int i, j, k;char c, ch;float f, salary;double d; 变量声明: 变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 例子: 1234567891011121314151617181920//声明变量extern int a, b;extern int c;extern float f;void test3() {//变量定义 int a, b; int c; float f;//init a = 10; b = 20; c = a + b; println(\"声明变量\\t\", \"a + b=\", c); f = 10 / 3; println(\"声明变量\\t\", \"10/3=\", f);} 输出: 声明变量 a + b=30声明变量 10/3=3 6. 变量作用域作用域是程序的一个区域，一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 我们将在后续的小节中学习什么是函数和参数。本小节我们先来讲解什么是局部变量和全局变量。 局部变量: 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量： 12345678void test4() { //局部变量声明 int i = 10, j = 20; int c; c = i * j; println(\"局部变量:\", \"i * j=\", c);} 输出: 局部变量:i * j=200 全局变量: 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。 全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量： 123456789101112131415161718int g, l = 20;//声明全局变量void test4() { //局部变量声明 int i = 10, j = 10; int c; c = i * j; println(\"局部变量:\", \"i * j=\", c); //赋值给全局变量 g = (int)i / j; println(\"全局变量:\", \"i / j=\", g); println(\"全局变量:\", \"l =\", l); l = 100;//重新赋值给全局变量 l println(\"全局变量:\", \"l =\", l);} 输出: 局部变量:i * j=100全局变量:i / j=1全局变量:l =20全局变量:l =100 初始化局部变量和全局变量: 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。 7. 常量常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 整数常量: 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 下面列举几个整数常量的实例： 12345678910111213212 // 合法的215u // 合法的0xFeeL // 合法的078 // 非法的：8 不是八进制的数字032UU // 非法的：不能重复后缀 85 // 十进制0213 // 八进制 0x4b // 十六进制 30 // 整数 30u // 无符号整数 30l // 长整数 30ul // 无符号长整数 浮点常量: 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 下面列举几个浮点常量的实例： 123453.14159 // 合法的 314159E-5L // 合法的 510E // 非法的：不完整的指数210f // 非法的：没有小数或指数.e55 // 非法的：缺少整数或分数 布尔常量: 布尔常量共有两个，它们都是标准的 C++ 关键字： true 值代表真。 false 值代表假。 我们不应把 true 的值看成 1，把 false 的值看成 0。 字符常量: 字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。 字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码： 转义序列 含义 \\ \\ 字符 ' ‘ 字符 &quot; “ 字符 ? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 1234void test5() { //字符常量 println(\"字符常量\", \"\\tC\\n+\\n+\\n\");} 输出: 字符常量 C++ 字符串常量: 字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 您可以使用空格做分隔符，把一个很长的字符串常量进行分行。 下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。 1234567\"hello, World\"\"hello, \\World\"\"hello, \" \"W\" \"orld\" 定义常量: 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 1234567891011121314//定义常量 const,#define#define NAME \"DevYK\"#define Blog \"https://www.devyk.top\"const string _NAME = \"DevYK\", _Blog = \"https://www.devyk.top\";void test5() { //打印定义的常量 println(\"#define 定义常量:\", NAME \"\\t\" Blog); //const 定义的常量 const int length = 10, width = 20, height = 30; cout &lt;&lt; \"const 定义的常量\\t\" &lt;&lt; _NAME &lt;&lt; \"\\t\" + _Blog &lt;&lt; endl; println(\"const 定义常量\\t\", \"求 width * height * length = \", length * width * height);} 输出: define 定义常量:DevYK https://www.devyk.topconst 定义的常量 DevYK https://www.devyk.topconst 定义常量 求 width * height * length = 6000 8. 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。 修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。 12unsigned x;unsigned int y; 为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序： 1234567891011void test6() { //演示有符号和无符号整数之间的差别 short int i; int k; short unsigned int j; j = 50000; i = j; k = j; cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl;} 输出: -15536 50000 50000 上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。 9. 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 auto 存储类: 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。 根据初始化表达式自动推断被声明的变量的类型，如： 1234auto f=3.14; //doubleauto s(\"hello\"); //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型 register 存储类: register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。 123{ register int miles;} 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 static 存储类: static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。 123456789101112131415161718192021//函数声明void test7_fun(void);//声明全局变量static int valueCount = 5;void test7() { //1. while(valueCount--){ test7_fun(); }}void test7_fun() { //使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static int value = 5; value++; cout &lt;&lt; \"变量 value 为：\" &lt;&lt; value &lt;&lt; endl; cout &lt;&lt; \"变量 valueCount 为：\" &lt;&lt; valueCount &lt;&lt; endl;} 输出: 变量 value 为：6变量 valueCount 为：4变量 value 为：7变量 valueCount 为：3变量 value 为：8变量 valueCount 为：2变量 value 为：9变量 valueCount 为：1变量 value 为：10变量 valueCount 为：0 extern 存储类: extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件: main.cpp 123456//extern 存储值extern void value_extern();void test7() { value_extern();} 第二个文件：main_1.cpp 123456#include &lt;iostream&gt;using namespace std;void value_extern(void){ cout &lt;&lt; \"value_extern 执行了\" &lt;&lt;endl;} 输出: value_extern 执行了 10. 运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 本小节将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。 算术运算符: 下表显示了 C++ 支持的算术运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 1234567891011121314151617181920212223242526void test8() { //算术运算符 int a = 21; int b = 10; int c; c = a + b; cout &lt;&lt; \"Line 1 - c 的值是 \" &lt;&lt; c &lt;&lt; endl; c = a - b; cout &lt;&lt; \"Line 2 - c 的值是 \" &lt;&lt; c &lt;&lt; endl; c = a * b; cout &lt;&lt; \"Line 3 - c 的值是 \" &lt;&lt; c &lt;&lt; endl; c = a / b; cout &lt;&lt; \"Line 4 - c 的值是 \" &lt;&lt; c &lt;&lt; endl; c = a % b; cout &lt;&lt; \"Line 5 - c 的值是 \" &lt;&lt; c &lt;&lt; endl; int d = 10; // 测试自增、自减 c = d++; //先赋值，再自增 cout &lt;&lt; \"Line 6 - c 的值是 \" &lt;&lt; c &lt;&lt; \" \" &lt;&lt; d &lt;&lt; endl; d = 12; // 重新赋值 c = d--; //先赋值，再自减 cout &lt;&lt; \"Line 7 - c 的值是 \" &lt;&lt; c &lt;&lt; \" \" &lt;&lt; d &lt;&lt; endl;} 输出: Line 1 - c 的值是 31Line 2 - c 的值是 11Line 3 - c 的值是 210Line 4 - c 的值是 2Line 5 - c 的值是 1Line 6 - c 的值是 10 11Line 7 - c 的值是 12 11 关系运算符: 下表显示了 C++ 支持的关系运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &gt; B) 不为真。 &lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &lt; B) 为真。 &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &gt;= B) 不为真。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &lt;= B) 为 123456789101112131415161718192021222324252627void test8() { //关系运算符 if (a == b) { cout &lt;&lt; \"Line 1 - a 等于 b\" &lt;&lt; endl; } else { cout &lt;&lt; \"Line 1 - a 不等于 b\" &lt;&lt; endl; } if (a &lt; b) { cout &lt;&lt; \"Line 2 - a 小于 b\" &lt;&lt; endl; } else { cout &lt;&lt; \"Line 2 - a 不小于 b\" &lt;&lt; endl; } if (a &gt; b) { cout &lt;&lt; \"Line 3 - a 大于 b\" &lt;&lt; endl; } else { cout &lt;&lt; \"Line 3 - a 不大于 b\" &lt;&lt; endl; } /* 改变 a 和 b 的值 */ a = 5; b = 20; if (a &lt;= b) { cout &lt;&lt; \"Line 4 - a 小于或等于 b\" &lt;&lt; endl; } if (b &gt;= a) { cout &lt;&lt; \"Line 5 - b 大于或等于 a\" &lt;&lt; endl; }} 输出: Line 1 - a 不等于 bLine 2 - a 不小于 bLine 3 - a 大于 bLine 4 - a 小于或等于 bLine 5 - b 大于或等于 a 逻辑运算符: 下表显示了 C++ 支持的关系逻辑运算符。 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 &amp;&amp; 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A &amp;&amp; B) 为假。 || 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A &amp;&amp; B) 为真。 12345678910111213141516171819202122void test8() { //逻辑运算符 if (a &amp;&amp; b) { cout &lt;&lt; \"Line 1 - 条件为真\" &lt;&lt; endl; } if (a || b) { cout &lt;&lt; \"Line 2 - 条件为真\" &lt;&lt; endl; } /* 改变 a 和 b 的值 */ a = 0; b = 10; if (a &amp;&amp; b) { cout &lt;&lt; \"Line 3 - 条件为真\" &lt;&lt; endl; } else { cout &lt;&lt; \"Line 4 - 条件不为真\" &lt;&lt; endl; } if (!(a &amp;&amp; b)) { cout &lt;&lt; \"Line 5 - 条件为真\" &lt;&lt; endl; } } 输出: Line 1 - 条件为真Line 2 - 条件为真Line 4 - 条件不为真Line 5 - 条件为真 位运算符: 位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示： p q p &amp; q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 -—————- A&amp;B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 &amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A &amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A | B) 将得到 61，即为 0011 1101 ^ 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 (A ^ B) 将得到 49，即为 0011 0001 ~ 二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 &lt;&lt; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A &lt;&lt; 2 将得到 240，即为 1111 0000 &gt;&gt; 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 A &gt;&gt; 2 将得到 15，即为 0000 1111 1234567891011121314151617181920212223242526void test8() { println(\"\\n\\n\\n\", \"位运算符\"); //位运算符 unsigned int aW = 60; // 60 = 0011 1100 unsigned int bW = 13; // 13 = 0000 1101 int cW = 0; cW = aW &amp; bW; // 12 = 0000 1100 cout &lt;&lt; \"Line 1 - cW 的值是 \" &lt;&lt; cW &lt;&lt; endl; cW = aW | bW; // 61 = 0011 1101 cout &lt;&lt; \"Line 2 - cW 的值是 \" &lt;&lt; cW &lt;&lt; endl; cW = aW ^ bW; // 49 = 0011 0001 cout &lt;&lt; \"Line 3 - cW 的值是 \" &lt;&lt; cW &lt;&lt; endl; cW = ~aW; // -61 = 1100 0011 cout &lt;&lt; \"Line 4 - cW 的值是 \" &lt;&lt; cW &lt;&lt; endl; cW = aW &lt;&lt; 2; // 240 = 1111 0000 cout &lt;&lt; \"Line 5 - cW 的值是 \" &lt;&lt; cW &lt;&lt; endl; cW = aW &gt;&gt; 2; // 15 = 0000 1111 cout &lt;&lt; \"Line 6 - cW 的值是 \" &lt;&lt; cW &lt;&lt; endl;} 输出: Line 1 - cW 的值是 12Line 2 - cW 的值是 61Line 3 - cW 的值是 49Line 4 - cW 的值是 -61Line 5 - cW 的值是 240Line 6 - cW 的值是 15 赋值运算符: 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移且赋值运算符 C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2 &gt;&gt;= 右移且赋值运算符 C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2 &amp;= 按位与且赋值运算符 C &amp;= 2 等同于 C = C &amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 1234567891011121314151617181920212223242526272829303132333435363738void test8() { println(\"\\n\\n\\n\", \"赋值运算符\"); a = 50; //赋值运算符 c = a; cout &lt;&lt; \"Line 1 - = 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c += a; cout &lt;&lt; \"Line 2 - += 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c -= a; cout &lt;&lt; \"Line 3 - -= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c *= a; cout &lt;&lt; \"Line 4 - *= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c /= a; cout &lt;&lt; \"Line 5 - /= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c = 200; c %= a; cout &lt;&lt; \"Line 6 - %= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c &lt;&lt;= 2; cout &lt;&lt; \"Line 7 - &lt;&lt;= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c &gt;&gt;= 2; cout &lt;&lt; \"Line 8 - &gt;&gt;= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c &amp;= 2; cout &lt;&lt; \"Line 9 - &amp;= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c ^= 2; cout &lt;&lt; \"Line 10 - ^= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl; c |= 2; cout &lt;&lt; \"Line 11 - |= 运算符实例，c 的值 = : \" &lt;&lt; c &lt;&lt; endl;} 输出: Line 1 - = 运算符实例，c 的值 = : 50Line 2 - += 运算符实例，c 的值 = : 100Line 3 - -= 运算符实例，c 的值 = : 50Line 4 - *= 运算符实例，c 的值 = : 2500Line 5 - /= 运算符实例，c 的值 = : 50Line 6 - %= 运算符实例，c 的值 = : 0Line 7 - &lt;&lt;= 运算符实例，c 的值 = : 0Line 8 - &gt;&gt;= 运算符实例，c 的值 = : 0Line 9 - &amp;= 运算符实例，c 的值 = : 0Line 10 - ^= 运算符实例，c 的值 = : 2Line 11 - |= 运算符实例，c 的值 = : 2 其它: 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -&gt;（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 &amp; 指针运算符 &amp; 返回变量的地址。例如 &a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 11. 循环C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 循环控制语句: 循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 C++ 提供了下列的控制语句。点击链接查看每个语句的细节。 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 死循环: 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。 12345678910111213#include &lt;iostream&gt;using namespace std; int main (){ //也可以使用 while (true){} for( ; ; ) { printf(\"This loop will run forever.\\n\"); } return 0;} 当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 注意：您可以按 Ctrl + C 键终止一个无限循环。 例子: 1234567891011121314151617181920212223242526void test9() { //for 循环 for (int i = 0; i &lt; 10; ++i) { if (i % 2 == 1) { cout &lt;&lt; i &lt;&lt; \"==\" &lt;&lt; i % 2 &lt;&lt; endl; //跳出当前循环，继续下一次操作 continue; } if (i == 8) { cout &lt;&lt; \"跳出循环\" &lt;&lt; endl; break; } cout &lt;&lt; \"遍历中...\" &lt;&lt; \"==\" &lt;&lt; i &lt;&lt; endl; } for (int j = 0; j &lt; 3; ++j) { if (j == 1) { cout &lt;&lt; \"j 跳出循环\" &lt;&lt; endl; return; } cout &lt;&lt; \"j 就遍历中...\" &lt;&lt; \"==\" &lt;&lt; j &lt;&lt; endl; }}; 输出: 遍历中…==01==1遍历中…==23==1遍历中…==45==1遍历中…==67==1跳出循环j 就遍历中…==0j 跳出循环 12. 判断判断语句: C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 三元运算符: 我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： 12345678void test10() { int i = 10; //格式：Exp1 ? Exp2 : Exp3; //其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。 //? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的 //值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。 i = i == 10 ? i = 9 : i; cout &lt;&lt; i &lt;&lt; endl;} 输出: 9 13. 函数函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 定义函数: 1234return_type function_name( parameter list ){ body of the function} 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 例子: 12345678910111213// 函数返回两个数中较大的那个数int max(int num1, int num2) { // 局部变量声明 int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } 函数声明: 1234//格式: return_type function_name( parameter list );//例子:int max(int num1, int num2);int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。 调用函数: 创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std; // 函数声明int max(int num1, int num2); int main (){ // 局部变量声明 int a = 100; int b = 200; int ret; // 调用函数来获取最大值 ret = max(a, b); cout &lt;&lt; \"Max value is : \" &lt;&lt; ret &lt;&lt; endl; return 0;} // 函数返回两个数中较大的那个数int max(int num1, int num2) { // 局部变量声明 int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } 输出: Max value is : 200 函数参数: 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有三种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。 参数的默认值: 当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。 这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std; int sum(int a, int b=20){ int result; result = a + b; return (result);} int main (){ // 局部变量声明 int a = 100; int b = 200; int result; // 调用函数来添加值 result = sum(a, b); cout &lt;&lt; \"Total value is :\" &lt;&lt; result &lt;&lt; endl; // 再次调用函数 result = sum(a); cout &lt;&lt; \"Total value is :\" &lt;&lt; result &lt;&lt; endl; return 0;} 输出: Total value is :300Total value is :120 14. 数学运算在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。您可以在程序中引用这些函数。 C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。 为了利用这些函数，您需要引用数学头文件 。 序号 函数 &amp; 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数。 下面是一个关于数学运算的简单实例： 123456789101112131415161718192021222324void test11() { //数字定义 short s = 10; int i = -1000; long l = 100000; float f = 250.41; double d = 200.45; //数学运算 cout &lt;&lt; \"sin(d) :\" &lt;&lt; sin(d) &lt;&lt; endl; cout &lt;&lt; \"abs(i) :\" &lt;&lt; abs(i) &lt;&lt; endl; cout &lt;&lt; \"floor(d) :\" &lt;&lt; floor(d) &lt;&lt; endl; cout &lt;&lt; \"sqrt(f) :\" &lt;&lt; sqrt(f) &lt;&lt; endl; cout &lt;&lt; \"pow( d, 2) :\" &lt;&lt; pow(d, 2) &lt;&lt; endl; //生成随机数之前必须先调用 srand() 函数。 int a; srand((unsigned) time(NULL)); //生成 5 个随机数 for (int j = 0; j &lt; 5; ++j) { a = rand(); cout &lt;&lt; \"随机数：\" &lt;&lt; a &lt;&lt; endl; }} 输出: sin(d) :-0.574448abs(i) :1000floor(d) :200sqrt(f) :15.8243pow( d, 2) :40180.2随机数：1753472662随机数：696942453随机数：1135996833随机数：1569150401随机数：1611604447 15. 数组C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。 声明数组: 在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： 1234//格式:type arrayName [ arraySize ];//这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。//例子:double balance[10]; 初始化数组: 在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示： 123double d[5] = {1.0, 2.0, 3.0, 4.0, 5.0};//修改数组d[4] = 50.0; 上面的意思是先定义一个大小为 5 的数组，然后在修改索引为 4 的数值，以下是上面的图形表示: 访问数组元素: 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： 1double temp = d[4]; 上面的语句将把数组中第 4 个元素的值赋给 temp 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组： 12345678910111213void test12() { int n[100]; //包含 100 个整数 for (int i = 0; i &lt; 100; ++i) { n[i] = i; } //setw 可以理解为 输出的间隔为 10 个字符 cout &lt;&lt; \"Element\" &lt;&lt; setw(10) &lt;&lt; \"value\" &lt;&lt; setw(10) &lt;&lt; n[20] &lt;&lt; endl; // 输出数组中每个元素的值 for (int j = 0; j &lt; 100; j++) { cout &lt;&lt; \"Element\" &lt;&lt; setw(10) &lt;&lt; \"value\" &lt;&lt; setw(10) &lt;&lt; n[j] &lt;&lt; endl; }} 输出: Element value 20Element value 0Element value 1Element value 2Element value 3Element value 4Element value 5Element value 6Element value 7Element value 8Element value 9Element value 10Element value 11Element value 12 … 其它: 在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念： 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 16. 字符串C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 C 风格字符串: 在上一篇文章中我们学习了 C 中定义字符串，这里我们在复习下，看下面示例: 123char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};//等同于如下定义char greeting[] = \"Hello\"; 以下是 C/C++ 中定义的字符串的内存表示： 其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\\0’ 放在字符串的末尾。让我们尝试输出上面的字符串： 其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\\0’ 放在字符串的末尾。 例子: 1234void test13() { char message[10] = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '\\0'}; cout &lt;&lt; message &lt;&lt; endl;} 输出: 123456789 C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings: 序号 函数 &amp; 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 下面的实例使用了上述的一些函数： 1234567891011121314void test13() { char ctr1[20] = \"网名:\"; char ctr2[50] = \"个人Blog地址:\"; int ctr1Len, ctr2Len; strcat(ctr1, \"DevYK\"); strcat(ctr2, \"https://www.devyk.top\"); cout &lt;&lt; \"ctr1\\t\" &lt;&lt; ctr1 &lt;&lt; \"\\n\" &lt;&lt; \"ctr2\\t\" &lt;&lt; ctr2 &lt;&lt; endl; ctr1Len = strlen(ctr1); ctr2Len = strlen(ctr2); cout &lt;&lt; \"ctr1Len\" &lt;&lt; setw(10) &lt;&lt; ctr1Len &lt;&lt; \"\\nctr2Len\" &lt;&lt; setw(10) &lt;&lt; ctr2Len &lt;&lt; endl;} 输出: ctr1 网名:DevYKctr2 个人Blog地址:https://www.devyk.topctr1Len 12ctr2Len 38 C++ 中的 String: C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例： 现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;int main(){ test13(); return 0;}void test13() { printf(\"\\n\\n\\nstring 类型字符串\"); string meg[10] = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}; cout &lt;&lt; meg &lt;&lt; endl; //定义 string 变量 string str1add, str2add; int str1Len, str2Len; //init string str1 = \"网名:\"; string str2 = \"个人Blog地址:\"; //追加到 str 末尾 str1add = str1.append(\"DevYK\"); str2add = str2.append(\"https://www.devyk.top\"); cout &lt;&lt; \"str1\\t\" &lt;&lt; str1 &lt;&lt; \"\\n\" &lt;&lt; \"str2\\t\" &lt;&lt; str2 &lt;&lt; endl; str1Len = str1add.length(); str2Len = str2add.size(); cout &lt;&lt; \"str1Len\" &lt;&lt; setw(10) &lt;&lt; str1Len &lt;&lt; \"\\nstr2Len\" &lt;&lt; setw(10) &lt;&lt; str2Len &lt;&lt; endl;} 输出: string 类型字符串0x7ffee9b98550str1 网名:DevYKstr2 个人Blog地址:https://www.devyk.topstr1Len 12str2Len 38 17. 指针学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： 12345void test14() { int var1; char var2[10]; cout &lt;&lt; \"var1 变量的地址\\t\" &lt;&lt; &amp;var1 &lt;&lt; \"\\nvar2 变量的地址\\t\" &lt;&lt; &amp;var2 &lt;&lt; endl;} 输出: var1 变量的地址 0x7ffeeef58698var2 变量的地址 0x7ffeeef5869e 通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。 指针是什么？ 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： 1type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 指针的使用: 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： 12345678910void test14() { int var = 20; //实际变量的声明 int *ip; //将 var 地址赋值给 ip 指针变量中 ip = &amp;var; cout &lt;&lt; \"指针变量中存储的地址\\t\" &lt;&lt; ip &lt;&lt; endl; cout &lt;&lt; \"指针变量中的地址\\t\" &lt;&lt; ip &lt;&lt; endl; cout &lt;&lt; \"指针变量中地址对应的值\\t\" &lt;&lt; *ip &lt;&lt; endl;} 输出: 指针变量中存储的地址 0x7ffeeef58694指针变量中的地址 0x7ffeeef58694指针变量中地址对应的值 20 18. 引用引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用 VS 指针: 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 创建引用: 1int i = 17; 我们可以为 i 声明引用变量，如下所示: 12int&amp; r = i;double&amp; s = d; 在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用： 1234567891011121314151617void test15() { //声明变量 int a = 10, b = 20; //声明引用变量 int &amp;i = a; int &amp;j = b; cout &lt;&lt; \"a == \" &lt;&lt; a &lt;&lt; \"\\t &amp;i ==\" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"b == \" &lt;&lt; b &lt;&lt; \"\\t &amp;j ==\" &lt;&lt; j &lt;&lt; endl; a = 5, b = 6; cout &lt;&lt; \"a == \" &lt;&lt; a &lt;&lt; \"\\t &amp;i ==\" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"b == \" &lt;&lt; b &lt;&lt; \"\\t &amp;j ==\" &lt;&lt; j &lt;&lt; endl;} 输出: a == 10 &amp;i ==10b == 20 &amp;j ==20a == 5 &amp;i ==5b == 6 &amp;j ==6 引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 19. 日期 &amp; 时间C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： 1234567891011struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时} 下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。 序号 函数 &amp; 描述 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 当前日期: 123456789101112131415void test16() { //获取系统的时间 time_t now = time(0); //把 now 转为字符串 char *curTime = ctime(&amp;now); //把 now 转为 tm 结构 tm *gmtm = gmtime(&amp;now); cout &lt;&lt; \"当前时间\\t\" &lt;&lt; curTime &lt;&lt; endl; curTime = asctime(gmtm); cout &lt;&lt; \"UTC 日期和时间\\t\" &lt;&lt; curTime &lt;&lt; endl;} 输出: 当前时间 Sun Jan 5 22:11:15 2020 UTC 日期和时间 Sun Jan 5 14:11:15 2020 使用结构 tm 格式化时间: tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。 在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。 12345678910111213void test16() { //基于当前系统的日期/时间 cout &lt;&lt; \"1970 到目前经过的秒数:\" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now); //输出 tm 结构的各个组成部分 cout &lt;&lt; \"年: \" &lt;&lt; 1990 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; \"月: \" &lt;&lt; 1 + ltm-&gt;tm_mon &lt;&lt; endl; cout &lt;&lt; \"日: \" &lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; \"时: \" &lt;&lt; ltm-&gt;tm_hour &lt;&lt; endl; cout &lt;&lt; \"分: \" &lt;&lt; ltm-&gt;tm_min &lt;&lt; endl; cout &lt;&lt; \"秒: \" &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;} 输出: 1970 到目前经过的秒数:1578233475年: 2110月: 1日: 5时: 22分: 11秒: 15 20. 输入输出C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。 C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 I/O 库头文件 下列的头文件在 C++ 编程中很重要。 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输入流 cout: 预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的。 标准输入流 cin: 预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的。 标准错误流 cerr: 预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 cerr 也是与流插入运算符 &lt;&lt; 结合使用的。 标准日志流 clog: 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。 clog 也是与流插入运算符 &lt;&lt; 结合使用的。 例子: 1234567891011121314151617181920void test17() { //1. 标准输出流 cout char str[] = \"Hello World\"; cout &lt;&lt; \"值为:\" &lt;&lt; str &lt;&lt; endl; //2. 标准输入流 cin char name[10]; cout &lt;&lt; \"请输入你的名称: \"; cin &gt;&gt; name; cout &lt;&lt; \"你的名称是：\" &lt;&lt; name &lt;&lt; endl;// 请输入你的名称: DevYK// 你的名称是：DevYK //3. 标准错误流 cerr char errStr[] = \"Read Error\"; cerr &lt;&lt; \"error message：\" &lt;&lt; errStr &lt;&lt; endl; //输出为报红的:error message：Read Error //4. 标准日志流 clog char logStr[] = \"out Log\"; clog &lt;&lt; \"Debug Log：\" &lt;&lt; logStr &lt;&lt; endl; // 输出为报红的 Debug Logout Log} 输出: 21. 数据结构C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。 定义结构: 为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： 1234567struct type_name {member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..} object_names; type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 Movies，变量为 movies： 12345//定义结构struct Movies { char title[10]; char address[30];}movies; 访问结构成员: 为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。 下面的实例演示了结构的用法： 1234567891011121314151617181920212223//定义结构struct Movies { char title[10]; char address[30];};void test18() { //定义结构体变量 Movies movieA, movieB; //movieA 详述 strcpy(movieA.title, \"叶问4\"); strcpy(movieA.address, \"china\"); //movieB 详述 strcpy(movieB.title, \"战狼2\"); strcpy(movieB.address, \"china\"); //输出电影信息 cout &lt;&lt; movieA.title &lt;&lt; \"\\t\" &lt;&lt; movieA.address &lt;&lt; endl; cout &lt;&lt; movieB.title &lt;&lt; \"\\t\" &lt;&lt; movieB.address &lt;&lt; endl;} 输出: 叶问4 china战狼2 china 结构体作为函数参数: 您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量： 12345678910111213141516171819202122232425262728293031//定义结构struct Movies { char title[10]; char address[30];};void movieInfo(struct Movies movie);void test18() { //定义结构体变量 Movies movieA, movieB; //movieA 详述 strcpy(movieA.title, \"叶问4\"); strcpy(movieA.address, \"china\"); //movieB 详述 strcpy(movieB.title, \"战狼2\"); strcpy(movieB.address, \"china\"); //将结构体作为函数参数传递 movieInfo(movieA); movieInfo(movieB);}void movieInfo(struct Movies movie) { //输出电影信息 cout &lt;&lt; movie.title &lt;&lt; \"\\t\" &lt;&lt; movie.address &lt;&lt; endl;} 输出: 叶问4 china战狼2 china 指针结构的指针: 您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： 1struct Movies *struct_pointer; 现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示： 1struct_pointer = &amp;Movies; 为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示： 1struct_pointer-&gt;title; 让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念： 123456789101112131415161718192021222324252627282930313233//定义结构struct Movies { char title[10]; char address[30];}movies;void movieInfo(struct Movies *movie);void test18() { //定义结构体变量 Movies movieA, movieB; //movieA 详述 strcpy(movieA.title, \"叶问4\"); strcpy(movieA.address, \"china\"); //movieB 详述 strcpy(movieB.title, \"战狼2\"); strcpy(movieB.address, \"china\"); //将结构体作为指针传递 movieInfo(&amp;movieA); movieInfo(&amp;movieB);}void movieInfo(struct Movies *movie) { //输出电影信息 // 为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符 cout &lt;&lt; movie-&gt;title &lt;&lt; \"\\t\" &lt;&lt; movie-&gt;address &lt;&lt; endl;} 输出: 叶问4 china战狼2 china 22. 类 &amp; 对象C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。 类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。 类定义: 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们创建一个 .h 文件 使用关键字 *class** 定义 Person 数据类型，如下所示： 123456789101112131415161718192021222324252627//定义了一个 Person ,跟 Java class 差不多class Person {public: //公共的属性 Person(); //空参 ~Person(); //Person 销毁执行 Person(char *name, char *gen, int age); //有参构造 //成员变量 char *name; char *gen; int age; //函数 void setName(char *name); char *getName(); void setGen(char *gen); char *getGen(); void setAge(int age); int getAge();}; 关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected。 定义 C++ 对象: 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Person的两个对象： 1Person personTemp;//声明 personTemp 类型为 Person 访问数据成员: 类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//1. person.h 文件中定义 Person 对象//定义了一个 Person ,跟 Java class 差不多class Person {public: //公共的属性 Person(); ~Person(); Person(char *name, char *gen, int age); char *name; char *gen; int age; void setName(char *name); char *getName(); void setGen(char *gen); char *getGen(); void setAge(int age); int getAge();};//2. person.cpp Person::Person(char *name, char *gen, int age) { this-&gt;name = name; this-&gt;age = age; this-&gt;gen = gen;}Person::~Person() { cout &lt;&lt; \"Person 销毁\" &lt;&lt; endl;}Person::Person() { cout &lt;&lt; \"执行 Person 空参构造函数\" &lt;&lt; endl;}void Person::setAge(int age) { this-&gt;age = age;}void Person::setName(char *name) { this-&gt;name = name;}void Person::setGen(char *gen) { this-&gt;gen = gen;}char *Person::getName() { cout &lt;&lt; \"DevYK getName\" &lt;&lt; endl; return this-&gt;name;}char *Person::getGen() { return this-&gt;gen;}int Person::getAge() { return this-&gt;age;}//3. 测试void test19() { //栈里面定义的当该方法执行完就会回收掉 Person 对象 Person personTemp; personTemp.setGen(\"男\"); personTemp.setName(\"小明\"); personTemp.setAge(18); cout &lt;&lt; personTemp.getName() &lt;&lt; \"\\t\" &lt;&lt; personTemp.getGen() &lt;&lt; \"\\t\" &lt;&lt; personTemp.getAge() &lt;&lt; endl; //初始化 Person 对象，在堆内存中，如果不主动清理 那么就会造成 内存泄漏 Person *person = new Person(\"DevYK\", \"男\", 28); cout &lt;&lt; person-&gt;getName() &lt;&lt; \"\\t\" &lt;&lt; person-&gt;getGen() &lt;&lt; \"\\t\" &lt;&lt; person-&gt;getAge() &lt;&lt; endl; //释放 person 堆内存 delete person;} 输出: 执行 Person 空参构造函数小明 男 18DevYK 男 28Person 销毁Person 销毁 需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。 类 &amp; 对象详解: 到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 &amp; 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的。 23. 继承面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。 基类 &amp; 派生类: 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下： 1class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 12345678910111213141516171819202122232425262728293031//1. 定义基类class SuperMan {public: ~SuperMan(); char *superName; void setSuperName(char *superName); char *getSuperName();};//2. 定义子类class DevYK : public SuperMan {public: DevYK(); ~DevYK(); char *getSupName();};//3. 测试void test20() { //子类 DevYK *devYkTemp = new DevYK(); //父类set Name devYkTemp-&gt;setSuperName(\"superMan\"); //子类获取 cout &lt;&lt; \"单继承:\" &lt;&lt; devYkMoreTemp-&gt;getPersonName();} 指针类型的访问需要以 “-&gt;” 形式来访问 输出: 执行 DevYK 空参构造函数 单继承:superMan 访问控制和继承: 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 我们可以根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 多继承: 多继承即一个子类可以有多个父类，它继承了多个父类的特性。 C++ 类可以从多个类继承成员，语法如下： 1234class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…{&lt;派生类类体&gt;}; 其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//1. 定义基类 Personclass Person {public: //公共的属性 Person(); ~Person(); Person(char *name, char *gen, int age); char *name; char *gen; int age; void setName(char *name); char *getName(); void setGen(char *gen); char *getGen(); void setAge(int age); int getAge();};//2. 定义基类 SuperManclass SuperMan {public: ~SuperMan(); char *superName; void setSuperName(char *superName); char *getSuperName();};//3. 派生类/** * 继承关系 * 多继承 */class DevYK : public Person, public SuperMan {public: DevYK(char *name, int age) : Person(name, \"nan\", age) {}; int length; DevYK(); ~DevYK(); char *getPersonName(); char *getSupName(); void setLength(int len); int getLength(); char *getName();};//4. 测试void test20() {// //子类 DevYK *devYkTemp = new DevYK(); //父类set Name devYkTemp-&gt;setName(\"DevYK\"); //子类获取 cout &lt;&lt; \"单继承 Person Name:\" &lt;&lt; devYkTemp-&gt;getPersonName() &lt;&lt; endl; //多继承 DevYK *devYkMoreTemp = new DevYK(); //给父类 Person set Name devYkMoreTemp-&gt;setName(\"DevYK\"); //给父类 Super set Name devYkMoreTemp-&gt;setSuperName(\"superMan\"); //子类获取 cout &lt;&lt; \"多继承 Person Name:\" &lt;&lt; devYkMoreTemp-&gt;getPersonName()&lt;&lt; endl; cout &lt;&lt; \"多继承 SuperMan Name:\" &lt;&lt; devYkMoreTemp-&gt;getSupName() &lt;&lt; endl; //释放内存 delete devYkTemp, devYkMoreTemp;} 输出: 执行 Person 空参构造函数执行 DevYK 空参构造函数单继承 Person Name:DevYK执行 Person 空参构造函数执行 DevYK 空参构造函数多继承 Person Name:DevYK多继承 SuperMan Name:superManDevYK 销毁SuperMan 销毁Person 销毁 24. 重载运算符和重载函数C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。 函数重载: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//1. 在 .h 文件中定义 DevYK 对象class DevYK {public: int length; DevYK(); ~DevYK(); void setLength(int len); int getLength();};//2. .cpp 实现DevYK::DevYK() { cout &lt;&lt; \"执行 DevYK 空参构造函数\" &lt;&lt; endl;}DevYK::~DevYK() { cout &lt;&lt; \"DevYK 销毁\" &lt;&lt; endl;}void DevYK::setLength(int len) { this-&gt;length = len;}int DevYK::getLength() { return this-&gt;length;}//3. 测试void test21() { //1.运算符重载 DevYK devYkA; DevYK devYkB; DevYK devYkC; //进行初始化赋值 devYkA.setLength(500); devYkB.setLength(20); cout &lt;&lt; \"devYkA length ： \" &lt;&lt; devYkA.getLength() &lt;&lt; endl; cout &lt;&lt; \"devYkB length ： \" &lt;&lt; devYkB.getLength() &lt;&lt; endl;}; 输出: devYkA length ： 500devYkB length ： 20 运算符重载: 您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 1DevYK operator+(const DevYK &amp;b); 下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//1. 在 .h 文件中定义 DevYK 对象class DevYK {public: int length; DevYK(); ~DevYK(); void setLength(int len); int getLength(); DevYK operator+(const DevYK &amp;b);};//2. .cpp 实现DevYK::DevYK() { cout &lt;&lt; \"执行 DevYK 空参构造函数\" &lt;&lt; endl;}DevYK::~DevYK() { cout &lt;&lt; \"DevYK 销毁\" &lt;&lt; endl;}void DevYK::setLength(int len) { this-&gt;length = len;}int DevYK::getLength() { return this-&gt;length;}// 重载 + 运算符，用于把两个 Box 对象相加class DevYK DevYK::operator+(const class DevYK &amp;b) { DevYK devYk; devYk.length = this-&gt;length + b.length; return devYk;}//3. 测试:void test21() { //1.运算符重载 DevYK devYkA; DevYK devYkB; DevYK devYkC; //进行初始化赋值 devYkA.setLength(500); devYkB.setLength(20); cout &lt;&lt; \"devYkA length ： \" &lt;&lt; devYkA.getLength() &lt;&lt; endl; cout &lt;&lt; \"devYkB length ： \" &lt;&lt; devYkB.getLength() &lt;&lt; endl; devYkC = devYkA + devYkB; cout &lt;&lt; \"DevYK 运算符重载 = \" &lt;&lt; devYkC.getLength() &lt;&lt; endl;}; 输出: devYkA length ： 500devYkB length ： 20 DevYK 运算符重载 = 520 25. 多态多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 下面的实例中，基类 Shape 被派生为两个类，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//1. 定义了一个 Person 基类,跟 Java class 差不多class Person {public: //公共的属性 Person(); ~Person(); Person(char *name, char *gen, int age); char *name; char *gen; int age; void setName(char *name); char *getName(); void setGen(char *gen); char *getGen(); void setAge(int age); int getAge(); /** * 虚函数 是在基类中使用关键字 virtual 声明的函数。 * 在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 * @return */ //virtual 转移给子类实现 virtual int test() { return 10; };};//2. 定义 DevYK 派生类class DevYK : public Person {public: DevYK(char *name, int age) : Person(name, \"nan\", age) {}; int length; DevYK(); ~DevYK(); char *getPersonName(); void setLength(int len); int getLength(); DevYK operator+(const DevYK &amp;b); char *getName(); int test() { return -10; };};//3. .cpp 文件#include \"ClssSample.h\"#include &lt;iostream&gt;using namespace std;Person::Person(char *name, char *gen, int age) { this-&gt;name = name; this-&gt;age = age; this-&gt;gen = gen;}Person::~Person() { cout &lt;&lt; \"Person 销毁\" &lt;&lt; endl;}Person::Person() { cout &lt;&lt; \"执行 Person 空参构造函数\" &lt;&lt; endl;}void Person::setAge(int age) { this-&gt;age = age;}void Person::setName(char *name) { this-&gt;name = name;}void Person::setGen(char *gen) { this-&gt;gen = gen;}char *Person::getName() { return this-&gt;name;}char *Person::getGen() { return this-&gt;gen;}int Person::getAge() { return this-&gt;age;}DevYK::DevYK() { cout &lt;&lt; \"执行 DevYK 空参构造函数\" &lt;&lt; endl;}DevYK::~DevYK() { cout &lt;&lt; \"DevYK 销毁\" &lt;&lt; endl;}char *DevYK::getName() { cout &lt;&lt; \"DevYK getName\" &lt;&lt; endl; return this-&gt;name;}char *DevYK::getPersonName() { return this-&gt;name;}void DevYK::setLength(int len) { this-&gt;length = len;}int DevYK::getLength() { return this-&gt;length;}// 重载 + 运算符，用于把两个 Box 对象相加class DevYK DevYK::operator+(const class DevYK &amp;b) { DevYK devYk; devYk.length = this-&gt;length + b.length; return devYk;}//3. 测试void test22() { //父类 Person *person; //定义子类 DevYK devYk(\"DevYK\", 27); if (person) { cout &lt;&lt; \"Person\\t\" &lt;&lt; person-&gt;getName() &lt;&lt; \"\\t\" &lt;&lt; person-&gt;getGen() &lt;&lt; \"\\t\" &lt;&lt; person-&gt;getAge() &lt;&lt; endl; } cout &lt;&lt; \"DevYK-&gt;\\t\" &lt;&lt; devYk.getName() &lt;&lt; \"\\t\" &lt;&lt; devYk.getGen() &lt;&lt; \"\\t\" &lt;&lt; devYk.getAge() &lt;&lt; endl; //把 devyk 的内存地址赋值给 person person = &amp;devYk; if (person) { cout &lt;&lt; \"Person\\t\" &lt;&lt; person-&gt;getName() &lt;&lt; \"\\t\" &lt;&lt; person-&gt;getGen() &lt;&lt; \"\\t\" &lt;&lt; person-&gt;getAge() &lt;&lt; endl; } cout &lt;&lt; \"DevYK 内存地址-&gt;\\t\" &lt;&lt; &amp;devYk &lt;&lt; \" Person 内存地址\\t\" &lt;&lt; person &lt;&lt; endl; //获取子类数据 int test = person-&gt;test(); cout &lt;&lt; \"test-&gt;\\t\" &lt;&lt; test &lt;&lt; endl;} 输出: DevYK-&gt; DevYK getNameDevYK nan 27Person DevYK nan 27DevYK 内存地址-&gt; 0x7ffee1d26628 Person 内存地址 0x7ffee1d26628test-&gt; -10DevYK 销毁Person 销毁 虚函数: 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 纯虚函数: 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 26. 数据封装所有的 C++ 程序都有以下两个基本要素： 程序语句（代码）：这是程序中执行动作的部分，它们被称为函数。 程序数据：数据是程序的信息，会受到程序函数的影响。 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。 数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。 C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如： 123456789101112class Box{ public: double getVolume(void) { return length * breadth * height; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度}; 变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。 为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 public 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。 把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。 1234567891011121314151617181920212223242526272829//1. .hclass Box{ public: double getVolume(void) { return length * breadth * height; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度};//2. .cppdouble Box::getVolume() { return this-&gt;length * this-&gt;height * this-&gt;width;}void Box::initValue() { //默认 int a = 10, b = 20, c = 30; length = a, width = b, height = c;}//3. cpp 测试void test23() { Box box; box.initValue(); cout &lt;&lt; \"数据私有封住:\" &lt;&lt; box.getVolume() &lt;&lt; endl;} 输出: 数据私有封住:6000 27. 接口(抽象类)接口描述了类的行为和功能，而不需要完成类的特定实现。 C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。 例子参考 25 小节的多态。 28. 文件和流到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 1void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法： 12ofstream outfile;outfile.open(\"file.dat\", ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法： 12ifstream afile;afile.open(\"file.dat\", ios::out | ios::in ); 关闭文件: 当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 1void close(); 写入文件: 在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 读取文件: 在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 读取 &amp; 写入实例: 1234567891011121314151617181920212223242526void test24() { char data[100]; //ofstream: 用于创建文件并向文件写入信息。 ofstream outfile; outfile.open(\"/Users/devyk/Data/ClionProjects/NDK_Sample/README.md\"); cout &lt;&lt; \"请输入写入文件的内容：\" &lt;&lt; endl; cin.getline(data, 100); //向文件开始写入数据 outfile &lt;&lt; data &lt;&lt; endl; cin.ignore(); //关闭打开的文件 outfile.close(); cout &lt;&lt; \"\\n\\n\" &lt;&lt; endl; char readData[100]; //开始读文件 ifstream readFile; readFile.open(\"/Users/devyk/Data/ClionProjects/NDK_Sample/README.md\"); readFile.getline(readData, 100); cout &lt;&lt; \"读取成功\\n\" &lt;&lt; readData &lt;&lt; endl; readFile.close();} 29. 异常处理异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示： 12345678910111213try{ // 保护代码}catch( ExceptionName e1 ){ // catch 块}catch( ExceptionName e2 ){ // catch 块}catch( ExceptionName eN ){ // catch 块} 如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。 抛出异常: 您可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。 以下是尝试除以零时抛出异常的实例： 12345678double division(int a, int b){ if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b);} 捕获异常: catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。 1234567try{ // 保护代码}catch( ExceptionName e ){ // 处理 ExceptionName 异常的代码} 下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std; double division(int a, int b){ if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b);} int main (){ int x = 50; int y = 0; double z = 0; try { z = division(x, y); cout &lt;&lt; z &lt;&lt; endl; }catch (const char* msg) { cerr &lt;&lt; msg &lt;&lt; endl; } return 0;} 由于我们抛出了一个类型为 const char* 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果： 输出: Division by zero condition! 自定义异常: 您可以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常： 1234567891011121314151617181920212223242526//自定义一个新的异常class MyException : public std::exception{public: const char* what() const throw(){ return \"C++ 操作失误，请检查代码是否正确!\"; }};//测试:void test25() { try { throw \"空指针异常\"; } catch (const char *msg) { cout &lt;&lt; \"错误日志:\\t\" &lt;&lt; msg &lt;&lt; endl; } //自定义异常 try { throw MyException(); } catch (MyException exception) { cout &lt;&lt; \"自定义异常:\" &lt;&lt; exception.what() &lt;&lt; endl; } catch (exception &amp;error) { cout &lt;&lt; \"其它异常:\" &lt;&lt; error.what() &lt;&lt; endl; }} 输出: 错误日志: 空指针异常自定义异常:C++ 操作失误，请检查代码是否正确! 30. 动态内存了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分： 栈：在函数内部声明的所有变量都将占用栈内存。 堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。 很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。 在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。 如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 new 和 delete 运算符: 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法： 1new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点： 12double* pvalue = NULL; // 初始化为 null 的指针pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： 1234567double* pvalue = NULL;if( !(pvalue = new double )){ cout &lt;&lt; \"Error: out of memory.\" &lt;&lt;endl; exit(1); } malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示： 1delete pvalue; // 释放 pvalue 所指向的内存 下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符： 123456789101112131415161718192021222324void test26() { //演示如何使用 new 和 delete 运算符： //初始化为 null 的指针 double *pvalue = NULL; //为变量申请内存 pvalue = new double; //在分配的地址存储值 *pvalue = 1314.520; //打印存储的数字 cout &lt;&lt; \"pvalue 的地址值为:\\t\" &lt;&lt; &amp;pvalue &lt;&lt; \"\\n在该地址存储的值为:\\t\" &lt;&lt; *pvalue &lt;&lt; endl; //释放内存 delete pvalue; //数组的动态内存分配 //动态分配，数组长度为 10 int *array = new int[10]; //释放数组内存 delete[] array; //对象的动态内存分配 Box *testBox = new Box[10]; delete[] testBox;} 输出: pvalue 的地址值为: 0x7ffee8b27658在该地址存储的值为: 1314.52 pvalue 的地址值为: 0x7ffee7b8c658在该地址存储的值为: 1314.52调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！ 31. 命名空间定义命名空间: 命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示： 123namespace namespace_name { // 代码声明} 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示： 1name::code; // code 可以是变量或函数 让我们来看看命名空间如何为变量或函数等实体定义范围： 1234567891011121314151617//1. 定义命名空间namespace test1_space { void func() { cout &lt;&lt; \"test1_space\" &lt;&lt; endl; }}namespace test2_space { void func2() { cout &lt;&lt; \"test2_space\" &lt;&lt; endl; }}void test27() { test1_space::func(); test2_space::func2();} 输出: test1_spacetest2_space using 指令: 您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。 1234567891011121314151617181920212223//1. 定义命名空间namespace test1_space { void func() { cout &lt;&lt; \"test1_space\" &lt;&lt; endl; }}namespace test2_space { void func2() { cout &lt;&lt; \"test2_space\" &lt;&lt; endl; }}//2. 使用 using 指令using namespace test1_space;using namespace test2_space;void test27() { //1. test1_space::func(); test2_space::func2(); //2. func(); func2();} 输出: test1_spacetest2_space test1_spacetest2_space 32. 预处理器预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。 所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。 我们已经看到，之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。 C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。 define 预处理: define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： 1#define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如： 12345//1. 预处理器#define MAX 100;void test28() { cout &lt;&lt; \"通过预处理器定义了一个 MAX:\" &lt;&lt; MAX;} 输出: 通过预处理器定义了一个 MAX:100 参数宏: 您可以使用 #define 来定义一个带有参数的宏，如下所示： 12345//2. 参数宏#define MAX_VALUE(a, b)(a&gt;b?a:b);void test28() { cout &lt;&lt; \"\\n通过预处理器定义了一个 MAX_VALUE:\" &lt;&lt; MAX_VALUE(10, 20);} 输出: 通过预处理器定义了一个 MAX_VALUE:20 条件编译: 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。 条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码： 1234//3. 条件编译#ifdef NULL#define NULL 0#endif 33. 多线程多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行。 基于线程的多任务处理是同一程序的片段的并发执行。 多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。 本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。 创建线程: 下面的程序，我们可以用它来创建一个 POSIX 线程： 12#include &lt;pthread.h&gt;pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明： 参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。 终止线程: 使用下面的程序，我们可以用它来终止一个 POSIX 线程： 12#include &lt;pthread.h&gt;pthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。 如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。 1234567891011121314151617181920212223242526//定义一个线程数量宏#define NUM_THREADS 5//线程的运行函数void *logD(void * args) { int threadID = *((int*)args); cout &lt;&lt; \"线程执行了\" &lt;&lt; threadID &lt;&lt; endl;}void test29() { //定义线程的 ID 变量，多个变量使用数组 pthread_t tids[NUM_THREADS]; for (int i = 0; i &lt; NUM_THREADS; ++i) { //参数依次是：创建的线程 id,线程参数，调用的函数，传入的参数函数 int ptc = pthread_create(&amp;tids[i],NULL,logD,(void*)&amp;(i)); if(0!=ptc){ cout &lt;&lt; \"pthread_create error:error code ：\" &lt;&lt; ptc &lt;&lt; endl; } } //等线程执行完毕后在释放线程 pthread_exit(NULL);} 输出: 线程执行了线程执行了5线程执行了55线程执行了5线程执行了5 总结这里差不多 C++ 基础都讲解完了，面向对象思想还是很好理解的，下来大家一定要好好消化，下一个开始就开始使用 AS 学习 JNI 知识了。 参考 C++ 关键字介绍 C++ 实例练习 [C++ 基础入门","link":"/2020/06/04/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E4%BA%8C-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"关于我","slug":"关于我","link":"/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"name":"webrtc","slug":"webrtc","link":"/tags/webrtc/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"音视频学习路线","slug":"音视频学习路线","link":"/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"}],"categories":[{"name":"README","slug":"README","link":"/categories/README/"},{"name":"服务","slug":"服务","link":"/categories/%E6%9C%8D%E5%8A%A1/"},{"name":"专题","slug":"专题","link":"/categories/%E4%B8%93%E9%A2%98/"},{"name":"apprtc","slug":"服务/apprtc","link":"/categories/%E6%9C%8D%E5%8A%A1/apprtc/"},{"name":"性能优化","slug":"专题/性能优化","link":"/categories/%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"音视频","slug":"专题/音视频","link":"/categories/%E4%B8%93%E9%A2%98/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"面试","slug":"专题/面试","link":"/categories/%E4%B8%93%E9%A2%98/%E9%9D%A2%E8%AF%95/"},{"name":"nginx","slug":"服务/nginx","link":"/categories/%E6%9C%8D%E5%8A%A1/nginx/"},{"name":"Android","slug":"专题/面试/Android","link":"/categories/%E4%B8%93%E9%A2%98/%E9%9D%A2%E8%AF%95/Android/"}]}